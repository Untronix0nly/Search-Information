строковый тип нить вереница тип данных значениями которого является произвольная строка символов алфавита каждая переменная такого типа строковая переменная может быть представлена фиксированным количеством байтов либо иметь произвольную длину представление памяти некоторые языки накладывают ограничения на максимальную длину строки но большинстве языков подобные ограничения отсутствуют при использовании unicode каждый символ строкового типа может требовать двух или даже четырёх байтов для своего представления основные проблемы машинном представлении строкового типа строки могут иметь достаточно существенный размер до нескольких десятков мегабайтов изменяющийся со временем размер возникают трудности добавлением удалением символов представлении строк памяти компьютера существует два принципиально разных подхода представление массивом символов этом подходе строки представляются массивом символов при этом размер массива хранится отдельной служебной области от названия языка pascal где этот метод был впервые реализован данный метод получил название pascal strings слегка вариантом этого метода является формат addr от применяемый форте отличие от pascal strings здесь размер массива хранится не совместно со строковыми данными является частью указателя на строку преимущества программа каждый момент времени содержит сведения размере строки поэтому операции добавления символов конец копирования строки собственно получения размера строки выполняются достаточно быстро строка может содержать любые данные возможно на программном уровне следить за выходом за границы строки при её обработке возможно быстрое выполнение операции вида взятие ого символа конца строки недостатки проблемы хранением обработкой символов произвольной длины увеличение затрат на хранение строк значение длина строки также занимает место случае большого количества строк маленького размера может существенно увеличить требования алгоритма оперативной памяти ограничение максимального размера строки современных языках это ограничение скорее теоретическое так как обычно размер строки хранится битовом поле что даёт максимальный размер строки байт гигабайта при использовании алфавита переменным размером символа например utf размере хранится не количество символов именно размер строки байтах поэтому количество символов необходимо считать отдельно метод завершающего байта второй метод заключается использовании завершающего байта одно из возможных значений символов алфавита как правило это символ кодом выбирается качестве признака конца строки строка хранится как байтов от начала до конца есть системы которых качестве признака конца строки используется не символ байт xff или код символа метод имеет три названия asciiz или asciz символы кодировке ascii нулевым завершающим байтом strings наибольшее распространение метод получил именно языке си метод нуль терминированных строк преимущества отсутствие дополнительной служебной информации строке кроме завершающего байта возможность представления строки без создания отдельного типа данных отсутствие ограничения на максимальный размер строки экономное использование памяти простота получения суффикса строки простота передачи строк функции передаётся указатель на первый символ недостатки долгое выполнение операций получения длины конкатенации строк отсутствие средств контроля за выходом за пределы строки случае повреждения завершающего байта возможность повреждения больших областей памяти что может привести непредсказуемым последствиям потере данных краху программы даже всей системы невозможность использовать символ завершающего байта качестве элемента строки невозможность использовать некоторые кодировки размером символа несколько байт например utf во многих таких символах например один из байтов равен нулю то же время кодировка utf свободна от этого недостатка использование обоих методов таких языках как например оберон строка размещается массиве символов определённой длины причём её конец обозначается нулевым символом по умолчанию весь массив заполнен нулевыми символами такой способ позволяет объединить многие преимущества обоих подходов также избежать большинство их недостатков представление виде списка языки erlang haskell пролог используют для строкового типа список символов этот метод делает язык более теоретически элегантным за счёт соблюдения ортогональности системе типов но приносит существенные потери быстродействия реализация языках первых языках вообще не было строкового типа программист должен был сам строить функции для работы со строками того или другого типа си используются нуль терминированные строки полным ручным контролем со стороны программиста стандартном паскале строка выглядит как массив из байтов первый байт хранил длину строки остальных хранится её тело таким образом длина строки не может превышать символов borland pascal также появились строки ля си очевидно из за того что число поддерживаемых платформ вошла windows object pascal stl строка является чёрным ящиком котором выделение высвобождение памяти происходит автоматически без участия программиста при создании строки память выделяется автоматически как только на строку не останется ни одной ссылки память возвращается системе преимущество этого метода том что программист не задумывается над работой строк другой стороны программист имеет недостаточный контроль над работой программы критичных скорости участках также трудно реализуется передача таких строк качестве параметра dll также object pascal автоматически следит чтобы конце строки был символ кодом поэтому если функция требует на входе нуль терминированную строку для конвертации надо просто написать pansichar или pwidechar для pascal переменная c_str для builder stl других языках со сборкой мусора строка является неизменяемым объектом если строку нужно модифицировать создаётся другой объект этот метод медленный расходует немало временной памяти но хорошо сочетается концепцией сборки мусора преимущество этого метода том что присваивание происходит быстро без дублирования строк также имеется некоторый ручной контроль над строк java например через классы stringbuffer stringbuilder это позволяет уменьшить количество выделений высвобождений памяти соответственно увеличить скорость некоторых языках например standard ml кроме этого есть дополнительный модуль для обеспечения ещё большей эффективности подстрока substring его использование позволяет выполнять операции над строками без копирования их тел посредством манипулирования индексами начала конца подстроки физическое копирование происходит лишь при необходимости преобразовании подстрок строки операции простейшие операции со строками получение символа по номеру позиции индексу большинстве языков это тривиальная операция конкатенация соединение строк производные операции получение подстроки по индексам начала конца проверка вхождения одной строки другую поиск подстроки строке проверка на совпадение строк учётом или без учёта регистра символов получение длины строки замена подстроки строке операции при трактовке строк как списков свёртка отображение одного списка на другой фильтрация списка по критерию более сложные операции нахождение минимальной надстроки содержащей все указанные строки поиск двух массивах строк совпадающих задача плагиате возможные задачи для строк на естественном языке сравнение на близость указанных строк по заданному критерию определение языка кодировки текста на основании вероятностей символов слогов представление символов строки до последнего времени один символ всегда кодировался одним байтом двоичных битов применялись также кодировки битами на символ что позволяло представлять при семибитной кодировке возможных значений однако для полноценного представления символов алфавитов нескольких языков многоязыковых документов типографских символов несколько видов кавычек тире нескольких видов пробелов для написания текстов на иероглифических языках китайском японском корейском символов недостаточно для решения этой проблемы существует несколько методов переключение языка управляющими кодами метод не лишает текст то есть символов без управляющего кода начале теряет смысл использовался некоторых ранних русификациях zx spectrum бк использование двух или более байт для представления каждого символа utf utf главным недостатком этого метода является потеря совместимости предыдущими библиотеками для работы текстом при представлении строки как asciiz например концом строки должен считаться уже не байт со значением два или четыре подряд идущих нулевых байта то время как одиночный байт может встречаться середине строки что сбивает библиотеку толку использование кодировки переменным размером символа например utf часть символов представляется одним байтом часть двумя тремя или четырьмя этот метод позволяет сохранить частичную совместимость со старыми библиотеками нет символов внутри строки поэтому можно использовать как признак конца строки но приводит невозможности прямой адресации символа памяти по номеру его позиции строке примечания см также нуль терминированная строка пустая строка текстовые данные свободная полугруппа порядок алгоритмы на строках слово математика широкий символ категория типы данных