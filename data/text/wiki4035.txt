приведе ние преобразование ти па информатике преобразование значения одного типа значение другого типа описание выделяют приведения типов явные неявные явное приведение задаётся программистом тексте программы помощью конструкции языка функции принимающей значение одного типа возвращающей значение другого типа неявное приведение выполняется транслятором компилятором или интерпретатором по правилам описанным стандарте языка стандарты большинства языков запрещают неявные преобразования слабо типизированных объектно ориентированных языках таких как механизм наследования реализуется посредством приведения типа указателя на текущий объект базовому классу типобезопасных таких как ocaml понятие приведении типов отсутствует принципиально допустимость обращения компоненту подтипа контролируется механизмом проверки согласования типов на этапе компиляции машинном коде остаётся прямое обращение неявное приведение типа неявное приведение типа языках неявное приведение типов происходит следующих случаях после вычисления операндов бинарных арифметических логических битовых операций операций сравнения также го или го операнда операции значения операндов приводятся одинаковому типу перед выполнением присваивания перед передачей аргумента функции перед возвратом функцией возвращаемого значения после вычисления выражения конструкции значение приводится целочисленному типу после вычисления выражений конструкций значение приводится типу например при выполнении бинарной арифметической операции значения операндов приводятся одному типу при наследовании указатели производного класса приводятся указателям базового класса рассмотрим пример на языке double вещественный тип long целый тип int целый тип if if if при выполнении операций сравнения при присваивании переменные разных типов неявно приводятся одному типу при неявных преобразованиях возможны побочные эффекты например при приведении числа вещественного типа целому типу дробная часть отсекается округление не выполняется при обратном преобразовании возможно понижение точности из за различий представлении вещественных целочисленных чисел например переменной типа число плавающей точкой одинарной точности по стандарту ieee нельзя сохранить число без потери точности битной переменной целого типа можно из за потери точности операции сравнения одного того же числа представленного целым вещественным типами например могут давать ложные результаты числа могут быть не равны include int main void int i_value float f_value printf the integer is i_value printf the float is f_value printf their equality i_value f_value приведённый код выведет следующее если размер бита компилятор поддерживает стандарт ieee the integer is the float is their equality явное приведение типа приведения типов языке для явного приведения типов имя типа указывается круглых скобках перед переменной или выражением рассмотрим пример int int char int переменная приводится типу int для вычисления последнего выражения компилятор выполняет примерно следующие действия сначала переменная символьного типа явно приводится целочисленному типу путём расширения разрядности выполняется вычисление операндов для операции умножения левый операнд имеет тип правый операнд константа такие константы по умолчанию имеют тип так как оба операнда оператора имеют тип неявное приведение типов не выполняется результат умножения тоже имеет тип выполняется вычисление операндов операции сложения левый операнд результат умножения имеет тип правый операнд переменная имеет тип так как оба операнда оператора имеют тип неявное приведение общему типу не выполняется результат сложения тоже имеет тип выполнение присваивания левый операнд переменная имеет тип правый операнд результат вычисления выражения записанного справа от знака тоже имеет тип так как оба операнда оператора имеют одинаковый тип неявное приведение типов не выполняется но даже при этом возможны ошибки тип может быть как знаковым так беззнаковым результат зависит от реализации компилятора такое поведение разрешено стандартом значение беззнакового типа при преобразовании знаковому типу может оказаться отрицательным из за особенностей реализации машинных инструкций на некоторых процессорах чтобы избежать рекомендуется явно указывать знаковость для типа приведения типов языке языке существует пять операций для явного приведения типа первая операция круглые скобки поддерживается для сохранения совместимости остальные четыре операции записываются виде xxx_cast expression_from рассмотрим пример static_cast переменной будет присвоено значение громоздкие ключевые слова являются напоминанием программисту том что приведение типа чревато проблемами операция static_cast назначение допустимые приведения типов операция аналогична операции круглые скобки одним исключением она не выполняет приведение указателей на неродственные типы для этого применяется операция применение преобразование между числовыми enum том числе если неявное преобразование невозможно или приводит предупреждению возможная потеря точности приведение указателей типу наоборот приведение указателей на производные типы указателям на базовые типы наоборот выбор одной из нескольких перегруженных функций bool myless const wchar_t const wchar_t bool myless const std wstring const std wstring std vector list std sort list begin list end static_cast myless явный вызов конструктора одним аргументом или перегруженной операции приведения типа struct type конструктор одним аргументом для приведения типа int типу type type int перегруженная операция для приведения типа type типу double operator double const int main type int double вызов конструктора одним аргументом static_cast вызов перегруженной операции приведения типа static_cast return конструктор может иметь большее число аргументов но для них должны быть заданы значения по умолчанию struct type конструктор несколькими аргументами для приведения типа type типу int для го последующих аргументов заданы значения по умолчанию type int int float приведение типа шаблонах компилятор уже при специализации шаблона решает какие операции использовать приведение операндов тернарной условной операции одному типу значения го го операндов должны иметь одинаковый тип ограничения на expression_from нет ограничения на type_to должен существовать способ преобразования значения выражения expression_from типу type_to помощью operator type_to или конструктора производит ли операция код общем случае да например вызов перегруженной операции приведения типа или конструктора источники логических ошибок не исключено что после преобразования типа появится временный объект который будет благополучно уничтожен со всеми изменениями большинство компиляторов при этом выдают предупреждение при преобразовании чисел возможны переполнения примеры получить процент попаданий double hitpercent const int ahitcount число попаданий const int ashotcount число выстрелов if ashotcount return приведение типов double выполняется для выполнения вещественного не целочисленного деления return static_cast ahitcount static_cast ashotcount следующие строчки эквивалентны использование операции static_cast string static_cast hello вызов конструктора одним аргументом string string hello использование операции круглые скобки string string hello string static_cast не компилируется компилятор не может найти подходящий конструктор операция dynamic_cast назначение приведение вниз по иерархии наследования особым поведением если объект не имеет нужного типа операция получает информацию типе объекта expression_from помощью rtti если тип будет type_to или его подтипом приведение выполняется иначе для указателей возвращается null для ссылок создаётся исключение ограничения на expression_from выражение должно быть ссылкой или указателем на объект имеющий хотя бы одну виртуальную функцию ограничения на type_to ссылка или указатель на дочерний по отношению expression_from тип производит ли операция код да логические ошибки возможны если операции передать аргумент не имеющий тип type_to не проверить указатель на равенство соответственно не обработать исключение операция const_cast назначение снятие установка модификатора ов или часто это применяется чтобы обойти неудачную архитектуру программы или библиотеки для стыковки си си для передачи информации через обобщённые указатели void ограничения на expression_from выражение должно возвращать ссылку или указатель ограничения на type_to тип type_to должен совпадать типом выражения expression_from точностью до модификатора ов производит ли операция код нет источники логических ошибок программа может изменить неизменяемый объект иногда это может привести ошибке сегментации иногда подпрограмма может не ожидать что память которую она предоставила для чтения вдруг изменили для примера рассмотрим код динамической библиотеки include string using namespace std namespace string wikipedia глобальная переменная метод string c_str возвращает указатель типа const char typedef char pchar void dllexport winapi somedllfunction pchar rmessage преобразование char const char rmessage const_cast c_str при загрузке библиотеки память процесса создаёт новый сегмент данных котором размещаются глобальные переменные код функции находится библиотеке при вызове возвращает указатель на скрытый член глобального объекта класса операция используется для удаления модификатора операция назначение каламбур типизации назначение ячейке памяти другого типа не обязательно совместимого данным сохранением битового представления объект возвращаемый выражением expression_from рассматривается как объект типа type_to ограничения на expression_from выражение должно возвращать значение порядкового типа любой из целых логический или перечислимый указатель или ссылку ограничения на type_to если expression_from возвращает значение порядкового типа или указатель тип type_to может быть порядковым типом или указателем если expression_from возвращает ссылку тип type_to должен быть ссылкой производит ли операция код нет источники логических ошибок объект возвращаемый выражением expression_from может не иметь типа type_to нет никакой возможности проверить это всю ответственность за корректность преобразования программист берёт на себя рассмотрим примеры возвращает true если число конечное возвращает false если число равно или nan bool isfinite double const преобразование double const uint const uint const return uint ff uint ff попытка получения адреса временного значения long const ошибка выражение не является ссылкой см также dynamic cast динамическая идентификация типа данных rtti типизация данных каламбур типизации примечания ссылки robert seacord пint understand integer conversion rules cert org категория типы данных категория концепции языков категория статьи примерами кода категория операции