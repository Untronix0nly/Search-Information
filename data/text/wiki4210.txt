ocaml objective caml современный объектно ориентированный язык функционального общего назначения который был разработан учётом безопасности исполнения надёжности программ этот язык имеет высокую степень выразительности что позволяет его легко выучить использовать язык caml поддерживает функциональную императивную объектно ориентированную парадигмы был разработан году во французском институте inria который занимается исследованиями области информатики самый практической работе диалект языка ml инструментарий ocaml включает себя интерпретатор компилятор байткод оптимизирующий компилятор машинный код сравнимый по эффективности java лишь немного уступающий по быстродействию на языке ocaml частности написан рендеринг формул википедии использующих тег файлообменный клиент mldonkey стек управления гипервизором xen xapi является частью xen server xen cloud platform язык haxe языке место роль информатике язык ocaml является языком общего назначения но при этом имеет свои сложившиеся области применения во первых это создание безопасных не только смысле информационной безопасности приложений языке используется сборка мусора большинство типов данных являются ссылочными что означает предотвращение переполнения буферов во время исполнения программы кроме того статическая типизация проверки времени компиляции делают невозможными некоторые другие классы ошибок такие как ошибки приведения типов силу отсутствия автоматического приведения типов кроме того код может быть формально верифицирован имеются утилиты автоматического доказательства типовой корректности кода превосходящие таковые для большинства языков что немаловажно меры безопасности не влияют на эффективность исполняемого кода другой областью успешного применения ocaml являются приложения управляемые данными data driven этой области относится обработка текста также написание компиляторов ocaml имеет не только средства для текстовой обработки какими славится например perl или awk но инструменты для глубокого семантического анализа преобразования текста что делает ocaml применимым задачах анализа данных разумеется ocaml как другие диалекты ml используются задачах задачах верификации при котором основной код пишется на некотором языке затем формально верифицируется анализируется программой на ocaml например на ocaml написана система интерактивного доказательства теорем coq основные свойства ocaml занимает особое место среди языков благодаря сочетанию эффективности выразительности практичности среди особенностей языка развивавшихся течение более чем лет со времени создания ml можно выделить статическая проверка типов параметрический полиморфизм функции первого класса алгебраические типы данных сопоставление образцом поддержка неизменяемыми структурами данных автоматическая сборка мусора эффективный компилятор машинный код без применения jit компиляции история ocaml ведёт своё происхождение от ml который был реализован на диалекте лиспа робином милнером году качестве программного средства для доказательства теорем как метаязык логики вычислимых функций lcf позднее был сделан компилятор году ml стал полноценной системой ги кузино guy cousineau добавил язык алгебраические типы данных сопоставление образцом определил ml виде категориальной абстрактной машины cam таким образом cam ml мог быть описан верифицирован оптимизирован что явилось шагом вперёд для ml дальнейшим развитием был созданный году аскандером суарецом ascánder suárez продолженный пьером вейсом pierre weis мичелом мони michel mauny язык caml переигранное cam ml году ксавье лерой xavier leroy дамьен долигез damien doligez выпустили новую реализацию названную caml light этой реализации на си использовался интерпретатор байт кода быстрый сборщик мусора написанием библиотек язык стал использоваться образовании институтах году увидел свет caml special light развиваемый лероем система получила компилятор машинные коды что поставило эффективность исполняемого кода один ряд другими компилируемыми языками то же время была разработана система модулей идея которой была заимствована из standard ml современном виде ocaml появился году когда дидье реми didier rémy джером вуйон jérôme vouillon реализовали для языка стройную эффективную поддержку объектов эта объектная система позволяет на этапе компиляции типобезопасной манере использовать идиомы объектно без свойственных java проверок времени выполнения годах язык плавно развивался одновременно получая всё большее признание коммерческих проектах образовании среди разработанного это время можно отметить полиморфные методы вариантный типы именованные необязательные параметры модули первого класса обобщённые алгебраические типы данных gadt язык стал поддерживать несколько аппаратных платформ arm sparc powerpc базовая семантика модель вычислений ocaml как языка функционального строится на трёх основных конструкциях лямбда исчисления переменных определениях функций применении функции аргументам переменные переменная идентификатор значение которого связано определённой величиной имена переменных начинаются со строчной буквы или подчёркивания привязка обычно выполняется помощью ключевого слова let как следующем примере интерактивной оболочке let переменные имеют область видимости например интерактивной оболочке переменную можно использовать следующих за её привязкой командах аналогично переменную определённую модуле можно использовать после определения данном модуле привязка переменной может быть осуществлена области видимости заданной конструкцией let in как следующем примере по вычислению площади круга по радиусу let area radius let pi in radius radius pi val area float float area float ocaml привязки переменных являются неизменяемыми как математических уравнениях то есть значение переменной присваивается только один раз единичное присваивание другое дело что внутри let in может быть другой let in котором вводится другая переменная которая может затенить первую функции для определения функций ocaml есть несколько синтаксических конструкций функции можно определить помощью ключевого слова function выражение для функции выглядит следующим образом function данном случае функция анонимная её можно использовать качестве параметров других функций или применить некоторому аргументу например function типом этой функции является int int то есть функция принимает целое возвращает целое функция может иметь несколько аргументов function этом примере её тип int int int то есть на входе функции пара на выходе целое есть другой подход представления функций нескольких аргументов преобразование арной функции функций одного аргумента каррирование следующие два вида записи функции вычисляющей произведение целочисленных аргументов эквивалентны function function fun именованные функции можно получить связав переменную функцией определение именованной функции настолько частая операция что имеет отдельную синтаксическую поддержку следующие три записи эквивалентные способы определить функцию интерактивной оболочке let prod function function val prod int int int let prod val prod int int int let prod fun val prod int int int функции двух аргументов можно определить для использования инфиксной записи let val float float float float float этом примере определена функция вычисляющая сумму квадратов двух чисел плавающей запятой последние два вида записи эквивалентны рекурсивные функции то есть функции ссылающиеся на своё же определение можно задать помощью let rec let rec fac match with fac этом же примере вычисления факториала применено сопоставление образцом конструкция match with аргументы функции можно определить как именованные именованные аргументы можно указывать любом порядке let divmod mod val divmod int int int int divmod int int divmod int int ocaml можно опускать значения используя уплотнённую запись если имя параметра переменной совпадают let in let in divmod int int выражения ассоциативность операций выражениях ocaml определяется префиксом распространяясь таким образом на операции определённые пользователем знак работает как префиксная так инфиксная операция причём при необходимости использовать качестве префикса совместно применением функции параметр нужно заключить скобки префикс операции ассоциативность префикс применение функции конструктора метки assert lazy левая префикс lsl lsr asr правая mod land lor lxor левая левая правая правая левая правая or правая правая if правая let match fun function try система типов примитивные типы язык ocaml имеет несколько примитивных типов числовые типы целый числа плавающей запятой символьный строки символов булевский целый тип представляет целые числа из интервала для битных архитектур соответственно целыми числами можно производить обычные операции сложения вычитания умножения деления взятия остатка от деления mod случае выхода результата за допустимый интервал ошибки не происходит результат вычисляется по модулю границы интервала числа плавающей запятой представляются битной мантиссой порядком из интервала следуя стандарту ieee для чисел двойной точностью операциях эти числа нельзя смешивать целыми кроме того операции над числами плавающей запятой синтаксически отличаются от целочисленных операций также имеется операция возведения степень для преобразования целых чисел числа плавающей запятой обратно доступны функции float_of_int int_of_float для чисел плавающей запятой имеются другие математические функции sin cos tan asin acos atan округления ceil floor exp логарифмические log log также извлечение квадратного корня sqrt для числовых типов имеются полиморфные операции сравнения символьный тип char соответствует представлению символа кодом от до первые символов совпадают ascii строчный тип string символов максимальная длина пример использованием функции преобразования целого строке операции конкатенации example string_of_int string example булевский тип имеет два значения true истина false ложь операции над величинами булевского типа унарная not отрицание бинарные или бинарные операции вычисляют сначала левый аргумент правый только если требуется булевские значения получаются результате сравнений структурное равенство тождество отрицание структурного равенства отрицание тождества для примитивных типов кроме строк чисел плавающей точкой структурное равенство тождество совпадают для других типов тождественными считаются значения располагающиеся по одному адресу памяти при структурном сравнении значения проверяются покомпонентно кроме того ocaml имеется специальный тип unit который имеет всего одно значение списки ocaml список конечная неизменяемая элементов одного типа реализованная как односвязный список следующий пример демонстрирует синтаксис списка char list char list char list list операция позволяет построить список на основе нового элемента хвоста старого списка при этом старый список не изменяется let lst val lst int list let lst lst val lst int list lst int list lst int list пример вычисление суммы элементов списка список является одним из основных типов данных ocaml следующий пример кода определяет рекурсивную обратите внимание на ключевое слово rec функцию которая перебирает элементы данного списка возвращает их сумму let rec sum xs match xs with xs sum xs sum int другой способ подсчёта суммы заключается использовании функции свёртки let sum xs list fold_left xs sum int записи записи являются важным элементом системе типов ocaml запись представляет собой набор хранимых вместе значений при котором каждый элемент значения записи доступен по своему имени имени поля записи пример описания типа связывания записи переменной доступ полю записи type user login string password string nick string let usr login myuser password secret nick aka val usr user login myuser password secret nick aka usr nick string aka следует заметить что тип переменной usr был установлен компилятором автоматически как случае другими типами тип может быть параметризован другие возможности записей сопоставление образцом irrefutable синтаксические уплотнение полей field punning записи случае совпадения имён полей переменных повторное использование полей разрешение неоднозначности помощью модулей функциональное обновление functional update записи изменяемые mutable поля fieldslib поле записи как объект первого класса итераторы полей вариантный тип вариантный тип представляет данные которые могут принимать различные формы определяемые явно заданными метками следующем примере определён тип для базовых цветов type main_color red green blue blue main_color blue red blue main_color main_color red blue примере выше вариантный тип используется качестве перечислимого типа ocaml вариантный тип тем не менее является более богатым так как помимо меток позволяет задавать данные например type color_scheme rgb of int int int cmyk of float float float float type color_scheme rgb of int int int cmyk of float float float float при определении функций вариантный тип естественно сочетается сопоставлением образцом объекты ocaml объекты их типы полностью отделены от системы классов классы используются для построения объектов поддержки наследования но не являются типами объектов объекты имеют собственные объектные типы object types для работы объектами классы применять необязательно объекты не так часто используются ocaml так система модулей является более выразительной чем объекты так как модули могут включать типы классы объекты нет основным преимуществом объектов перед записями они не требуют объявления типов обладают большей гибкостью благодаря полиморфизму строчных переменных другой стороны преимущества объектов проявляются при использовании системы классов отличие от модулей классы поддерживают позднее связывание что позволяет ссылаться на методы объекта без статически заданной реализации использовать открытую рекурсию случае модулями можно использовать функции функторы но синтаксически такие описания требуют написания большего количества кода вывод типов хотя ocaml является языком сильной типизацией система вывода типов позволяет определять тип выражения на основе имеющейся информации его компонентах следующем примере функции проверки числа на чётность не указано ни одной декларации типа тем не менее компилятора языка есть полная информация типе функции let odd mod val odd int bool императивное функции побочными эффектами хотя бо льшая часть кода может быть выполнена на ocaml чистом функциональном стиле язык позволяет программировать императивно используя побочные эффекты также алгоритмические конструкции вроде циклов следующий пример напечатает на стандартном выводе это побочный эффект функции printf строк for to do printf printf done следующем довольно искусственном примере элементы массива на месте увеличиваются на единицу цикле предусловием для индекса массива используется ссылка ref которая теле цикла let incr_ar ar let ref in while unit let nums val nums int array incr_ar nums unit nums int array хотя результатов вычислений можно достичь чисто функциональными средствами побочные эффекты позволяют оптимизировать вычисления например они позволяются организовать ленивые вычисления мемоизацию модульность ocaml можно представить себе как состоящий из двух языков язык ядра со значениями типами язык модулей их сигнатур эти языки образуют два слоя том смысле что модули могут содержать типы значения обычные значения не могут содержать модулей модулей типов тем не менее ocaml предлагает механизм модулей первого класса которые могут быть значениями при необходимости преобразуются обычные модули обратно функторы система модулей ocaml не ограничивается модульной организацией кода интерфейсами одними из важных инструментов обобщённого являются функторы упрощённо говоря функторы являются функцией из модуля модули что позволяет реализовать следующие механизмы внедрение зависимости авторасширение модулей создание экземпляра модуля некоторым состоянием примеры программ запуск интерпретатора ocaml для запуска интерпретатора языка ocaml необходимо консоли ввести следующую команду ocaml objective caml version теперь можно вводить различные выражения которые интерпретатор будет считывать вычислять выводить результат на экран int hello world следующая программа hello ml print_endline hello world может быть скомпилирована либо байт код ocamlc hello ml hello либо машинный код ocamlopt hello ml hello запущена hello hello world быстрая сортировка следующем примере приведён алгоритм быстрой сортировки который сортирует список порядке возрастания let rec qsort function pivot rest let is_less фибоначчи let rec fib_aux match with fib_aux let fib fib_aux см также mlton примечания литература список книг доступных онлайн перевод на русский язык ссылки официальный сайт языка ocaml сайт ocaml community сайт gerd stolpmann посвящённый ocaml перевод документации на русский язык перевод на русский язык книги reilly daoc emmanuel chailloux pascal manoury and bruno pagano developing applications with objective caml категория объектно ориентированные языки категория языки семейства ml категория свободные компиляторы интерпретаторы категория языки расширяемым синтаксисом