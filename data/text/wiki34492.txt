наследование англ inheritance концепция объектно согласно которой абстрактный тип данных может наследовать данные некоторого существующего типа способствуя повторному использованию компонентов программного обеспечения терминология объектно ориентированном начиная simula абстрактные типы данных называются классами класс определённый через наследование от другого класса называется производным классом классом потомком англ derived class или подклассом англ subclass класс от которого новый класс наследуется называется предком англ parent базовым классом англ base class или суперклассом англ super class применение наследование является механизмом повторного использования кода англ code reuse способствует независимому расширению программного обеспечения через открытые классы англ public classes интерфейсы англ interfaces установка отношения наследования между классами порождает иерархию классов англ class hierarchy наследование полиморфизм подтипов часто наследование отождествляют полиморфизмом подтипов англ subtyping концептуально полиморфизм подтипов устанавливает отношение является англ is relationship тем самым имитируя семантическое отношение наследования свою очередь наследование большей степени относится повторному использованию кода то есть определяет синтаксическое отношение несмотря на приведённое выше замечание наследование является широко используемым механизмом установки отношения является англ is relationship некоторые языки согласуют наследование полиморфизм подтипов основном это относится языкам со статической типизацией java scala то время как другие разделяют вышеописанные концепции наследование даже языках которые поддерживают применение наследования как механизма обеспечивающего полиморфизм подтипов не гарантирует поведенческий полиморфизм подтипов смотри принцип подстановки барбары лисков типы наследования простое наследование терминология базовые родительские классы производящие наследование потомки наследники производные классы наследуемые от базовых абстрактные классы создание объектов для некоторых языков справедлива следующая концепция существуют абстрактные классы объявляемые таковыми произвольно или из за приписанных им абстрактных методов их можно описывать имеющими поля методы создание же объектов экземпляров означает конкретизацию применимую лишь неабстрактным классам том числе неабстрактным наследникам абстрактных представителями которых по итогу будут созданные объекты пример пусть базовый класс сотрудник вуза от которого наследуются классы аспирант профессор абстрактный общие поля функции классов например поле год рождения могут быть описаны базовом классе программе будут созданы объекты только производных классов аспирант профессор обычно нет смысла создавать объекты базовых классов множественное наследование при множественном наследовании класса может быть более одного предка этом случае класс наследует методы всех предков достоинства такого подхода большей гибкости множественное наследование реализовано из других языков предоставляющих эту возможность можно отметить python eiffel множественное наследование поддерживается языке uml множественное наследование потенциальный источник ошибок которые могут возникнуть из за наличия одинаковых имён методов предках языках которые позиционируются как наследники java другие от множественного наследования было решено отказаться пользу интерфейсов практически всегда можно обойтись без использования данного механизма однако если такая необходимость всё таки возникла то для разрешения конфликтов использования наследованных методов одинаковыми именами возможно например применить операцию расширения видимости для вызова конкретного метода конкретного родителя попытка решения проблемы наличия одинаковых имён методов предках была предпринята языке eiffel котором при описании нового класса необходимо явно указывать импортируемые члены каждого из наследуемых классов их именование дочернем классе большинство современных объектно ориентированных языков java delphi другие поддерживают возможность одновременно наследоваться от класса предка реализовать методы нескольких интерфейсов одним тем же классом этот механизм позволяет во многом заменить множественное наследование методы интерфейсов необходимо переопределять явно что исключает ошибки при наследовании одинаковых методов различных классов предков единый базовый класс ряде языков все классы явно или неявно наследуются от некого базового класса smalltalk был одним из первых языков которых использовалась эта концепция таким языкам также относятся objective класс nsobject perl universal eiffel any java java lang object system object delphi tobject scala any наследование языках наследование class базовый класс class public public наследование class protected protected наследование class private private наследование существует три типа наследования public protected private спецификаторы доступа членов базового класса меняются потомках следующим образом если класс объявлен как базовый для другого класса со спецификатором доступа public public члены базового класса доступны как public члены производного класса protected члены базового класса доступны как protected члены производного класса protected public protected члены базового класса доступны как protected члены производного класса private public protected члены базового класса доступны как private члены производного класса одним из основных преимуществ public наследования является то что указатель на классы наследники может быть неявно преобразован указатель на базовый класс то есть для примера выше можно написать new эта интересная особенность открывает возможность динамической идентификации типа rtti delphi object pascal для использования механизма наследования delphi необходимо объявлении класса скобках class указать класс предок предок tancestor class private protected public виртуальная процедура procedure virtual abstract procedure staticprocedure end наследник tdescendant class tancestor private protected public перекрытие виртуальной процедуры procedure override procedure staticprocedure end абсолютно все классы delphi являются потомками класса tobject если класс предок не указан то подразумевается что новый класс является прямым потомком класса tobject множественное наследование delphi изначально принципиально не поддерживается однако для тех кому без этого не обойтись всё же имеются такие возможности например за счёт использования классов помощников сlass helpers python python поддерживает как одиночное так множественное наследование при доступе атрибуту просмотр производных классов происходит порядке разрешения метода class ancestor object предок def self pass class ancestor object предок def self pass class descendant ancestor ancestor наследник def self pass descendant инстанциация print порядок разрешения метода версии python языке сосуществуют классические классы новые классы последние являются наследниками object классические классы будут поддерживаться вплоть до версии но удалены из языка python версии множественное наследование применяется python частности для введения основной класс классов примесей php для использования механизма наследования php необходимо объявлении класса после имени объявляемого класса наследника указать слово extends имя класса предка class descendant extends ancestor случае перекрытия классом наследником методов предка доступ методам предка можно получить использованием ключевого слова parent class function example echo вызван метод example class extends function example echo вызван метод example parent example можно предотвратить перекрытие классом наследником методов предка для этого необходимо указать ключевое слово final class final function example echo вызван метод example class extends function example вызовет ошибку parent example никогда не выполнится чтобы при наследовании обратиться конструктору родительского класса необходимо дочернему классу конструкторе указать parent objective interface nsobject void example end implementation void example nslog class end interface void example end implementation void example nslog class end интерфейсе объявляют методы которые будут видны снаружи класса public внутренние методы можно реализовывать без интерфейса для объявления дополнительных свойств пользуются interface extension файле реализации все методы objective виртуальные java пример наследования от одного класса двух интерфейсов public class public interface public interface public class extends implements директива final объявлении класса делает наследование от него невозможным пример наследования от одного класса двух интерфейсов public class public interface public interface public class наследование от типизированных классов можно осуществлять указав фиксированный тип либо путём переноса переменной типа наследуемый класс public class public class public class допустимо также наследование вложенных классов от классов их содержащих class default class is internal not public class can not be public class директива sealed объявлении класса делает наследование от него невозможным ruby class parent def public_method public method end private def private_method private method end end class child класс parent является предком для класса child которого переопределён метод public_method child child new child public_method redefined public method child ancestor private method private method приватные методы предка можно вызывать из наследников javascript var parent function data this data data false this public_method function return public method var child function this public_method function return redefined public method this getdata function return data this data child prototype object create parent prototype var test new child test getdata data test test public_method redefined public method test data test класс parent является предком для класса child которого переопределен метод public_method javascript используется прототипное наследование конструкторы деструкторы конструкторы при наследовании вызываются последовательно от самого раннего предка до самого позднего потомка деструкторы наоборот от самого позднего потомка до самого раннего предка class first public first cout first constructor first destructor second constructor second destructor first constructor second constructor third constructor third destructor second destructor first destructor ссылки multiple inheritance проблемы множественного динамического приведения типов их решения примечания категория статьи примерами кода python