читается си плюс плюс компилируемый статически типизированный язык общего назначения поддерживает такие парадигмы как процедурное объектно ориентированное обобщённое язык имеет богатую стандартную библиотеку которая включает себя контейнеры алгоритмы ввод вывод регулярные выражения поддержку многопоточности другие возможности сочетает свойства как высокоуровневых так низкоуровневых языков сравнении его языком наибольшее внимание уделено поддержке объектно обобщённого широко используется для разработки программного обеспечения являясь одним из самых популярных языков область его применения включает создание операционных систем разнообразных прикладных программ драйверов устройств приложений для встраиваемых систем серверов также развлекательных приложений игр существует множество реализаций языка как бесплатных так коммерческих для различных платформ например на платформе это gcc visual intel compiler embarcadero borland builder другие оказал огромное влияние на другие языки первую очередь на java синтаксис унаследован от языка одним из принципов разработки было сохранение совместимости тем не менее не является строгом смысле надмножеством множество программ которые могут одинаково успешно транслироваться как компиляторами так компиляторами довольно велико но не включает все возможные программы на история исторический этап развития год язык bcpl язык би оригинальная разработка томпсона под unix язык си си классами cfront выпуск cfront выпуск множественное виртуальное наследование обобщённое шаблоны ansi iso iso iec iso iec cli tr создание язык возник начале годов когда сотрудник фирмы bell labs бьёрн страуструп придумал ряд языку под собственные нужды когда конце годов страуструп начал работать bell labs над задачами теории очередей приложении моделированию телефонных вызовов он обнаружил что попытки применения существующих то время языков моделирования оказываются неэффективными применение машинных языков слишком сложно из за их ограниченной выразительности так язык симула имеет такие возможности которые были бы очень полезны для разработки большого программного обеспечения но работает слишком медленно язык bcpl достаточно быстр но слишком близок языкам низкого уровня не подходит для разработки большого программного обеспечения вспомнив опыт своей диссертации страуструп решил дополнить язык преемник bcpl возможностями имеющимися языке симула язык будучи базовым языком системы unix на которой работали компьютеры bell является быстрым переносимым страуструп добавил нему возможность работы классами объектами результате практические задачи моделирования оказались доступными для решения как точки зрения времени разработки благодаря использованию симула подобных классов так точки зрения времени вычислений благодаря быстродействию первую очередь были добавлены классы инкапсуляцией наследование классов строгая проверка типов inline функции аргументы по умолчанию ранние версии языка первоначально именовавшегося with classes си классами стали доступны года разрабатывая классами страуструп написал программу транслятор исходный код классами исходный код простого это позволило работать над новым языком использовать его на практике применяя уже имеющуюся unix инфраструктуру для разработки на новый язык неожиданно для автора приобрёл большую популярность среди коллег вскоре страуструп уже не мог лично поддерживать его отвечая на тысячи вопросов году язык были добавлены новые возможности такие как виртуальные функции перегрузка функций операторов ссылки константы контроль над управлением свободной памятью улучшенная проверка типов новый стиль комментариев получившийся язык уже перестал быть просто дополненной версией классического был переименован из классами его первый коммерческий выпуск состоялся октябре года до начала официальной стандартизации язык развивался основном силами страуструпа ответ на запросы сообщества функцию стандартных описаний языка выполняли написанные страуструпом печатные работы по описание языка справочное руководство так далее лишь году был ратифицирован международный стандарт языка iso iec standard for the programming language после принятия технических исправлений стандарту году следующая версия этого стандарта iso iec развитие стандартизация языка году вышло первое издание языка обеспечивающее первое описание этого языка что было чрезвычайно важно из за отсутствия официального стандарта году состоялся выход версии его новые возможности включали множественное наследование абстрактные классы статические функции члены функции константы защищённые члены году вышло справочное руководство по положенное впоследствии основу стандарта последние обновления включали шаблоны исключения пространства имён новые способы приведения типов булевский тип стандартная библиотека также развивалась вместе ним первым добавлением стандартной библиотеке стали потоки ввода вывода обеспечивающие средства для замены традиционных функций printf scanf позднее самым значительным развитием стандартной библиотеки стало включение неё стандартной библиотеки шаблонов году был опубликован стандарт языка iso iec известный как разработанный комитетом по стандартизации iso iec jtc sc wg working group стандарт не описывает способы именования объектов некоторые детали обработки исключений другие возможности связанные деталями реализации что делает несовместимым объектный код созданный различными компиляторами однако для этого третьими лицами создано множество стандартов для конкретных архитектур операционных систем году был опубликован стандарт языка iso iec где были исправлены выявленные ошибки недочёты предыдущей версии стандарта году был выпущен отчёт library technical report кратко называемый tr не являясь официально частью стандарта отчёт описывает расширения стандартной библиотеки которые как ожидалось авторами должны быть включены следующую версию языка степень поддержки tr улучшается почти во всех поддерживаемых компиляторах языка года велась работа по обновлению предыдущего стандарта предварительной версией нового стандарта сперва был спустя год впоследствии переименованный куда были включены дополнения ядро языка расширение стандартной библиотеки том числе большую часть tr продолжает развиваться чтобы отвечать современным требованиям одна из групп разрабатывающих язык направляющих комитету по стандартизации предложения по его улучшению это boost которая занимается том числе возможностей языка путём добавления него особенностей никто не обладает правами на язык он является свободным однако сам документ стандарта языка за исключением черновиков не доступен бесплатно рамках процесса стандартизации iso выпускает несколько видов изданий частности технические доклады технические характеристики публикуются когда видно будущее но нет немедленной возможности соглашения для публикации международного стандарта до года не было опубликовано три технических отчёта по tr также известный как технический отчёт для расширений библиотеки основном интегрирован tr для специальных математических функций tr для десятичной арифметики плавающей точкой техническая спецификация dts по файловой системе была утверждена начале года остальные технические характеристики находятся стадии разработки ожидают одобрения марте года россии была создана рабочая группа рг группа была организована для сбора предложений стандарту отправки их комитет защиты на общих собраниях международной организации по стандартизации iso история названия имя языка получившееся итоге происходит от оператора унарного постфиксного инкремента увеличение значения переменной на единицу имя не было использовано потому что является синтаксической ошибкой кроме того это имя было занято другим языком язык также не был назван поскольку является расширением не пытается устранять проблемы путём удаления элементов философия книге дизайн эволюция бьёрн страуструп описывает принципы которых он придерживался при проектировании эти принципы объясняют почему именно такой какой он есть некоторые из них получить универсальный язык со статическими типами данных эффективностью переносимостью языка непосредственно всесторонне поддерживать множество стилей том числе процедурное абстракцию данных объектно ориентированное обобщённое дать программисту свободу выбора даже если это даст ему возможность выбирать неправильно максимально сохранить совместимость тем самым делая возможным лёгкий переход от на избежать разночтений между любая конструкция допустимая обоих языках должна каждом из них обозначать одно то же приводить одному тому же поведению программы избегать особенностей которые зависят от платформы или не являются универсальными не платить за то что не используется никакое языковое средство не должно приводить снижению программ не использующих его не требовать слишком усложнённой среды обзор языка стандарт состоит из двух основных частей описание ядра языка описание стандартной библиотеки первое время язык развивался вне формальных рамок спонтанно по мере встававших перед ним задач развитию языка сопутствовало развитие кросс компилятора cfront новшества языке отражались изменении номера версии кросс компилятора эти номера версий кросс компилятора на сам язык но применительно настоящему времени речь версиях языка не ведут лишь году язык стал поддерживает как комментарии стиле комментарий так однострочные вся оставшаяся часть строки является комментарием где обозначает начало комментария ближайший последующий символ новой строки который не предварён символом либо эквивалентным ему обозначением считается окончанием комментария плюс этого комментария том что его не обязательно заканчивать то есть обозначать окончание комментария спецификатор inline для функций функция определённая внутри тела класса является inline по умолчанию данный спецификатор является подсказкой компилятору может встроить тело функции код вместо её вызова квалификаторы const volatile отличие от где const обозначает только доступ на чтение переменная квалификатором const должна быть volatile используется описании переменных информирует компилятор что значение данной переменной может быть изменено способом который компилятор не состоянии отследить для переменных объявленных volatile компилятор не должен применять средства оптимизации изменяющие положение переменной памяти например помещающие её регистр или полагающиеся на неизменность значения переменной промежутке между двумя присваиваниями ей значения многоядерной системе volatile помогает избегать барьеров памяти го типа пространства имён namespace пример namespace foo const int const int foo специальным случаем является безымянное пространство имён все имена описанные нём доступны только текущей единице трансляции имеют локальное связывание пространство имён std содержит себе стандартные библиотеки для работы памятью введены операторы new new delete delete отличие от библиотечных malloc free пришедших из данные операторы производят инициализацию объекта для классов это вызов конструктора для pod типов инициализацию можно либо не проводить new pod либо провести инициализацию нулевыми значениями new pod new pod типы доступны следующие встроенные типы типы практически полностью повторяют типы данных символьные char wchar_t char char стандарте целочисленные знаковые signed char short int int long int long long стандарте целочисленные беззнаковые unsigned char unsigned short int unsigned int unsigned long int unsigned long long стандарте плавающей точкой float double long double логический bool имеющий значения true или false операции сравнения возвращают тип bool выражения скобках после if while приводятся типу bool язык ввёл понятие ссылок начиная одиннадцатой версии стандарта rvalue ссылки forwarding ссылки см ссылка добавляет объектно ориентированные возможности он вводит классы которые обеспечивают три самых важных свойства ооп инкапсуляцию наследование полиморфизм стандарте под классом class подразумевается тип объявленный использованием одного из ключевых слов class struct или union под структурой structure подразумевается класс определённый через ключевое слово struct под объединением union подразумевается класс определённый через ключевое слово union теле определения класса можно указать как объявления функций так их определение последнем случае функция является встраиваемой inline нестатические функции члены могут иметь квалификаторы const volatile также ссылочный квалификатор или наследование поддерживает множественное наследование базовые классы классы предки указываются заголовке описания класса возможно со спецификаторами видимости наследование от каждого класса может быть публичным защищённым или закрытым доступ члена базового класса режим наследования private член protected член public член private наследование недоступен private private protected наследование недоступен protected protected public наследование недоступен protected public по умолчанию базовый класс наследуется как private результате наследования класс потомок получает все поля классов предков все их методы можно сказать что каждый экземпляр класса потомка содержит подэкземпляр каждого из классов предков если один класс предок наследуется несколько раз это возможно если он является предком нескольких базовых классов создаваемого класса то экземпляры класса потомка будет включать столько же подэкземпляров данного класса предка чтобы избежать такого эффекта если он нежелателен поддерживает концепцию виртуального наследования при наследовании базовый класс может объявляться виртуальным на все виртуальные вхождения класса предка дерево наследования класса потомка потомке создаётся только один подэкземпляр полиморфизм поддерживает динамический полиморфизм параметрический полиморфизм параметрический полиморфизм представлен аргументами по умолчанию для функций примеру для функции void int int int вызовы эквивалентны перегрузка функций функция одним именем может иметь разное число разные по типу аргументы например void print int void print double void print int int частным случаем перегрузки функций можно считать перегрузку операторов механизмом шаблонов динамический полиморфизм реализуется помощью виртуальных методов иерархии наследования полиморфным является тип имеющий хотя бы один виртуальный метод пример иерархии class figure public virtual void draw чистый виртуальный метод virtual figure при наличии хотя бы одного виртуального метода деструктор следует сделать виртуальным class square public figure public void draw override class circle public figure public void draw override здесь класс figure является абстрактным даже интерфейсным так как метод draw не определён объекты данного класса нельзя создать зато можно использовать ссылки или указатели типом figure выбор реализации метода draw будет производиться во время выполнения исходя из реального типа объекта инкапсуляция инкапсуляция реализуется через указание уровня доступа членам класса они бывают публичными открытыми public защищёнными protected приватными закрытыми private структуры формально отличаются от классов лишь тем что по умолчанию уровень доступа членам класса тип наследования структуры публичные класса приватные доступ private protected public сам класс да да да друзья да да да наследники нет да да извне нет нет да проверка доступа происходит во время компиляции попытка обращения недоступному члену класса вызовет ошибку компиляции друзья функции друзья это функции не являющиеся функциями членами тем не менее имеющие доступ защищённым закрытым членам класса они должны быть объявлены теле класса как friend например class matrix friend matrix multiply matrix matrix здесь функция multiply может обращаться любым полям функциям членам класса matrix дружественным может быть объявлен как весь класс так функция член класса четыре важных ограничения накладываемых на отношения дружественности дружественность не транзитивна если объявляет другом свою очередь объявляет другом то не становится автоматически другом для для этого должен явно объявить своим другом дружественность не взаимна если класс объявляет другом класс то он не становится автоматически другом для для этого должно существовать явное объявление дружественности классе дружественность не наследуется если объявляет класс своим другом то потомки не становятся автоматически друзьями для этого каждый из них должен быть объявлен другом явной форме дружественность не на потомков если класс объявляет другом то не становится автоматически другом для классов потомков каждый потомок если это нужно должен объявить своим другом самостоятельно общем виде это правило можно сформулировать следующим образом отношение дружественности существует только между теми классами классом функцией для которых оно явно объявлено коде действует только том направлении котором оно объявлено специальные функции класс по умолчанию может иметь шесть специальных функций конструктор по умолчанию конструктор копирования конструктор перемещения деструктор оператор присваивания копированием оператор присваивания перемещением также можно явно определить их все см правило трёх class array public array default компилятор создаст конструктор по умолчанию сам array size_t len val new double_len array const array delete конструктор копирования явно удалён array array конструктор перемещения array delete val array operator const array rhs оператор присваивания копированием array operator array rhs оператор присваивания перемещением double operator size_t return vali const double operator size_t const return vali protected std size_t len инициализация поля double val nullptr конструктор вызывается для инициализации объекта типа при его создании деструктор для уничтожения объекта класс может иметь несколько конструкторов но деструктор может иметь только один конструкторы не могут быть объявлены виртуальными деструкторы могут обычно объявляются для всех полиморфных типов чтобы гарантировать правильное уничтожение доступного по ссылке или указателю объекта независимо от того какого типа ссылка или указатель при наличии хотя бы одного из базовых классов виртуального деструктора деструктор класса потомка автоматически становится виртуальным шаблоны шаблоны позволяют порождать функции классы определённым типом или значением например предыдущий класс мог бы реализовывать массив для любого типа данных template class array operator size_t return vali protected std size_t len инициализация поля val nullptr стандартная библиотека общая структура стандартная библиотека включает себя набор средств которые должны быть доступны для любой реализации языка чтобы обеспечить программистам удобное пользование языковыми средствами создать базу для разработки как прикладных приложений самого широкого спектра так библиотек стандартная библиотека включает себя часть стандартной библиотеки стандарт содержит нормативную ссылку на стандарт от года не определяет самостоятельно те функции стандартной библиотеки которые заимствуются из стандартной библиотеки доступ возможностям стандартной библиотеки обеспечивается помощью включения программу посредством директивы include соответствующих стандартных заголовочных файлов всего стандарте определено таких файлов средства стандартной библиотеки объявляются как входящие пространство имён std заголовочные файлы имена которых соответствуют шаблону cx где имя заголовочного файла стандартной библиотеки без расширения cstdlib cstring cstdio пр содержат объявления соответствующие данной части стандартной библиотеки стандартные функции библиотеки также находятся пространстве имён std состав стандартная библиотека включает себя следующие разделы поддержка языка включает средства которые необходимы для работы программ также сведения об особенностях реализации выделение памяти rtti базовые исключения пределы значений для числовых типов данных базовые средства взаимодействия со средой такие как системные часы обработка сигналов unix завершение программы стандартные контейнеры стандартную библиотеку входят шаблоны для следующих контейнеров динамический массив vector статический массив array одно двунаправленные списки list forward_list стек stack дек deque ассоциативные массивы map multimap множества set multiset очередь приоритетом priority_queue основные утилиты этот раздел входит описание основных базовых элементов применяемых стандартной библиотеке распределителей памяти поддержка времени даты стиле итераторы обеспечивают шаблоны итераторов помощью которых стандартной библиотеке реализуется стандартный механизм группового применения алгоритмов обработки данных элементам контейнеров алгоритмы шаблоны для описания операций обработки которые помощью механизмов стандартной библиотеки могут применяться любой элементов том числе элементам контейнерах также этот раздел входят описания функций bsearch qsort из стандартной библиотеки строки шаблоны строк стиле также этот раздел попадает часть библиотек для работы со строками символами стиле ввод вывод шаблоны вспомогательные классы для потоков ввода вывода общего вида строкового ввода вывода манипуляторы средства управления форматом потокового ввода вывода стиле локализация определения используемые для поддержки национальных особенностей форматов представления дат валют стиле стиле диагностика определения ряда исключений механизмов проверки утверждений во время выполнения assert поддержка обработки ошибок стиле числа определения для работы комплексными числами математическими векторами поддержка общих математических функций генератор случайных чисел контейнеры строки алгоритмы итераторы основные утилиты за исключением заимствований из библиотеки собирательно называются stl standard template library стандартная шаблонная библиотека изначально эта библиотека была отдельным продуктом её аббревиатура иначе но потом она вошла стандартную библиотеку качестве неотъемлемого элемента названии отражено то что для реализации средств общего вида контейнеров строк алгоритмов использованы механизмы обобщённого шаблоны template работах страуструпа подробно описываются причины по которым был сделан именно такой выбор основными из них являются бо льшая универсальность выбранного решения шаблонные контейнеры отличие от объектных могут легко использоваться для не объектных типов не требуют наличия общего предка типов элементов его техническая эффективность как правило операции шаблонного контейнера не требуют вызовов виртуальных функций могут легко встраиваться inline что итоге даёт выигрыш начиная со стандарта добавились следующие возможности добавлена библиотека реализующая общепринятые механизмы поиска подстановки помощью регулярных выражений добавлена поддержка многопоточности атомарные операции unordered варианты ассоциативных массивов множеств умные указатели обеспечивающие автоматическое освобождение выделенной памяти отличия от языка совместимость языком выбор именно качестве базы для создания нового языка объясняется тем что язык является многоцелевым лаконичным относительно низкоуровневым языком подходит для решения большинства системных задач исполняется везде на всём стыкуется со средой unix несмотря на ряд известных недостатков языка страуструп пошёл на его использование качестве основы так как есть свои проблемы но их имел бы разработанный нуля язык проблемы нам известны кроме того это позволило быстро получить прототип компилятора который лишь выполнял трансляцию добавленных синтаксических элементов оригинальный язык по мере разработки него были включены другие средства которые перекрывали возможности конструкций связи чем неоднократно поднимался вопрос об отказе от совместимости языков путём удаления устаревших конструкций тем не менее совместимость была сохранена из следующих соображений сохранение действующего кода написанного изначально на прямо перенесённого исключение необходимости переучивания программистов ранее изучавших им требуется только изучить новые средства исключение путаницы между языками при их совместном использовании если два языка используются совместно их различия должны быть или минимальными или настолько большими чтобы языки было невозможно перепутать новые возможности новые возможности включают объявления виде выражений преобразования типов виде функций операторы new delete тип bool ссылки расширенное понятие константности подставляемые функции аргументы по умолчанию переопределения пространства имён классы включая все связанные классами возможности такие как наследование функции члены виртуальные функции абстрактные классы конструкторы переопределения операторов шаблоны оператор обработку исключений динамическую идентификацию многое другое язык также во многих случаях строже относится проверке типов чем появились комментарии виде двойной косой черты которые были предшественнике языке bcpl некоторые особенности позднее были перенесены например ключевые слова const inline объявления циклах for комментарии стиле более поздних реализациях также были представлены возможности которых нет например макросы va_arg улучшенная работа массивами параметрами не включает себя несмотря на то что большая часть кода будет справедлива для не является надмножеством не включает его себя существует такой верный для код который неверен для это отличает его от objective ещё одного для ооп как раз являющегося надмножеством существуют другие различия например не разрешает вызывать функцию main внутри программы то время как это действие правомерно кроме того более строг некоторых вопросах например он не допускает неявное приведение типов между несвязанными типами указателей не разрешает использовать функции которые ещё не объявлены более того код верный для обоих языков может давать разные результаты зависимости от того компилятором какого языка он оттранслирован например на большинстве платформ следующая программа печатает если компилируется компилятором если компилятором так происходит из за того что символьные константы например имеют тип int тип char размеры этих типов обычно различаются include int main printf sizeof sizeof char return средства которых рекомендуется избегать по замечанию страуструпа чем лучше вы знаете тем труднее вам будет избежать на стиле теряя при этом потенциальные преимущества связи этим он даёт следующий набор рекомендаций для программистов на чтобы полной мере воспользоваться преимуществами не использовать define для объявления констант применять const групп констант перечислений enum для прямого включения функций inline для определения семейств функций или типов template не использовать предварительные объявления переменных объявлять переменные блоке где они реально используются всегда совмещая объявление инициализацией отказаться от использования malloc пользу оператора new от realloc пользу типа vector более безопасным будет использование умных указателей таких как shared_ptr unique_ptr доступных одиннадцатой версии стандарта избегать бестиповых указателей арифметики указателей неявных приведений типов объединений за исключением возможно низкоуровневого кода использовать новые преобразования типов как более точно выражающие действительные намерения программиста более безопасные свести минимуму использование массивов символов строк стиле заменив их на типы string vector из stl вообще не стремиться создавать собственные реализации того что уже имеется стандартной библиотеке реализации stl до включения стандарт была сторонней разработкой вначале фирмы hp затем sgi стандарт языка не называет её stl так как эта библиотека стала неотъемлемой частью языка однако многие люди до сих пор используют это название чтобы отличать её от остальной части стандартной библиотеки потоки ввода вывода iostream подраздел другие проект под названием stlport основанный на sgi stl осуществляет постоянное обновление stl iostream строковых классов некоторые другие проекты также занимаются разработкой частных применений стандартной библиотеки дальнейшее развитие текущий стандарт языка iso iec был опубликован декабре года неофициально его обозначают как следующая версия стандарта запланированная на год имеет неофициальное обозначение общие направления развития по мнению автора языка бьёрна страуструпа говоря дальнейшем развитии перспективах языка можно выделить следующее основном дальнейшее развитие языка будет идти по пути внесения дополнений стандартную библиотеку одним из основных источников этих дополнений является известная библиотека boost изменения ядре языка не должны приводить снижению уже достигнутой эффективности точки зрения страуструпа внесение ядро нескольких серьёзных больших изменений чем множества мелких правок базовыми направлениями развития на ближайшее время является расширение возможностей доработка средств обобщённого стандартизация механизмов параллельной обработки также доработка средств безопасного таких как различные проверки безопасные преобразования типов проверка условий так далее целом спроектирован развивается как язык впитывающий себя различные методы технологии но реализующий их на платформе обеспечивающей высокую техническую эффективность поэтому будущем не исключено добавление язык средств функционального автоматической сборки мусора других отсутствующих нём сейчас механизмов но любом случае это будет делаться на имеющейся платформе компилируемого языка хотя формально одним из принципов остаётся сохранение совместимости языком фактически группы по стандартизации этих языков не взаимодействуют вносимые ими изменения не только не коррелируют но нередко принципиально противоречат друг другу идеологически так элементы которые новые стандарты добавляют ядро стандарте являются элементами стандартной библиотеки ядре вообще отсутствуют например динамические массивы массивы фиксированными границами средства параллельной обработки как считает страуструп объединение разработки этих двух языков принесло бы большую пользу но оно вряд ли возможно по политическим соображениям так что практическая совместимость между постепенно будет утрачиваться стандарт дополнения ядре языка явно определяемые константные функции выражения constexpr универсальная инициализация конструкторы операторы присваивания семантикой переноса вывод типов для применения шаблонах там где затруднительно указать конкретный тип переменной введены два новых механизма переменные типа auto описание decltype цикл по коллекции вслед за многими современными языками введена конструкция цикл по коллекции вида for type array здесь тело цикла выполняется для каждого элемента коллекции array каждой итерации будет ссылаться на очередной элемент коллекции качестве коллекции может выступать массив или любой контейнер стандартной библиотеки для которого определены итераторы begin end лямбда выражения добавлена возможность объявлять лямбда выражения безымянные функции определяемые точке применения том числе зависящие от внешних переменных замыкания лямбда выражения могут присваиваться переменным использоваться везде где требуется функция типа например алгоритмах стандартной библиотеки изменения описании виртуальных методов добавлен необязательный модификатор override который употребляется объявлении метода замещающего виртуальный метод родительского класса описание замещения override вызывает проверку на наличие родительском классе замещаемого метода на совпадение сигнатур методов добавлен также модификатор final как java запрещающий дальнейшее замещение помеченного им метода также final может быть объявлен класс таком случае от него запрещено наследовать новые классы добавлена возможность описания вариативных шаблонов различные синтаксические дополнения определено ключевое слово для константы нулевого указателя nullptr внесены изменения семантику частично синтаксис перечислений объединений добавлена возможность создавать типобезопасные перечисления объединений снят ряд ограничений на структуру от компилятора требуется правильный лексический разбор текста программы несколькими закрывающимися угловыми скобками подряд ранее воспринималась однозначно как операция побитового сдвига вправо поэтому записи вложенных шаблонных конструкций требовалось обязательно разделять знаки больше пробелами или переводами строк примеры программ пример это пример программы hello world которая выводит сообщение используя стандартную библиотеку завершается include int main std cout пример современный позволяет решать простым способом более сложные задачи этот пример демонстрирует кроме всего прочего использование контейнеров стандартной библиотеки шаблонов stl include для использования std cout include содержит динамический массив include содержит тип данных словарь include int main импортируем все объявления пространстве имён std глобальное пространство имён using namespace std объявляем ассоциативный контейнер со строковыми ключами данными виде векторов строк map items добавим этот ассоциативный контейнер пару человек дадим им несколько предметов items anya push_back scarf items dmitry push_back tickets items anya push_back puppy переберём все объекты контейнере for const auto person items person это пара двух объектов person first это его имя person second это список его предметов вектор строк cout этом примере для простоты импортируются все имена из пространства имён std настоящей же программе так делать не рекомендуется так как можно столкнуться коллизией имён язык позволяет импортировать отдельные объекты include int main using std vector vector my_vector как если выполнение программы доходит до конца функции main то это эквивалентно return это неверно для любой другой функции кроме main достоинства недостатки достоинства содержит средства разработки программ контролируемой эффективности для широкого спектра задач от низкоуровневых утилит драйверов до весьма сложных программных комплексов частности высокая совместимость языком си код на си может быть минимальными переделками скомпилирован компилятором внешнеязыковой интерфейс является прозрачным так что библиотеки на си могут вызываться из без дополнительных затрат более того при определённых ограничениях код на может внешне не отличимо от кода на си конструкция extern как следствие предыдущего пункта вычислительная язык спроектирован так чтобы дать программисту максимальный контроль над всеми аспектами структуры порядка исполнения программы один из базовых принципов не платишь за то что не используешь см философия то есть ни одна из языковых возможностей приводящая дополнительным накладным расходам не является обязательной для использования имеется возможность работы памятью на низком уровне поддержка различных стилей традиционное императивное структурное объектно ориентированное обобщённое функциональное порождающее автоматический вызов деструкторов объектов адекватном порядке обратном вызову конструкторов упрощает повышает надёжность управления памятью другими ресурсами открытыми файлами сетевыми соединениями соединениями базами данных перегрузка операторов позволяет кратко ёмко записывать выражения над типами естественной алгебраической форме имеется возможность управления константностью объектов модификаторы const mutable volatile использование константных объектов повышает надёжность служит подсказкой для оптимизации перегрузка функций членов по признаку константности позволяет определять выбор метода зависимости цели вызова константный для чтения неконстантный для изменения объявление mutable позволяет сохранять логическую константность при виде извне кода использующего кэши ленивые вычисления шаблоны дают возможность построения обобщённых контейнеров алгоритмов для разных типов данных попутно шаблоны дают возможность производить вычисления на этапе компиляции возможность встраивания предметно ориентированных языков основной код такой подход использует например библиотека boost spirit позволяющая задавать ebnf грамматику парсеров прямо коде доступность для существует огромное количество учебной литературы переведённой на всевозможные языки язык имеет высокий порог вхождения но среди всех языков такого рода обладает наиболее широкими возможностями недостатки числу обычно упоминаемых недостатков языка можно отнести отсутствие системы модулей унаследовал от си подключение заголовочных файлов помощью препроцессора это вынуждает дублировать описания объектов порождает неочевидные требования коду см правило одного определения увеличивает объём компилируемого текста значит время компиляции наличие более чем одного механизма для выполнения одних тех же задач что усложняет язык приводит неоптимальному небезопасному кодированию унаследованные от си опасные провоцирующие ошибки возможности такие как define адресная арифметика неявное приведение типов возможность прямого управления распределением памяти провоцирует ошибки приводящие внезапному краху программ из за разрушения стека или обращения невыделенной памяти шаблоны порождают объёмный код появившиеся поздних версиях языка возможности частичного определения шаблонов сильно усложняют язык объектно ориентированная подсистема построена так что оказывается затруднительно применять многие приёмы обычные для других объектных языков множественное том числе виртуальное наследование усложняет транслятор приводит созданию громоздких иерархий классов которые при любом изменении требований программе могут потребовать серьёзного пересмотра сложный синтаксис объёмная спецификация языка затрудняют его изучение язык не поощряет регулярное безопасное вместо этого зачастую предлагая выбор между короткими простыми но опасными объёмными сложными но безопасными механизмами сложная постоянно разрастающаяся стандартная библиотека затрудняющая изучение дополнительно увеличивающая объём программ при всём богатстве доступных языке возможностей он не поддерживает ряд полезных технологий методик либо поддержка их крайне ограниченна критика критике целом одной стороны является потомком симулы которую алан кэй определил как алгол классами потому актуальна оценка сравнении другими языками из семейства потомков алгола pascal java visual basic delphi oberon пр другой стороны претендует на универсальную применимость отличие от си на очень узкий круг задач используется промышленности намного шире других потомков алгола потому представляет интерес оценка сравнении со всем многообразием применяемых языков включая си во избежание повторений оценки обычно совмещаются язык складывающийся эволюционно отличие от языков формальным определением семантики каждый элемент заимствовался из других языков отдельно независимо от остальных элементов ничто из предложенного за всю историю его развития не было новшеством computer science что сделало язык чрезвычайно сложным со множеством дублирующихся взаимно противоречивых элементов блоки которых основаны на разных формальных базах этом отношении повторяет путь pl но отличие от последнего длительное повсеместное использование обеспечил выбор языка си качестве отправной точки за редкими исключениями критики не ему какой либо другой конкретный язык утверждают что для всякого случая применения существует альтернативный инструментарий позволяющий решить ту же задачу более эффективно качественно отдельно подвергается критике принцип совместимости си результатом следования которому является заимствование целого ряда опасных провоцирующих ошибки решений свою очередь сторонники возражают против сравнения различных аспектов различными языками заявляя что общий набор средств существенно шире чем большинстве альтернативных языков эта широта является оправданием несовершенства каждой отдельно взятой возможности том числе недостатки вызванные сохранением совместимости си оправданы ею преимуществами см раздел философия критики указывают на тот подтверждённый исследованиями факт что использование наиболее подходящего языка или декомпозиция проекта на подзадачи решаемые на наиболее подходящих языках сокращает на порядок общую трудоёмкость разработки при одновременном повышении на порядки основных показателей качества из чего делается вывод что если задача требует одновременно высоко низкоуровневых возможностей то разумнее использовать си совместно языками также критики не соглашаются рассматривать элементы по отдельности так как это означает отказ от рассмотрения языка как системы следовательно от ожидания синергизма что ограничивает сложность абстракций которые можно выразить на этом языке той же мере сужает спектр реализуемых на нём программных систем таким образом одни те же свойства языка эклектичность отсутствие конкретной целевой ниши применения рассматривается сторонниками как главное достоинство критиками как главный недостаток критика отдельных элементов концепций контроль за поведением принцип не платишь за то что не используешь см философия заявляется как средство обеспечения высокой скорости исполнения на практике он лишь приводит чрезмерному использованию ситуативного ad hoc полиморфизма явного описания различного поведения даже для редких ситуаций под единым идентификатором то есть перегрузки функций предусмотрено сразу три формы перегрузки что приводит значительному дублированию кода перегрузка операторов призвана дать возможность введения программу синтаксического сахара но может поощрять бесконтрольное изменение поведения элементарных операций том числе new delete new delete для разных типов что резко повышает риск разного рода ошибок это обусловлено во первых тем что вводить новый синтаксис нельзя хотя синтаксис стандартных операторов адекватен семантике далеко не всех типов которые может потребоваться ввести программу во вторых тем что всякий учебник даже для низкого порога вхождения показывает как перегружать те или иные операторы включая управление временем жизни объектов обычно ввод специального синтаксиса для операций является совершенно безболезненным аппликативных языках где эта возможность существует независимо от полиморфной семантики системы типов не предоставляет доступа управлению памятью некоторые интуитивно ожидаемые операции подчистка динамических объектов случае генерации исключений не выполняются соответствии означенным принципом то же время значительная часть перегруженных функций операторов вызывается неявно приведение типов создание временных экземпляров классов др попутно идеология языка смешивает контроль за поведением контролем за эффективностью что представляет опасность так как де факто возможности явного контроля этих аспектов исполнения программы со стороны человека являются сочетании изобилием побочных эффектов всё это приводит тому что по мере роста сложности системы код на не абстрагируется наоборот усложняется значительно снижаются показатели понимаемости тестируемости возникает необходимость контролировать как чтением так отладкой слои реализации по разные стороны от текущего барьера абстракции что считается плохой практикой результате трудоёмкость значит стоимость разработки растёт от объёма реализованной по вогнутому закону языках полиморфной семантикой системы типов этот рост характеризуется выпуклой кривой за счёт существенно более высокого показателя повторного использования кода компонентное объектно ориентированное объектная модель унаследованная от симулы дополненная двумя формами множественного наследования простой виртуальной имеет не только объективные проблемы но опасную идеологию по словам создателя smalltalk алана кэя объектная модель алгол классами обладает худшими качества чем модель всё объект этом смысле уступает своему ближайшему конкуренту objective показатель повторного использования кода оказывается крайне низким см раздел полиморфизм рефлексивное невозможным показатели понимаемости тестируемости слабыми см раздел отсутствие возможностей реализация указателей на методы классов не их размер различных компиляторах варьируется от диапазоне до байт что значительно снижает портируемость программ их использованием принятая сообществе методология декомпозиции приводит проектным решениям не доказуемым математически неадекватным предметной области потому угрожающим неоправданными затратами скрытыми ошибками традиционно понятие тип класс отождествляется понятием множества или реже категории понятие наследования классов информатике традиционно означает создание подклассов то есть подмножеств обычной практикой является применение наследования вместо вложения определение нового типа на основании более простых взаимно ортогональных значит не имеющих точек соприкосновения типов осуществляется посредством создания их общего подтипа условно говоря класс автомобиль создаётся путём наследования классов колесо двигатель например приводится учебно пример реализации класса список как подкласса от класса элемент списка который хотя заявляется как скалярный тип контейнер для единственного значения тем не менее содержит операции присущие агрегатным типам функции доступа другим элементам списка внешним по отношению текущему объекту при этом он не может использоваться как агрегатный тип вообще не предназначен для использования такое отношение типов является абсурдом точки зрения математики на более строгих языках идеология некоторых библиотек опирается на возможность приведения типов вверх вниз по иерархии классов операции static_cast dynamic_cast подтверждая что не входит традиции языка ошибочность проектных решений принятых соответствии этой идеологией может обнаруживаться на поздних этапах разработки из за высокой вязкости требовать повторной разработки значительных частей проекта ярким примером является описанный случай пример подобной проблемы описан potts software engineering research revisited ieee software sept lubers potts richter developing initial ooa models proc intl conf software eng los alamitos calif для исследования применимости объектно ориентированной декомпозиции системам разного рода были три случая один из них был реальным проектом разработки системы наведения ракеты томагавк разработчики сочли что все ракеты можно разделить на подклассы соответствии видом боеголовки навигационными также их можно разделить на тактические учебные эти две таксономии были практически ортогональны было принято решение использовать множественное наследование для применения этих категорий конкретным видам ракет однако на более поздней стадии разработки было обнаружено что ортогональность нарушена хотя некоторые виды учебных ракет могут нести боеголовки ядерные ракеты не могут продолжение принятого подхода построению архитектуры привело бы неэлегантным искусственным моделям скрывающим под массой деталей исключительные ситуации которые легко упустить как отмечает ян джойнер ошибочно отождествляет инкапсуляцию сокрытие существует большая путаница относительно инкапсуляции основным источником которой является отождествляющий инкапсуляцию сокрытием данных словарь маккуори определяет глагол инкапсулировать как помещать прямом или переносном смысле капсулу объектно ориентированное понимание инкапсуляции заключается том чтобы помещать родственные данные процедуры определения капсулу класса это не обязательно означает сокрытие сокрытие реализации является ортогональным понятием которое становится возможным благодаря инкапсуляции инкапсуляция предоставляет возможность отделять абстрактный интерфейс класса от его реализации интерфейс это видимая поверхность капсулы реализация скрыта капсуле сокрытие реализации означает что данными можно манипулировать изменяя их только внутри класса но не означает сокрытие интерфейсных данных для сокрытия реализации необходимо осуществлять доступ данным через функции си это называется сокрытием данных механизм доступа является скрываемой деталью реализации обеспечивает заметные различия механизмах доступа константам переменным функциям большинство не си подобных языков обеспечивают единый механизм доступа константам переменным процедурам возвращающим значения при этом совпадение типов определяется на уровне идентификаторов не сигнатур как следствие оказывается невозможно подменять модули классы основываясь на совпадении их интерфейсной то есть если некоторые возможности отсутствуют но реализованы на уровне библиотек такие как сборка мусора или длинная арифметика то для получения выгоды от них необходимо вручную модифицировать уже имеющийся код для адаптации его под новый модуль языках самых разных семантик ml smalltalk erlang python даже си полиморфизм инкапсуляция сокрытие являются независимыми ортогональными категориями контроль типов осуществляется по соответствию их сигнатур не идентификаторов так что выгода от нового кода обеспечивается простой подменой имеющегося модуля на новый что называется абстракцией как отмечает линус торвальдс код кажется абстрактным лишь до тех пор пока не возникает необходимость его изменить результирующий ущерб от совокупности описанных свойств отмечается также линусом торвальдсом провоцирует на написание дополнение структурам функциям си значительного объёма кода не имеющего принципиального значения программы критика позиций только ооп без сравнения методологий проектирования описанием вреда от влияния на другие языки приведена работе заявляется как стандарт языка накладывает минимальные требования на эвм для запуска программ на практике для написания портируемого кода на требуется огромное мастерство опыт небрежные коды на высокой вероятностью могут оказаться непортируемыми тонкое владение принципе может сделать код на столь же портируемым что код на си хотя по мнению линуса торвальдса при этом фактически сократится до своего подмножества си однако критики утверждают что изучение использование одновременно всех языков не вызывающих серьёзных проблем при портировании сумме требует примерно тех же интеллекта усилий временных затрат что изучение использование одного только на высококлассном уровне связи чем становится актуальной также оценка порога вхождения качества труда программистов многие аспекты спорах за против обусловлены расхождением сущностном понимании процесса стандартизации страуструп его последователи считают что стандарт это контракт между программистами программы на языке программистами компиляторы языка каждый новый стандарт являлся декларацией того что отныне должно быть реализовано во всех компиляторах при том что имеет естественное определение семантики то есть потенциально зависим от реализации стандарт содержит множество пунктов определённых как implementation defined традиционно успешная стандартизация технике представляет собой формальный перевод стандарта из статуса де факто статус де юре подытоживание общепринятых устоявшихся знаний для обеспечения надёжной совместимости теоретически эти определения стандартизации тождественны на практике определение страуструпа согласуется традиционным лишь при условии что нет абсолютно никаких препятствий против немедленного подчинения статуса де факто де юре то есть если абсолютно все компиляторы реализуют поддержку нового стандарта сразу после его выхода со соответствием ему что новый стандарт не отменяет никаких положений старого кроме признанных убыточными или вредоносными так может происходить лишь условиях полного отсутствия человеческого фактора иначе говоря при отсутствии программистов как таковых на практике именно этим обусловлено значительное отставание реальной от заявленной разработчиками стандарта предлагаемых возможностей сторонники считают взгляд страуструпа на стандартизацию более практико ориентированным принимают порождаемые им проблемы за должное все языки если проходили процедуру стандартизации что не обязательно для портируемости то лишь после многолетней апробации на практике при этом все они изначально имеют формальное определение семантики так что накапливающиеся моменту стандартизации изменения от первой версии языка оказываются не принципиальны отсутствие возможностей рефлексивное рефлексивное невозможно интроспекция предусмотрена но реализована отдельно от основной системы типов что делает её практически бесполезной наибольшее что можно получить параметризацию поведения на заранее известном диапазоне случаев это является препятствием против применения большинстве подходов реализации искусственного интеллекта за исключением самых примитивных реализующих статический алгоритм порождающее порождающее на основе шаблонов трудоёмко ограничено по возможностям оно осуществляется за счёт реализации статического исполняемого на этапе компиляции интерпретатора примитивного функционального языка посредством шаблонов также примитивного препроцессора унаследованного от си сама по себе данная возможность весьма привлекательна но во первых код на шаблонах имеет крайне низкие показатели понимаемости тестируемости во вторых при разворачивании шаблонов порождается неэффективный код так как язык шаблонов не предоставляет никаких средств для оптимизации см также раздел вычислительная эффективность при этом встраиваемые предметно специфичные языки реализуемые таким образом всё равно требуют знания самого для их использования так как возводимые барьеры абстракции сохраняют все свойства нижележащей реализации что не обеспечивает полноценное разделение труда таким образом возможности по расширению возможностей самого весьма ограничены одной из причин отставания мощности шаблонов является то что отличие от языков где качестве подсистемы используется сам основной язык язык шаблонов представляет собой отдельный язык не пересекающийся самим из за чего потенциал роста сложности абстракций оказывается ограниченным функциональное явная поддержка функционального присутствует только стандарте вышедшим лишь после почти лет развития языка до этого данный пробел устранялся различными библиотеками loki boost использующими язык шаблонов для расширения основного языка функциональными конструкциями качество подобных решений значительно уступает качеству встроенных функциональные языки решений качеству реализаций высокоуровневых возможностей таких как ооп посредством функциональных языков все реализованные возможности фп оказываются лишь их эмуляцией используются совместно императивными возможностями что не даёт возможности применения присущих функциональному мощных оптимизационных методик см раздел вычислительная эффективность кроме того из за трудоёмкости использования шаблонов на практике фп обычно ограничивается вызовами функциональных библиотек реализацией отдельных методов практически не даёт преимуществ проектировании программ см соответствие карри ховарда пред пункт так что оно по прежнему осуществляется обычно лишь посредством объектно ориентированной декомпозиции избыточные опасные возможности гарантия некорректности из за слабой системы типов программист оказывается волен легко нарушить заданную конкретном случае дисциплину например хотя модификатор const предназначен для повышения предсказуемости поведения что должно облегчить доказательство корректности как следствие расширить возможности оптимизации но модификатор mutable предназначен именно для принудительного разрешения изменения состояния внутри константного объекта это значит что код сторонней библиотеки на может содержать изменяемое состояние вопреки любым попыткам назначить ему извне свойство константности более того допускается динамически удалить атрибут const константного объекта превращая его леводопустимый value сама по себе явная декларация спецификации языка подобных возможностей делает попытки формальной верификации бессмысленными средства си define являются сколь мощным столь же опасным средством они сохранены несмотря на то что для решения всех задач для которых они были предусмотрены си были предоставлены более строгие средства шаблоны перегрузка функций inline функции пространства имён более развитая типизация расширение применения модификатора const др унаследованных от си стандартных библиотеках много потенциально опасных макросов шаблонное также порой совмещается использованием для обеспечения синтаксического сахара вычислительная эффективность результирующий объём исполнимого кода использование шаблонов представляет собой параметрический полиморфизм на уровне исходного кода но при трансляции он превращается ситуативный ad hoc полиморфизм то есть перегрузку функций что приводит существенному увеличению объёма машинного кода сравнении языками имеющими истинно полиморфную систему типов потомками ml для снижения размера машинного кода пытаются автоматически обрабатывать исходный код до этапа раскрутки шаблонов другим решением могла бы быть ещё году возможность экспорта шаблонов но она доступна далеко не во всех компиляторах так как её трудно реализовать для импорта библиотек шаблонов языки существенно отличной от семантикой она всё равно была бы бесполезна сторонники оспаривают масштабы раздувания кода как преувеличенные игнорируя даже тот факт что си параметрический полиморфизм транслируется непосредственно то есть без дублирования тел функций вообще при этом сторонники считают что параметрический полиморфизм си опасен то есть более опасен чем переход от си противники утверждают обратное см выше потенциал оптимизации из за слабой системы типов изобилия побочных эффектов становится крайне затруднительным эквивалентное преобразование программ значит встраивание компилятор многих оптимизирующих алгоритмов таких как автоматическое программ удаление общих подвыражений подъём вызовы процедур передачей продолжений суперкомпиляция др результате реальная эффективность программ на ограничивается имеющейся квалификацией программистов вложенными конкретный проект усилиями небрежная реализация может существенно уступать по эффективности небрежным реализациям на языках более высокого уровня что подтверждается сравнительными испытаниями языков это является существенным препятствием против применения индустрии data mining эффективное управление памятью потенциал повышению эффективности управления памятью весьма ограничен хотя существуют многочисленные реализации автоматической сборки мусора использование более эффективных способов управления памятью таких как статический для конкретной библиотеки невозможно точнее это привело бы реализации поверх языка интерпретатора нового языка сильно отличающегося от как большинством объективных свойств так общей идеологией по причине необходимости прямого доступа ast для автоматического управления памятью традиционно используются умные указатели ручное же управление памятью снижает эффективность самих программистов см раздел замедление си противники утверждают что данном случае расширение возможностей языка привело серьёзному ухудшению его качества из за чего он не может эффективно использоваться как средство низкоуровневого контексте задач для решения которых разработан си частности условиях сильно ограниченных вычислительных ресурсов например при многих встраиваемых систем неприемлемыми могут оказаться самые разные аспекты так механизм виртуальных функций реализуется посредством то есть требует динамического вычисления реального адреса функции rva шаблоны использование которых неизбежно при кодировании стиле так как на них основана стандартная библиотека приводят раздуванию кода ухудшению возможностей оптимизации наконец система может просто не располагать тем объёмом памяти который необходим для библиотеки времени исполнения rtl хотя формально стандарт не накладывает ограничений на состав этой библиотеки для конкретной программы на при полном её удалении большинство конструкций языка связанных rtl окажутся недоступными например операции new delete new delete результате сократится до си или его подмножества что делает бессмысленным его использование линус торвальдс говоря выборе между си низкоуровневых задачах замечает приводит очень очень плохим проектным решениям неизбежно начинают применяться замечательные библиотечные возможности вроде stl boost прочего мусора которые могут помочь но порождают невыносимую боль когда они не работают всякий кто утверждает что stl особенно boost стабильны портируемы настолько погряз во лжи что это даже не смешно неэффективно программные модели когда спустя два года обнаруживается что какая то абстракция была недостаточно эффективна но теперь весь код зависит ото всех окружающих её замечательных объектных моделей её нельзя исправить не переписав всё приложение другими словами единственный способ иметь хороший эффективный низкоуровневый портируемый сводится тому чтобы ограничиться всеми теми вещами которые элементарно доступны си ограничение проекта рамками си будет означать что люди его не выкинут что будет доступно множество программистов действительно хорошо понимающих низкоуровневые особенности не отказывающихся от них из за идиотской ерунды про объектные модели когда эффективность является первостепенным требованием преимущества будут огромной ошибкой соотнесение факторов затратами на разработку также общая культивируемая сообществе программистов дисциплина культура важны для заказчиков выбирающих язык соответственно предпочитающих этот язык разработчиков для реализации задуманных ими проектов также для людей начинающих изучать особенно намерением программировать для собственных нужд ручное управление памятью как отмечается исследовании программисты на си тратят общего времени разработки не считая отладки только на управление памятью если низкоуровневых задачах для которых разработан си это оправданно то прикладных задачах широкого спектра на которые претендует это не только является напрасным но чревато ошибками для существуют библиотечные средства автоматического управления памятью но они применяются далеко не всегда то же время существует эмпирическое исследование показывающее что разница скорости разработки программного обеспечения на на java которой реализована автоматическая сборка мусора невелика качество культура принцип не навязывать хороший стиль является достоинством лишь точки зрения снижения порога вхождения позиции качества предпочтительны языки сводящие минимуму влияние человеческого фактора то есть как раз навязывающие хороший стиль хотя такие языки имеют более высокий порог вхождения поскольку все элементы семантики отсутствующие си были заимствованы из других языков зачастую чужеродных алголу очевидно что для адекватного применения этих взаимно противоречивых возможностей избегания провоцируемых ими ошибок программисту на крайне желательно знать непосредственно эти языки источники лежащую их основе формальную базу то есть чем более широк кругозор программиста тем лучше он сможет программировать на однако на практике положительная оценка предпочтение использования характерны преимущественно для программистов не владеющих ни одним языком не являющимся потомком алгола не считая ограниченного набора языков таких как sql html perl др те же кто имеет опыт использования языков построенных на иной теоретической базе чаще отзываются скептически стараются его избегать если нет вынужденности поддерживать унаследованный код это даёт основания полагать что существует обратная зависимость между умением программировать на хорошем стиле желанием использовать качестве инструмента разработки из которой следует что защищающие программисты по всей видимости заблуждаются отношении того что именно следует считать хорошим стилем частности линус торвальдс говорит что использует мнение кандидатов качестве критерия отсева предпочитающие язык языку си отвергаются кошмарный язык его делает ещё более кошмарным тот факт что множество недостаточно грамотных программистов используют его откровенно говоря даже если нет никаких причин для выбора си кроме того чтобы держать программистов подальше то одно это уже будет достаточно веским основанием для использования си пришёл выводу что действительно предпочту выгнать любого кто предпочтёт вести разработку проекта на нежели на си чтобы этот человек не загубил проект который вовлечён исправление исправного непрерывная эволюция языка побуждает порой вынуждает программистов раз за разом изменять уже отлаженный код это не только удорожает разработку но несёт риск внедрения отлаженный код новых ошибок частности хотя изначально обратная совместимость си была одним из базовых принципов года си перестал быть подмножеством так что отлаженный код на си уже не может использоваться проекте на без изменений сложность ради самой сложности избыточная сложность оправдываемая принципом не платишь за то что не используешь тем не менее приводит увеличению стоимости развития поддержки продукта при этом определяется его апологетами как мощнейший именно потому что он изобилует опасными взаимно противоречивыми возможностями по мнению эрика реймонда это делает язык сам по себе почвой для личного самоутверждения программистов облегчая возможность субъективно превращать процесс разработки из средства самоцель программисты это зачастую яркие люди которые гордятся своей способностью справляться со сложностями ловко обращаться абстракциями часто они состязаются друг другом пытаясь выяснить кто может создать самые замысловатые красивые сложности соперники полагают что должны соревноваться чужими путём добавления собственных довольно скоро массивная опухоль становится индустриальным стандартом все используют большие переполненные ошибками программы которые не способны удовлетворить даже их создателей такой подход может обернуться неприятностями если программисты реализуют простые вещи сложными способами просто потому что им известны эти способы они умеют ими пользоваться саботаж отмечены случаи когда нерадивые программисты пользуясь сильной контекстной зависимостью отсутствием возможности отслеживания компилятором тормозили разработку проекта написав одну две лишних корректных точки зрения компилятора строки кода но внедрив за их счёт спонтанно проявляющуюся ошибку например define if if rand define iв языках доказанной корректностью даже развитыми макро средствами нанести урон подобным образом невозможно ненадёжность продукта неоправданное обилие побочных эффектов даже таких простых операциях как индексация массива сочетании отсутствием контроля со стороны системы времени исполнения языка слабой системой типов делает программы на традиционно нестабильными что исключает применение при высоких требованиях кроме того это увеличивает длительность самого процесса разработки общеизвестные сообщения об ошибках при фатальных крахах прикладных программ такие как access violation pure virtual function call или программа выполнила недопустимую операцию будет закрыта присущи наибольшей степени именно контр примеры для потомков ml фатальный крах принципе невозможен программа может навечно уйти расчёты или выдать сообщение об ошибке но никогда не обрушится кроме того контроль типов заметно сокращает время разработки семантика форта обеспечивает практически гарантированное выявление ошибок на этапе разработки eiffel smalltalk erlang предоставляют простые способы обработки любых возможных ошибок самой программой без обрушения менеджмент проектов перечисленные выше факторы делают сложность менеджмента проектов на одной из самых высоких индустрии разработки по джеймс коггинс течение четырёх лет ведущий колонку the report дает такое объяснение проблема том что программисты работающие ооп приложениями были нацелены на низкий уровень абстракции например они строили такие классы как связанный список вместо интерфейс пользователя или луч радиации или модель из конечных элементов несчастью строгая проверка типов которая помогает программистам избегать ошибок одновременно затрудняет построение больших объектов из маленьких влияние альтернативы неоднократно предпринимались попытки предложить альтернативы как для прикладного так для низкоуровневого не обязательно заявляемые как универсально применимые языки единственным прямым потомком является язык задуманный как переработка для устранения наиболее очевидных его проблем авторы отказались от совместимости си сохранив синтаксис многие базовые принципы введя язык возможности характерные для новых языков частности нет препроцессора включения заголовочных файлов множественного наследования но есть система модулей интерфейсы ассоциативные массивы поддержка unicode строках сборка мусора при сохранении возможности ручного управления памятью встроенная многопоточность вывод типов явное объявление чистых функций неизменяемых значений несмотря на преимущества не смог потеснить его использование весьма ограничено для программистов на различия возможностях учётом библиотек не стали достаточно весомым стимулом для перехода для тех кто нуждался альтернативе более оказались более радикальные варианты старейшим конкурентом задачах низкого уровня является objective также построенный по принципу объединения си объектной моделью только объектная модель унаследована от smalltalk исходя из идеи что эффективность низкоуровневые возможности си могут использоваться сложно высокоуровневых задачах только посредством облачения их ту или иную объектную модель одной из первых альтернатив прикладном стал язык java разработанный sun microsystems который часто ошибочно считают прямым потомком на деле java от нет ничего кроме базового синтаксиса семантика java унаследована от языка модула основы семантики java не прослеживаются учитывая это также генеалогию языков модула является потомком симулы как но им не является си java правильнее называть троюродным племянником нежели наследником по тому же пути пошла компания microsoft предложив язык попыткой совмещения безопасности скорости разработки характерных для java возможностями явился диалект managed впоследствии доработанный получивший название cli он разработан microsoft основном для переноса существующих проектов на под платформу microsoft net программы выполняются под управлением clr могут использовать весь массив библиотек net но при этом накладывается ряд ограничений на использование возможностей таких как множественное наследование ручное управление памятью прямое обращение api операционной системы возможно именно из за ограничений фактически сводящих данный диалект не получил широкого признания альтернативный путь развития языка си совмещение его не объектно ориентированным аппликативным то есть улучшение абстракции строгости модульности низкоуровневых программ посредством обеспечения не инкапсуляции изменяемого состояния предсказуемости поведения ссылочной прозрачности примерами работ этом русле служат языки bitc cyclone limbo хотя есть успешные попытки применения фп задачах реального времени без интеграции со средствами си всё же на данный момент низкоуровневой разработке применение той или иной мере средств си имеет лучшее соотношение трудоёмкости много усилий было приложено разработчиками python lua для обеспечения использования этих языков программистами на так что из всех языков достаточно тесно связанных фп именно они чаще всего отмечаются совместном использовании одном проекте наиболее значимыми точками соприкосновения фп можно считать привязки разработанных на библиотек wxwidgets qt характерной для идеологией языкам lisp haskell python большинстве случаев привязки функциональным языкам делают для библиотек написанных на си или на других функциональных языках ещё одним языком рассматриваемым как конкурент стал nemerle являющийся результатом попытки совместить модель типизации хиндли милнера макро подмножество common lisp языком том же русле находится созданный microsoft язык диалект ml адаптированный для среды net попыткой создать промышленную замену стал разработанный корпорации google году язык go авторы языка прямо указывают что мотивом для его создания были недостатки процесса разработки вызванные особенностями языков си go компактный несложный по структуре императивный язык си подобным синтаксисом без препроцессора со статической типизацией строгим контролем типов системой пакетов автоматическим управлением памятью некоторыми функциональными чертами функции значения замыкания экономно построенной ооп подсистемой без поддержки наследования реализации но интерфейсами утиной типизацией встроенной основанной на сопрограммах каналах la occam язык позиционируется как альтернатива то есть первую очередь средство групповой разработки вычислительных систем большой сложности том числе распределённых допускающее при необходимости низкоуровневое см также wxwidgets qt тернарная условная операция стандартная библиотека языка си стандартная библиотека языка aspectc примечания мнения пояснения литература ссылки комитет по стандартизации языка рабочие материалы комитета по стандартизации за год бьёрн страуструп the core guidelines are set of tried and true guidelines rules and best practices about coding in известный как новый стандарт языка доклад yet another conference бьёрн страуструп краткий обзор comp lang moderated учебник для начинающих окончательный список ресурсов для изучения категория категория языки ручным управлением памятью категория высокоуровневые языки категория низкоуровневые языки