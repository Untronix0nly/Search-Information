функциона льное программи рование раздел дискретной математики парадигма которой процесс вычисления трактуется как вычисление значений функций математическом понимании последних отличие от функций как подпрограмм процедурном парадигме императивного которая описывает процесс вычислений как изменение состояний значении подобном таковому теории автоматов при необходимости функциональном вся совокупность состояний вычислительного процесса представляется явным образом например как список функциональное предполагает обходиться вычислением результатов функций от исходных данных результатов других функций не предполагает явного хранения состояния программы соответственно не предполагает оно изменяемость этого состояния отличие от императивного где одной из базовых концепций является переменная хранящая своё значение позволяющая менять его по мере выполнения алгоритма на практике отличие математической функции от понятия функции императивном заключается том что императивные функции могут опираться не только на аргументы но на состояние внешних по отношению функции переменных также иметь побочные эффекты менять состояние внешних переменных таким образом императивном при вызове одной той же функции одинаковыми параметрами но на разных этапах выполнения алгоритма можно получить разные данные на выходе из за влияния на функцию состояния переменных функциональном языке при вызове функции одними теми же аргументами мы всегда получим одинаковый результат выходные данные зависят только от входных это позволяет средам выполнения программ на функциональных языках кешировать результаты функций вызывать их порядке не определяемом алгоритмом их без каких либо дополнительных действий со стороны программиста что обеспечивают функции без побочных эффектов чистые функции лямбда исчисление являются основой для функционального многие функциональные языки можно рассматривать как надстройку над ними языки функционального наиболее известными языками функционального являются лисп джон маккарти множество его диалектов наиболее современные из которых scheme clojure common lisp erlang joe armstrong функциональный язык поддержкой процессов elixir apl предшественник современных научных вычислительных сред таких как matlab ml робин милнер из ныне используемых диалектов известны standard ml objective caml функциональный язык семейства ml для платформы net scala miranda дэвид тёрнер который впоследствии дал развитие языку haskell nemerle гибридный функционально императивный язык xslt xquery haskell чистый функциональный назван честь хаскелла карри ещё не полностью функциональные изначальные версии лиспа apl внесли особый вклад создание развитие функционального более поздние версии lisp такие как scheme также различные варианты apl поддерживали все свойства концепции функционального языка как правило интерес функциональным языкам особенно чисто функциональным был скорее научный нежели коммерческий однако такие примечательные языки как erlang ocaml haskell scheme после также специфические статистика wolfram символьная математика финансовый анализ xslt xml находили применение индустрии коммерческого такие широко декларативные языки как sql lex yacc содержат некоторые элементы функционального например они остерегаются использовать переменные языки работы электронными таблицами также можно рассматривать как функциональные потому что ячейках электронных таблиц задаётся массив функций как правило зависящих лишь от других ячеек при желании смоделировать переменные приходится прибегать возможностям императивного языка макросов история лямбда исчисление стало теоретической базой для описания вычисления функций являясь математической абстракцией не языком оно составило базис почти всех языков функционального на сегодняшний день сходное теоретическое понятие комбинаторная логика является более абстрактным нежели исчисления было создано раньше эта логика используется некоторых эзотерических языках например unlambda исчисление комбинаторная логика были разработаны для более ясного точного описания принципов основ математики первым функциональным языком был лисп созданный джоном маккарти период его работы массачусетском технологическом институте конце пятидесятых реализованный первоначально для лиспе впервые введено множество понятий функционального языка хотя при этом языке применяется не только парадигма функционального дальнейшим развитием лиспа стали такие языки как scheme dylan язык обработки информации ipl иногда определяется как самый первый машинный функциональный язык это язык ассемблерного типа для работы со списком символов нём было понятие генератора который использовал функцию качестве аргумента также поскольку это язык ассемблерного уровня он может как язык имеющий функции высшего порядка однако целом ipl акцентирован на использование императивных понятий кеннет айверсон разработал язык apl начале шестидесятых документировав его своей книге programming language isbn apl оказал значительное влияние на язык созданный джоном бэкусом начале девяностых айверсон создали преемника apl язык середине девяностых ранее работавший айверсоном создал язык который впоследствии использовался финансовой индустрии на коммерческой основе семидесятых университете эдинбурга робин милнер создал язык ml дэвид тернер начинал разработку языка sasl университете сент эндрюса впоследствии язык miranda университете города кент конечном итоге на основе ml были созданы несколько языков среди которых наиболее известные objective caml standard ml также семидесятых осуществлялась разработка языка построенного по принципу scheme реализация не только функциональной парадигмы получившего описание известной работе lambda papers также книге восемьдесят пятого года structure and interpretation of computer programs восьмидесятых пер мартин лёф создал теорию типов также называемую конструктивной этой теории функциональное получило конструктивное доказательство того что ранее было известно как зависимый тип это дало мощный толчок развитию диалогового доказательства теорем последующему созданию множества функциональных языков haskell был создан конце восьмидесятых попытке соединить множество идей полученных ходе исследования функционального концепции некоторые концепции парадигмы специфичны для функционального основном чужды императивному включая объектно ориентированное тем не менее языки обычно представляют собой гибрид нескольких парадигм поэтому большей частью императивные языки могут использовать какие либо из этих концепций функции высших порядков функции высших порядков это такие функции которые могут принимать качестве аргументов возвращать другие функции математики такую функцию чаще называют оператором например оператор взятия производной или оператор интегрирования функции высших порядков позволяют использовать карринг преобразование функции от пары аргументов функцию берущую свои аргументы по одному это преобразование получило своё название честь карри чистые функции чистыми называют функции которые не имеют побочных эффектов ввода вывода памяти они зависят только от своих параметров возвращают только свой результат чистые функции обладают несколькими полезными свойствами многие из которых можно использовать для оптимизации кода если результат чистой функции не используется её вызов может быть удален без вреда для других выражений результат вызова чистой функции может быть мемоизирован то есть сохранен таблице значений вместе аргументами вызова если дальнейшем функция вызывается этими же аргументами её результат может быть взят прямо из таблицы не вычисляясь иногда это называется принципом прозрачности ссылок мемоизация ценой небольшого расхода памяти позволяет существенно увеличить уменьшить порядок роста некоторых рекурсивных алгоритмов если нет никакой зависимости по данным между двумя чистыми функциями то порядок их вычисления можно поменять или распараллелить говоря иначе вычисление чистых функций удовлетворяет принципам thread safe если весь язык не допускает побочных эффектов то можно использовать любую политику вычисления это предоставляет свободу компилятору комбинировать вычисление выражений программе например исключить древовидные структуры хотя большинство компиляторов императивных языков распознают чистые функции удаляют общие подвыражения для вызовов чистых функций они не могут делать это всегда для предварительно библиотек которые как правило не предоставляют эту информацию некоторые компиляторы такие как gcc целях оптимизации предоставляют программисту ключевые слова для обозначения чистых функций fortran позволяет обозначать функции как pure чистые рекурсия функциональных языках цикл обычно реализуется виде рекурсии строго говоря функциональной парадигме нет такого понятия как цикл рекурсивные функции вызывают сами себя позволяя операции выполняться снова снова для использования рекурсии может потребоваться большой стек но этого можно избежать случае хвостовой рекурсии хвостовая рекурсия может быть распознана оптимизирована компилятором код получаемый после компиляции аналогичной итерации императивном языке стандарты языка scheme требуют распознавать оптимизировать хвостовую рекурсию оптимизировать хвостовую рекурсию можно путём преобразования программы стиле использования продолжений при её компиляции как один из способов рекурсивные функции можно обобщить помощью функций высших порядков используя например катаморфизм анаморфизм или свертка развертка функции такого рода играют роль такого понятия как цикл императивных языках подход вычислению аргументов функциональные языки можно по тому как обрабатываются аргументы функции процессе её вычисления технически различие заключается денотационной семантике выражения примеру при строгом подходе вычислению выражения print len на выходе будет ошибка так как третьем элементе списка присутствует деление на ноль при нестрогом подходе значением выражения будет поскольку для вычисления длины списка значения его элементов строго говоря не важны могут вообще не вычисляться при строгом аппликативном порядке вычисления заранее подсчитываются значения всех аргументов перед вычислением самой функции при нестрогом подходе нормальный порядок вычисления значения аргументов не вычисляются до тех пор пока их значение не понадобится при вычислении функции как правило нестрогий подход реализуется виде редукции графа нестрогое вычисление используется по умолчанию нескольких чисто функциональных языках том числе miranda clean haskell фп языках принципиально нет препятствий для написания программ функциональном стиле на языках которые традиционно не считаются функциональными точно так же как программы объектно ориентированном стиле можно писать на структурных языках некоторые императивные языки поддерживают типичные для функциональных языков конструкции такие как функции высшего порядка списковые включения list comprehensions что облегчает использование функционального стиля этих языках примером может быть функциональное на python другим примером является язык ruby который имеет возможность создания как lambda объектов так возможность организации анонимных функций высшего порядка через блок помощью конструкции yield языке указатели на функцию качестве типов аргументов могут быть использованы для создания функций высшего порядка функции высшего порядка отложенная списковая структура реализованы библиотеках языке версии выше можно использовать функции для написания программы функциональном стиле сложных языках типа алгол имеющиеся средства фактически дополнения языка новыми конструкциями позволяют создать специфичные для функционального стиля объекты данных программные конструкции после чего можно писать функциональные программы их использованием стили императивные программы имеют склонность акцентировать шагов для выполнения какого то действия функциональные программы расположению композиции функций часто не обозначая точной шагов простой пример двух решений одной задачи используется один тот же язык python иллюстрирует это императивный стиль target создать пустой список for item in source_list для каждого элемента исходного списка trans item применить функцию trans trans применить функцию target append trans добавить преобразованный элемент список функциональная версия выглядит по другому функциональный стиль языки фп часто имеют встроенную функцию compose compose lambda lambda target map compose source_list отличие от императивного стиля описывающего шаги ведущие достижению цели функциональный стиль описывает математические отношения между данными целью более точно существует четыре ступени развития функционального стиля порядке убывания роли данных программах рефал для этой категории представленной единственным языком нет общепринятого названия аппликативные лисп ml tcl rebol комбинаторные apl бесточечные чистые конкатенативные joy cat factor подмножество postscript первом случае вся структура программы определяется структурой данных последнем данные как таковые вообще отсутствуют исходном коде они лишь подразумеваются на входе некоторые языки поддерживают ряд стилей например haskell позволяет писать аппликативном комбинаторном бесточечном стилях особенности основной особенностью функционального определяющей как преимущества так недостатки данной парадигмы является то что ней реализуется модель вычислений без состояний если императивная программа на любом этапе исполнения имеет состояние то есть совокупность значений всех переменных производит побочные эффекты то чисто функциональная программа ни целиком ни частями состояния не имеет побочных эффектов не производит то что императивных языках делается путём присваивания значений переменным функциональных достигается путём передачи выражений параметры функций следствием становится то что чисто функциональная программа не может изменять уже имеющиеся неё данные может лишь порождать новые путём копирования или расширения старых следствием того же является отказ от циклов пользу рекурсии сильные стороны повышение надёжности кода привлекательная сторона вычислений без состояний повышение надёжности кода за счёт чёткой структуризации отсутствия необходимости отслеживания побочных эффектов любая функция работает только локальными данными работает ними всегда одинаково независимо от того где как при каких обстоятельствах она вызывается невозможность мутации данных при пользовании ими разных местах программы исключает появление ошибок таких например как случайное присваивание неверного значения глобальной переменной императивной программе удобство организации модульного тестирования поскольку функция функциональном не может порождать побочные эффекты менять объекты нельзя как внутри области видимости так снаружи отличие от императивных программ где одна функция может установить какую нибудь внешнюю переменную считываемую второй функцией единственным эффектом от вычисления функции является возвращаемый ей результат единственный фактор оказывающий влияние на результат это значения аргументов таким образом имеется возможность протестировать каждую функцию программе просто вычислив её от различных наборов значений аргументов при этом можно не беспокоиться ни вызове функций правильном порядке ни правильном формировании внешнего состояния если любая функция программе проходит модульные тесты то можно быть уверенным качестве всей программы императивных программах проверка возвращаемого значения функции недостаточна функция может модифицировать внешнее состояние которое тоже нужно проверять чего не нужно делать функциональных программах возможности оптимизации при компиляции традиционно упоминаемой положительной особенностью функционального является то что оно позволяет описывать программу так называемом декларативном виде когда жесткая выполнения многих операций необходимых для вычисления результата явном виде не задаётся формируется автоматически процессе вычисления функций это обстоятельство также отсутствие состояний даёт возможность применять функциональным программам достаточно сложные методы автоматической оптимизации возможности параллелизма ещё одним преимуществом функциональных программ является то что они предоставляют широчайшие возможности для автоматического вычислений поскольку отсутствие побочных эффектов гарантировано любом вызове функции всегда допустимо параллельное вычисление двух различных параметров порядок их вычисления не может оказать влияния на результат вызова недостатки недостатки функционального вытекают из тех же самых его особенностей отсутствие присваиваний замена их на порождение новых данных приводят необходимости постоянного выделения автоматического освобождения памяти поэтому системе исполнения функциональной программы обязательным компонентом становится сборщик мусора нестрогая модель вычислений приводит порядку вызова функций что создает проблемы при вводе выводе где порядок выполнения операций важен кроме того очевидно функции ввода своем естественном виде например getchar из стандартной библиотеки языка не являются чистыми поскольку способны возвращать различные значения для одних тех же аргументов для устранения этого требуются определенные ухищрения для преодоления недостатков функциональных программ уже первые языки функционального включали не только чисто функциональные средства но механизмы императивного присваивание цикл неявный progn были уже лиспе использование таких средств позволяет решить некоторые практические проблемы но означает отход от идей преимуществ функционального написание императивных программ на функциональных языках чистых функциональных языках эти проблемы решаются другими средствами например языке haskell ввод вывод реализован при помощи монад нетривиальной концепции из теории категорий см также парадигма сравнение языков отложенные вычисления анаморфизм катаморфизм примечания литература городняя основы функционального курс лекций интернет университет информационных технологий isbn душкин функциональное на языке haskell дмк пресс isbn роганова функциональное учебное пособие для студентов высших учебных заведений гинфо миронов теория функциональных программ ссылки сильные стороны функционального почему никто не использует функциональные языки журнал практика функционального категория статьи примерами кода python