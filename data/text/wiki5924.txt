компилируемый язык общего назначения основанный на системе типов хиндли милнера отличается математически точным определением гарантирующим идентичность смысла программ вне зависимости от компилятора аппаратного обеспечения имеющим доказанную надёжность статической динамической семантики является функциональным языком то есть поддерживает большинство технических свойств функциональных языков но также предоставляет развитые возможности императивного при необходимости сочетает устойчивость программ гибкость на уровне динамически типизируемых языков быстродействие на уровне языка си обеспечивает превосходную поддержку как быстрого так модульности sml был первым самостоятельным компилируемым языком семействе ml до сих пор служит опорным языком сообществе по развитию ml sml впервые была реализована уникальная аппликативная система модулей см язык модулей ml общие сведения язык изначально ориентирован на программных систем он предоставляет эффективные средства абстракции модульности обеспечивая высокий коэффициент повторного использования кода это делает его подходящим также для быстрого программ том числе например процессе разработки тогда ещё компилятора на sml порой приходилось вносить радикальные изменения реализации ключевых структур данных влияющих на десятки модулей новая версия компилятора была готова течение дня см также icfp programming contest за при этом отличие многих других языков подходящих для быстрого sml может очень эффективно компилироваться sml известен своим относительно низким порогом вхождения служит языком обучения во многих университетах мира обширно документирован рабочем виде активно используется учёными качестве базы для исследования новых элементов языков идиом см например полиморфизм структурных типов настоящему времени все реализации языка включая устаревшие стали открытыми свободными отличительные особенности язык имеет математически точное формальное определение называемое определением для определения построено доказательство полной что гарантирует устойчивость программ предсказуемое поведение даже при некорректных входных данных возможных ошибках программистов даже содержащая ошибку программа на sml всегда продолжает вести себя как ml программа она может навечно уйти расчёты или породить исключение но она не может обрушиться sml является основном функциональным или языком то есть поддерживает большинство технических свойств функциональных языков но также предоставляет возможности императивного его чаще называют чтобы подчеркнуть поддержку первоклассных функций при этом отличить его от ссылочно прозрачных языков sml реализует выдающиеся средства поддержки за счёт наиболее мощной выразительной системы модулей среди известных см язык модулей ml sml реализована ранняя версия языка модулей являющаяся отдельным слоем языка модули могут содержать объекты ядра языка но не наоборот отличие многих других языков семейства ml ocaml haskell felix opa nemerle др sml весьма минималистичен он не имеет изначально встроенных средств объектно средств конкурентности ad hoc полиморфизма динамической типизации генераторов списков многих других возможностей однако sml отличается то есть реализует минимально необходимый но полный набор максимально различных элементов что позволяет сравнительно легко эмулировать прочие возможности необходимые для этого приёмы широко освещены литературе фактически sml позволяет использовать сколь угодно высокоуровневую качестве примитивной для реализации ещё более высокого уровня частности построены модели реализации классов типов монад использованием только стандартных конструкций sml также средств объектно более того sml является одним из немногих языков котором непосредственно реализованы продолжения первого класса возможности мощная выразительная система типов является отличительной особенностью ml его потомков она обеспечивает надёжность программ за счёт раннего выявления ошибок высокий коэффициент повторного использования кода высокий потенциал оптимизации сочетая эти качества на уровне динамически типизируемых языков наиболее характерными чертами присущими являются полиморфизм типов также алгебраические типы данных сопоставление образцом на них реализация sml имеет следующие особенности поддерживается полная абстракция единообразие типов любой конструктор типов применим любому типу вводимые пользователем типы используются неотличимо от встроенных полиморфизм типов ограничен пренексным полиморфизмом имеет дополнительные ограничения отдельное место отводится типам допускающим проверку на равенство выведение почти всех типов за единичными исключениями разнообразие встроенных разновидностей типов произведений используемых без необходимости объявления записи кортежи реализованные как записи номерами качестве имён полей массивы служащие для обеспечения высокой эффективности см далее исключения имеют особую семантику тип исключения является единственным языке расширяемым типом то есть всякое определение exception вводит программу новую конструирующую функцию для типа exn как следствие определения исключений являются порождающими то есть повторение идентичного определения exception foo exception foo вводит два разных конструктора несовместимых друг другом из за совпадения имён второй заслоняет видимость первого это делает механизм динамической обработки исключений статически типобезопасным но не гарантирует отсутствие необработанных исключений соответствующие доработки системы типов были предложены много позже см полиморфизм управляющих конструкций поддержка функционального всё выражение все функции являются объектами первого класса представленными виде замыканий доступно каррирование для функций но не для конструкторов типов по умолчанию все объявляемые значения константны лексическая область видимости позволяющее инкапсулировать изменяемое состояние функции лямбда абстракция гарантия оптимизации хвостовых вызовов это особенно важно для эффективной реализации продолжений см стиле передачи продолжений поддержка императивного исполнение выражений однозначном порядке слева направо мутабельные ячейки аккуратно обособленные системе типов виде ссылок обеспечивающих полную безопасность по типам по доступу памяти за их счёт возможность эмуляции вызова по ссылке мутабельные массивы отдельно от константных которые также доступны обработка исключений цикл while полное сохранение духа ml императивных участках кода возможность их безопасного смешивания чистыми обеспечение высокой эффективности программ энергичная семантика передачи параметров мутабельные ячейки стандартная поддержка нескольких разновидностей массивов константных vector мутабельных array том числе двухмерных array мономорфных monovector monoarray полиморфных также их некопирующих срезов строковые типы как си реализованы посредством массивов символов то есть тип string определён как char vector также доступны их некопирующие срезы тип substring гарантия оптимизации хвостовых вызовов полное статическое разрешение типов всех выражений включая полиморфную проверку значений на равенство полным удалением информации типах целевом коде но остаётся контроль переполнения некоторых реализациях очень тонкий быстрый ffi доступность каламбуров типизации ручной контроль над сборщиком мусора другие нестандартные особенности способы использования отличие от многих языков sml предоставляет большое многообразие способов своего использования интерактивное доказательство теорем repl явная загрузка модулей традиционная для потомков лиспа пакетная компиляция традиционная для потомков алгола bcpl полнопрограммно оптимизирующая компиляция порой позволяющая конкурировать быстродействии си см mlton интерпретация очень редко при этом определённых режимах возможны самые разные целевые платформы стратегии компиляции машинный код на данный момент покрывается порядка десятка семейств архитектур теоретически может быть существенно шире чем всех потомков алгола bcpl за счёт более высокого уровня абстракции от машинного языка каждом случае потенциально возможно создание эффективно оптимизирующего компилятора общепринятые байт коды jvm net собственные байт коды языки общего назначения семантически более низкого уровня си ada java ассемблер только пакетно или полнопрограммно другие диалекты ml см сами стратегии компиляции также существенно различаются стиле передачи продолжений представление адресов функций глобальным вариантным типом сохранение явных потоков исходного кода автоматическое уплощение многопоточного исходного кода до линейного обёрнутое boxed или не обёрнутое unboxed представление примитивных типов динамическая или статическая сборка мусора одном потоке приложением или отдельном полностью автоматическая или возможностью явного контроля язык базовая семантика объявления выражения блоки функции примитивные типы составные определяемые типы мутабельные значения ограничение на значения ограничение на значения управляющие конструкции модульность система модулей sml является наиболее развитой системой модулей языках она повторяет семантику так что зависимости между крупными компонентами программ строятся подобно зависимостям мелкого уровня эта система модулей состоит из трёх видов модулей структур structure сигнатур signature функторов functor структуры похожи на модули большинстве языков сигнатуры служат интерфейсами структур но не привязываются жёстко определённым структурам выстраивают отношения по схеме позволяя гибко управлять видимостью компонентов структур зависимости от нужд контекста программы функторы представляют собой функции над структурами позволяя разрывать зависимости времени компиляции описывать модули они дают возможность типобезопасным образом описывать вычисления над компонентами программ которые других языках могут реализовываться только посредством как шаблоны только без боли страданий или макроязык лиспа только со статическим контролем безопасности порождаемого кода большинство языков вовсе не имеют ничего сравнимого функторами принципиальным отличием языка модулей ml является то что результат функтора может включать не только значения но типы причём они могут зависеть от типов входящих состав параметра функтора этим модули ml оказываются наиболее близки своей выразительности системам зависимыми типами но отличие от последних модули ml могут быть редуцированы плоскую см язык модулей ml преобразование россберга руссо дрейера синтаксис синтаксический сахар синтаксис языка очень краток по количеству слов занимает промежуточную позицию между haskell pascal sml имеет контекстно свободную грамматику хотя ней отмечены некоторые неоднозначности использует lalr но одном месте присутствует lalr список ключевых слов языка совпадающие ними идентификаторы не допускаются abstype and andalso as case datatype do else end eqtype exception fn fun functor handle if in include infix infixr let local nonfix of op open orelse raise rec sharing sig signature struct structure then type val where while with withtype допустимы также символьные идентификаторы то есть имена типов данных функций могут состоять из следующих небуквенных символов имена из этих символов могут быть любой длины val fun infix fun val list foldr разумеется использование таких имён на практике не желательно но если предыдущий автор поддерживаемого кода их интенсивно применял то благодаря формальному определению становится возможным sml сам позволяет довольно легко эту задачу решить написание препроцессора для исправления мнемоники исключаются лишь следующие цепочки символов причина этого ограничения заключена их особой роли синтаксисе языка аннотирование типа значения разделение образцов отделение тела функции от её заголовка отделение тела лямбда функции от её заголовка конструктор функционального стрелочного типа доступ полю записи сопоставление структуры сигнатурой sml не предусмотрено встроенного синтаксиса для массивов векторов константных массивов некоторые реализации той или иной мере поддерживают синтаксис для массивов векторов качестве расширения операция присваивания записывается как языках семейства паскаль экосистема языка стандартная библиотека стандартная библиотека sml носит название базиса она формировалась много лет пройдя тщательное тестирование на реальных задачах на базе её черновик был опубликован году затем её спецификация была официально издана году этот период уже появлялись руководства по её использованию базисная библиотека реализует лишь необходимый минимум модулей тривиальные типы данных арифметика над ними ввод вывод платформенно независимый интерфейс операционной системе но не реализует более сложную например многопоточность многие компиляторы дополнительно представляют различные библиотеки компиляторы могут использовать знания базисе для применения заранее алгоритмов техник оптимизации например mlton использует нативное представление типов базиса точности соответствующее примитивным типам языка си также простейших агрегатных типов составленных из них как большинстве языков базисе sml действует ряд определённых архитектурных синтаксических соглашений прежде всего это тривиальные составляющие стандартных структур таких как сходные по названию сигнатурам комбинаторы такие как fold далее это на большинство типов схема преобразования строковый тип обратно конверторы сканеры стандартная схема преобразования строковый тип обратно инкапсулирована структуру stringcvt structure stringcvt sig datatype radix bin oct dec hex datatype realfmt sci of int option fix of int option gen of int option exact type reader option val padleft char int string string val padright char int string string val splitl char bool char reader string val takel char bool char reader string val dropl char bool char reader val skipws char reader type cs val scanstring char cs reader cs reader string option end схема преобразования не ограничивается перечислением обоснований систем счисления как си bin oct dec hex она на позволяя описывать операции чтения значений конкретных типов из абстрактных потоков записи них затем преобразовывать простые операции более сложные посредством комбинаторов роли потоков могут выступать как стандартные потоки ввод вывода так просто агрегатные типы такие как списки или строки ключевым ингредиентом этой схемы являются ридеры то есть значения типа reader интуитивно ридер это функция которая принимает на вход поток типа предпринимает попытку считать из него значение типа возвращая либо считанное значение остаток потока либо none случае неудачи важной разновидностью ридеров являются сканеры или сканирующие функции для данного типа сканирующая функция имеет тип char reader reader то есть представляет собой конвертор из ридера символов ридер данного типа сканеры входят состав многих стандартных модулей например сигнатура integer включает сканер для целых чисел signature integer sig eqtype int val scan stringcvt radix char stringcvt reader int option end числа считываются атомарным образом но ридеры могут считывать из потоков цепочки поэлементно например посимвольно строку из строки fun stringgetc let val ss substring full in case substring getc ss of none none some ss some substring string ss end stringgetc hello val it some ello char string option stringgetc valof it val it some llo char string option stringgetc valof it val it some lo char string option stringgetc valof it val it some char string option stringgetc valof it val it some char string option stringgetc valof it val it none char string option сканеры позволяют создавать ридеры из имеющихся ридеров например val stringgetint int scan stringcvt dec stringgetc структура stringcvt предоставляет также ряд вспомогательных функций например splitl takel dropl комбинируют символьные ридеры символьными предикатами позволяя фильтровать потоки следует отметить что не символьные ридеры являются особым случаем ридеров вообще наоборот причина этого том что извлечение из представляет собой обобщение извлечения подстроки из строки портирование большинство реализаций языка достаточно строго соответствуют определению различия заключаются технических деталях таких как бинарный формат раздельно компилируемых модулей реализация ffi др на практике реальная программа должна отталкиваться от некоего базиса минимального набора типов средств ввода вывода однако определение предъявляет лишь минимальные требования составу начального базиса так что единственный обозримый результат корректной программы согласно определению состоит том что программа завершается либо порождает исключение большинство реализаций совместимы на этом уровне однако даже стандартном базисе заложены определённые потенциальные проблемы портируемости например константа int maxint содержит значение наибольшего возможного целого упакованное его необходимо извлекать либо сопоставлением образцом либо вызовом функции valof для типов конечной размерности значение int maxint равно some использование обоих способов извлечения равнозначно но intinf maxint равно none так что прямое обращение содержимому через valof породит исключение option по умолчанию intinf открыта например компиляторе определёнными усилиями возможна разработка программ свободно портируемых между всеми актуальными реализациями языка примером такой программы является hamlet инструментарий разработки настоящему времени полностью стал достоянием общественности все реализации являются бесплатными открытыми под самыми лояльными лицензиями bsd style mit тексты определения языка как версии года так ревизированной версии года спецификации базиса также доступны бесплатно sml имеет большое число реализаций значительная их часть написана на самом sml исключение составляют рантаймы некоторых компиляторов написанные на си ассемблере также система диалекты расширения sml sml сайт проекта консервативно расширяет sml полиморфизмом записей модели ацуси охори который sml используется для бесшовного встраивания sql код на sml для интенсивного database символ решётки названии языка символизирует селектор операцию выбора поля из записи одноимённый компилятор претендует на хорошее быстродействие разработан развивается институте тохоку япония под руководством самого охори alice alice ml консервативно расширяет sml примитивами для конкурентного на основе экзотичной стратегии вычисления call by future вызов по будущности решателем ограничениях также всеми согласованными элементами проекта частности alice поддерживает модули первого класса форме пакетов динамической загрузкой динамической типизацией что позволяет реализовывать распределённые вычисления alice также наделяет будущности первоклассными свойствами том числе предоставляя будущности уровня модулей будущные структуры будущные сигнатуры одноимённый компилятор использует виртуальную машину разработан развивается саарландском университете под руководством андреаса россберга concurrent ml библиотека воплощающая встраиваемый язык который расширяет sml конструкциями конкурентного на основе модели синхронной передачи первоклассных сообщений входит стандартную поставку компиляторов mlton ключевые идеи cml лежат основе проекта manticore включены проект manticore manticore сайт проекта реализует всестороннюю поддержку конкурентного параллельного от логической декомпозиции системы на процессы до тонкого котроля за максимально эффективным использованием многоядерных систем manticore основан на подмножестве sml исключая мутабельные массивы ссылки то есть является чистым языком сохраняя строгий порядок вычисления механизмы явной конкурентности грубого параллелизма потоки основаны на cml механизмы тонкого параллелизма уровня данных параллельные массивы аналогичны одноимённый компилятор порождает нативный код mlpolyr mlpolyr основанный на простейшем подмножестве sml дополняющий его несколькими уровнями целью проекта является глубокое исследование полиморфизма записей для нужд проекта инновационная система типов mlpolyr решает гарантирует отсутствие необработанных исключений программах разработан под руководством матиаса блюма автора nlffi сша mythryl mythryl сайт проекта синтаксический вариант sml нацеленный на повышение скорости разработки под posix новый синтаксис во многом заимствован из си терминология также пересмотрена под более традиционную например функторы переименованы дженерики при этом авторы подчёркивают что не намерены создать очередную свалку языковых возможностей придерживаются минималистичной природы sml опираются на его определение реализация является форком прочие расширение sml средствами порождающего утилиты compilation manager cm mlbasis system mlb расширения компиляторов для лучшей поддержки модульности контроля зависимостей принципе для этой цели мог бы использоваться традиционный для большинства языков make но язык модулей sml значительно мощнее средств модульности других языков make его преимуществ не поддерживает не пригоден для работы режиме repl cm изначально реализован затем портирован на mlton позже составе mlton была предложена система mlb конвертор файлов формата cm формат mlb поддержка mlb была добавлена exene библиотека графического интерфейса пользователя под window system реализует реактивную модель взаимодействия на основе cml поставляется mllex mlyacc mlantlr mllpt генераторы лексеров парсеров см lex yacc межъязыковое взаимодействие foreign function interface разных компиляторах имеет разную реализацию что тесно связано представлением данных прежде всего обёрнутое или необёрнутое теговое или бестеговое sml nj ffi основан на динамической кодогенерации если функция принимает на вход данные общим объёмом байт возвращает байт то её вызов имеет сложность некоторые компиляторы mlton используют необёрнутое бестеговое представление данных обеспечивают прямые обращения функциям данным си последнем случае вынесение медлительных функций код на си может существенно повышать общее быстродействие программы nlffi no longer foreign function interface альтернативный более высокоуровневый nlffi автоматически порождает связующий код позволяя подключать файлы заголовочные файлы си непосредственно состав проекта на sml cm или mlb что снимает необходимость ручного кодирования определений ffi конструктивно идея nlffi состоит моделировании системы типов си посредством типов ml реализация основана ckit поставляется mlton ckit фронт энд языка си написанный на sml осуществляет трансляцию исходных кодов на си учётом препроцессора ast реализуемое посредством структур данных языка sml лежит основе реализации nlffi идеоматика соглашения оформлению программ на sml не предъявляется никаких требований поскольку грамматика языка полностью контекстно свободна не содержит явных тем не менее ней отмечаются частные проблемы например при передаче оператора умножения op закрывающую скобку необходимо отделять пробелом op так как при сплошном написании многие реализации не все принимают пару символов за закрытие комментария коде выдают ошибку однако всё же существуют определённые рекомендации нацеленные на улучшение читабельности модульности повторного использования кода также раннего обнаружения ошибок повышения но не для внесения информации типах идентификаторы как это делается например венгерской нотации частности sml рекомендуется правило именования идентификаторов уровня ядра языка аналогичное тому что требуется haskell foobar для значений foo_bar для конструкторов типов foobar для конструирующих функций некоторые компиляторы даже выдают предупреждение при его нарушении это связано особенностью работы механизма сопоставления образцом который общем случае не способен отличить ввод локальной переменной от использования нуль арного конструктора типов так что опечатки могут приводить сравнительно легко обнаружимым ошибкам наиболее непривычными неожиданными могут быть предпочтение шага отступа частое применение апострофа идентификаторах аналогично принятому математике если на основе требуется построить новый то большинстве языков пишут sml как математике зачастую икс штрих синтаксис бинарных логических операций или andalso orelse соответственно синтаксис инфиксных операций конкатенации строк списков соответственно для векторов массивов не предусмотрены процедуры для процедур принята та же идиома что си процедуры представляются функциями возвращающими значение fun print val fn sting unit вычисления let in end fun foo let val in end приёмы эта расширение эта расширение выражения есть выражение fn то есть обёртка исходного выражения лямбда функцию где не встречается разумеется это имеет смысл лишь случае если имеет стрелочный тип то есть является функцией эта расширение принуждает задержку вычисления до применения функции повторное его вычисление при каждом применении этот приём применяется sml для преодоления ограничений выразительности связанных семантикой ограничения на значения термин эта расширение заимствован из эта преобразования лямбда исчислении означающего напротив редукцию выражения fn до случае если не встречается эта сжатие значения индексированные типами значения индексированные типами это техника позволяющая ввести sml поддержку ad hoc полиморфизма которая нём изначально отсутствует существует целый ряд её вариантов том числе нацеленные на поддержку полноценного объектно fold fold это техника позволяющая ввести sml ряд идиом включая функции переменным числом аргументов именованные параметры функций значения параметров по умолчанию синтаксическую поддержку массивов коде функциональное обновление записей косметическое изображение зависимой типизации для обеспечения функций вроде printf примеры программ hello world простейшая программа на sml может быть записана одну строку print hello world однако учитывая языка на минимальной всё же следует считать её обёртку язык модулей некоторые компиляторы работают только программами уровня модулей выходной машинный код для минимальной программы также получается относительно крупным сравнении реализаций hello world на си поскольку даже самая маленькая программа на sml обязана включать себя рантайм систему языка бо льшую часть которой составляет сборщик мусора однако не следует воспринимать размер исходного машинного кодов на начальном этапе как тяжеловесность sml их причиной является интенсивная языка на разработку крупных сложных систем дальнейшее наращивание программ происходит по существенно более пологой кривой чем большинстве других статически типизируемых языков оверхед становится едва заметным при разработке серьёзных программ автоматическая вёрстка fun firstline let val name rest substring splitl fn substring full in substring string name substring string rest end fun htmlcvt filename let val is textio openin filename and os textio openout filename html fun cvt none cvt some cvt true textio inputline is cvt first some textio output os if first then firstline else cvt false textio inputline is in cvt true some textio closein is textio closeout os end этот код преобразует по простейшим правилам плоский текст html оформляя диалог по ролям троичные деревья для задачи поиска строки словаре сочетают молниеносную скорость префиксных деревьев экономичностью двоичных деревьев отношении памяти type key key ord_key type item key ord_key list datatype set leaf node of key key lt set eq set gt set val empty leaf exception alreadypresent fun member leaf false member node key lt eq gt case key compare key of equal member eq less member lt greater member gt member node key lt eq gt case key compare key sentinel key of equal true less member lt greater member gt fun insert leaf node key eq insert leaf lt leaf gt leaf insert leaf node key key sentinel eq leaf lt leaf gt leaf insert node key lt eq gt case key compare key of equal node key key lt lt gt gt eq insert eq less node key key lt insert lt gt gt eq eq greater node key key lt lt gt insert gt eq eq insert node key lt eq gt case key compare key sentinel key of equal raise alreadypresent less node key key lt insert lt gt gt eq eq greater node key key lt lt gt insert gt eq eq fun add insert handle alreadypresent этот код использует базисную структуру key сопоставимую сигнатурой ord_key также глобальный тип order над которым частности определена функция key compare datatype order less equal greater языке быстродействие типичные преимущества функционального автоматическое управление памятью высокий уровень абстракции др проявляются обеспечении надёжности вообще программ ответственных особенно задачах быстродействие часто играет второстепенную роль упор на эти свойства исторически привёл тому что программистам на функциональных языках зачастую оказываются недоступны многие эффективные структуры данных массивы строки битовые цепочки поэтому функциональные программы обычно заметно менее эффективны чем эквивалентные программы на си ml изначально предоставляет весьма неплохие средства для тонкого контроля за быстродействием однако исторически реализации ml были крайне медлительными тем не менее ещё начале прочил языку sml скорость исполнения выше скорости языка си по крайней мере при интенсивной работе со данными но sml не претендует на то чтобы быть заменой си задачах системного за следующие несколько лет напряжённая работа над развитием компиляторов привела тому что скорость исполнения программ на sml повысилась раз конце стивен уикс задался целью добиться от программ на sml максимально возможной написал дефункторизатор для сразу показавший прирост скорости ещё раза дальнейшая работа этом направлении привела созданию компилятора mlton который середине нулевых годов xxi века показывал прирост скорости перед другими компиляторами среднем на два порядка конкурируя си подробнее см mlton стратегия автоматического управление памятью на основе выведения регионов позволяет устранять затраты на инициализацию высвобождение памяти из исполнения программы то есть реализует сборку мусора на этапе компиляции компилятор использует эту стратегию позволяя решать задачи реального времени хотя он уступает mlton по возможностям оптимизации на основе фронт енда был разработан компилятор исходный код на си sml он порождает код хорошего качества но примечательно что схема компиляции сперва си затем машинный код до двух раз снижает быстродействие по сравнению прямой компиляцией sml машинный код из за семантических различий между sml си некоторые компиляторы sml предоставляют возможность профилирования кода целью определения функций занимающих наибольшее процессорное время причём результат всегда неожиданный после чего можно сосредоточиться на их оптимизации средствами sml либо вынести их код на си через ffi обоснование семантики общие сведения теоретической основой языка является полиморфно типизированное лямбда исчисление система ограниченное let полиморфизмом определение the definition официальным стандартом языка является изданное виде книги определение определение сформулировано строгих математических понятиях имеет доказанную надёжность определения позволяет человеку без запуска конкретного компилятора проверить программу на корректность вычислить её результат но другой стороны определение требует высокой квалификации для понимания не может служить учебником по языку доказуемость надёжности не далась сама по себе определение было неоднократно пересмотрено прежде чем увидело свет многие языки опираются на общие теории но при разработке они почти никогда не проверяются на безопасность совместного использования конкретных языковых элементов являющихся частными приложениями этих теорий что неизбежно приводит несовместимости между реализациями языка эти проблемы либо игнорируются либо начинают преподноситься как естественное явление но их причиной является то что язык не был подвергнут математическому анализу семантика харпера стоуна семантика харпера стоуна сокращённо семантика представляет собой интерпретацию sml типизированной системе семантика sml по определяется через выработку внешнего языка sml во внутренний язык представляющий собой типизированное лямбда исчисление таким образом служит теоретико типовым обоснованием языка эта интерпретация может рассматриваться как альтернатива определению формализующая статические семантические объекты через выражения типизированного лямбда исчисления также как декларативное описание правил выработки для компиляторов управляемых типами таких как tilt или sml nj фактически фронт енд компилятора tilt воплощает эту семантику хотя он был разработан на несколько лет раньше внутренний язык основан на языке xml харпера митчела но имеет более обширный набор примитивов более выразительную систему модулей основанную на просвечивающих суммах харпера лилибриджа этот язык пригоден для выработки многих других языков семантика которых основана на лямбда исчислении таких как haskell scheme применение этого подхода заложено проект при этом изменения языке на внутренний язык рассматриваются как кратковременная перспектива требующие его изменения как долговременная перспектива критика сравнение альтернативами разработчики sml изначально установили самую высокую планку требований качества для языка так что порог критики располагается намного выше чем большинства промышленных языков упоминания недостатках языка sml встречаются официальной печати так же часто как языка много чаще большинства других языков но причина вовсе не негативном отношении sml напротив всякая критика sml производится очень тёплым отношением нему даже педантичный разбор недостатков sml обычно сопровождается его описанием как изумительного языка единственного серьёзного из существующих иначе говоря исследователи досконально копаются недостатках подразумевая что даже их учётом sml оказывается более предпочтителен для применения гигантских наукоёмких проектах чем многие более популярные языки желая довести sml до совершенства история философия терминология формальная семантика sml ориентирована на интерпретацию однако большинство его реализаций является компиляторами том числе интерактивными компиляторами некоторые из которых уверенно соперничают по эффективности языком си так как язык хорошо поддаётся глобальному анализу по той же причине sml может компилироваться исходный код на других языках высокого или среднего уровня например существуют комплияторы из sml си ada основе языка лежит сильная статическая полиморфная типизация которая не только обеспечивает верификацию программ на этапе компиляции но жёстко обособляет мутабельность что само по себе повышает потенциал автоматической оптимизации программ частности упрощает реализацию сборщика мусора первая версия ml была представлена миру году роли мета языка для построения интерактивных доказательств составе системы её реализовали малькольм ньюи локвуд моррис робин милнер на платформе dec первая реализация была крайне неэффективной так как конструкции ml транслировались lisp который затем первое полное описание ml как компонента lcf издано году около года реализовал первый компилятор дополнив ml некоторыми своими идеями вскоре карделли портировал на unix используя berkley pascal среда выполнения была переписана на си но большая часть компилятора оставалась на паскале работа карделли вдохновила милнера на создание sml как языка общего назначения они начали совместную работу эдинбурге результатом чего стал компилятор выпущенный году процессе этой работы майк гордон придумал ссылочные типы предложил их луи дамасу который позже защитил на них диссертацию одновременно велось сотрудничество кэмбриджа inria жерар хью из inria портировал ml на maclisp под multics inria разработали собственный диалект ml названный caml впоследствии развившийся ocaml оптимизировал так что код на ml стал работать раз быстрее вскоре после этого дэвид мэтьюз разработал язык poly на основе ml дальнейшая работа этом направлении привела созданию среды дэвид маккуин сформулировал язык модулей ml работе подключился совместно они начали вести работу над компилятором который служил одновременно платформой для развития языка первым промышленным оптимизирующим компилятором многие из реализаций языка были первоначально разработаны использованием затем раскручены опытом разработок был обнаружен ряд недочётов определении языка от года часть недостатков была устранена ревизии определения от года но рамки ревизии исключают потерю обратной совместимости коды адаптируются косметически без необходимости переписывания нуля году была опубликована спецификация на состав базисной библиотеки черновик спецификации датируется годом другие недостатки были устранены других языках ml породил целое семейство типизированных языков эти языки завоевали популярность на задаче разработке языков часто определяются как dsl для исследователи занимавшиеся развитием использованием sml на протяжении почти трёх десятилетий концу xx века сформировали сообщество по созданию нового языка фактически sml не был первым семействе после собственно lcf ml ему предшествовали такие языки как hope французы поддерживают собственный диалект caml ocaml тем не менее говоря ml многие подразумевают sml даже пишут через дробь ml sml изучение наиболее рекомендуемым учебником по sml является книга автора системы ml for the working programmer для первоначального ознакомления языком может быть полезен краткий несколько десятков страниц курс introduction to standard ml доступный русском переводе который он использовал для преподавания языка за следующие два десятилетия расширил до более крупного учебника учебным руководством по использованию стандартной библиотеки языка предполагающим его базовое знание служит книга рикардо пуцеллы числе других учебников можно назвать книги гилмора ульмана шипмана среди руководств по использованию языка можно выделить книгу ведущего разработчика modern compiler implementation in ml этой книги есть две сестры близняшки modern compiler implementation in java modern compiler implementation in эквивалентные по структуре но использующие другие языки для воплощения излагаемых методов имеется также масса статей издаваемых таких журналах как jfp ml workshop др применение sml наряду ocaml служит первым языком преподавания обучения во многих университетах мира среди аппликативных языков они имеют вероятно самый низкий собственный порог вхождения значительная часть существующих кодов на sml представляет собой либо реализацию его же компиляторов либо системы автоматического доказательства такие как все они свободны открыты тем не менее существуют более приземлённые том числе проприетарные продукты см также ml successor ml проект дальнейшего развития standard ml языки ocaml yeti примечания литература стандарты бесплатная pdf версия бесплатная pdf версия бесплатная pdf версия бесплатная онлайн версия учебники руководства справочники использование общая техника усиления типизации для раннего выявления ошибок см также полнотиповое история анализ критика прочее ссылки