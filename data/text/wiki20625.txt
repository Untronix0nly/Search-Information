виртуальный метод виртуальная функция объектно ориентированном метод функция класса который может быть переопределён классах наследниках так что конкретная реализация метода для вызова будет определяться во время исполнения таким образом программисту необязательно знать точный тип объекта для работы ним через виртуальные методы достаточно лишь знать что объект принадлежит классу или наследнику класса котором объявлен метод одним из переводов слова virtual английского языка может быть фактический что больше подходит по смыслу использование виртуальные методы один из важнейших приёмов реализации полиморфизма они позволяют создавать общий код который может работать как объектами базового класса так объектами любого его класса наследника при этом базовый класс определяет способ работы объектами любые его наследники могут предоставлять конкретную реализацию этого способа способ определения одни языки например требуют явно указывать что данный метод является виртуальным других языках например java python все методы являются виртуальными по умолчанию но только те методы для которых это возможно например java методы доступом private не могут быть переопределены связи правилами видимости базовый класс может не предоставлять реализации виртуального метода только декларировать его существование такие методы без реализации называются чистыми виртуальными перевод или абстрактными класс содержащий хотя бы один такой метод тоже будет абстрактным объект такого класса создать нельзя некоторых языках допускается но вызов абстрактного метода приведёт ошибке наследники абстрактного класса должны предоставить реализацию для всех его абстрактных методов иначе они свою очередь будут абстрактными классами абстрактный класс который содержит только абстрактные методы называется интерфейсом реализация техника вызова виртуальных методов называется ещё динамическим связыванием имеется виду что имя метода использованное программе связывается адресом входа конкретного метода динамически во время исполнения программы не статически во время компиляции так как момент компиляции общем случае невозможно определить какая из существующих реализаций метода будет вызвана компилируемых языках динамическое связывание выполняется обычно использованием таблицы виртуальных методов которая создаётся компилятором для каждого класса имеющего хотя бы один виртуальный метод элементах таблицы находятся указатели на реализации виртуальных методов соответствующие данному классу если классе потомке добавляется новый виртуальный метод его адрес добавляется таблицу если классе потомке создаётся новая реализация виртуального метода соответствующее поле таблице заполняется адресом этой реализации таким образом для адреса каждого виртуального метода дереве наследования имеется одно фиксированное смещение таблице виртуальных методов каждый объект имеет техническое поле которое при создании объекта указателем на таблицу виртуальных методов своего класса для вызова виртуального метода из объекта берётся указатель на соответствующую таблицу виртуальных методов из неё по известному фиксированному смещению указатель на реализацию метода используемого для данного класса при использовании множественного наследования ситуация несколько усложняется за счёт того что таблица виртуальных методов становится нелинейной пример виртуальной функции на диаграмма класса animal пример на иллюстрирующий отличие виртуальных функций от невиртуальных предположим базовый класс animal животное может иметь виртуальный метод eat есть подкласс класс потомок fish рыба переопределит метод eat не так как его переопределит подкласс wolf волк но можно вызвать eat на любом экземпляре класса унаследованного от класса animal получить поведение eat соответствующее данному подклассу это позволяет программисту обрабатывать список объектов класса animal вызывая над каждым объектом метод eat не задумываясь том какому подклассу принадлежит текущий объект то есть как питается конкретное животное интересной деталью виртуальных функций является поведение аргументов по умолчанию при вызове виртуальной функции аргументом по умолчанию тело функции берется реального объекта значения аргументов по типу ссылки или указателя class animal public void невиртуальный move std cout move eat delete так как деструктор виртуальный для каждого объекта вызовется деструктор его класса return вывод this animal moves in some way wolf eats meat this animal moves in some way animal eat something пример аналога виртуальных функций php аналогом php можно считать использование позднего статического связывания class foo public static function baz return вода public function echo static baz позднее статическое связывание class bar extends foo public static function baz return огонь new foo выведет вода new bar выведет огонь пример виртуальной функции delphi полиморфизм языка object pascal использующемся delphi рассмотрим пример объявим два класса предка ancestor tancestor class private protected public виртуальная процедура procedure virtual procedure staticprocedure end его потомка descendant tdescendant class tancestor private protected public перекрытие виртуальной процедуры procedure override procedure staticprocedure end как видно классе предке объявлена виртуальная функция чтобы воспользоваться достоинствами полиморфизма её нужно перекрыть потомке реализация выглядит следующим образом tancestor procedure tancestor staticprocedure begin showmessage ancestor static procedure end procedure tancestor begin showmessage ancestor virtual procedure end tdescendant procedure tdescendant staticprocedure begin showmessage descendant static procedure end procedure tdescendant begin showmessage descendant override procedure end посмотрим как это работает procedure tform bitbtn click sender tobject var myobject tancestor myobject tancestor begin myobject tancestor create myobject tdescendant create try myobject staticprocedure myobject myobject staticprocedure myobject finally myobject free myobject free end end заметьте что разделе var мы объявили два объекта myobject myobject типа tancestor при создании myobject создали как tancestor myobject как tdescendant вот что мы увидим при нажатии на кнопку bitbtn ancestor static procedure ancestor virtual procedure ancestor static procedure descendant override procedure для myobject все понятно просто вызвались указанные процедуры вот для myobject это не так вызов myobject staticprocedure привел появлению ancestor static procedure ведь мы объявили myobject tancestor поэтому была вызвана процедура staticprocedure класса tancestor вот вызов myobject привел вызову реализованной потомке tdescendant это произошло потому что myobject был создан не как tancestor как tdescendant myobject tdescendant create виртуальный метод был перекрыт delphi полиморфизм реализован помощью так называемой виртуальной таблицы методов или vmt достаточно часто виртуальные методы забывают перекрыть помощью ключевого слова override это приводит закрытию метода этом случае замещения методов vmt не произойдет требуемая не будет получена эта ошибка отслеживается компилятором который выдаёт соответствующее предупреждение пример виртуального метода на пример виртуального метода на примере используется ключевое слово base предоставляющее доступ методу родительского базового класса class program static void main string args myobj new console readkey базовый класс public class public virtual string return огонь произвольный класс наследующий класс class public override string return вода public выводим результат возвращаемый методом console out writeline вода выводим результат возвращаемый методом родительского класса console out writeline base огонь вызов метода предка из перекрытого метода бывает необходимо вызвать метод предка перекрытом методе объявим два класса предка ancestor tancestor class private protected public виртуальная процедура procedure virtual end его потомка descendant tdescendant class tancestor private protected public перекрытие виртуальной процедуры procedure override end обращение методу предка реализуется помощью ключевого слова inherited procedure tdescendant begin inherited end стоит помнить что delphi деструктор должен быть обязательно перекрытым override содержать вызов деструктора предка tdescendant class tancestor private protected public destructor destroy override end destructor tdescendant destroy begin inherited end языке не нужно вызывать конструктор деструктор предка деструктор должен быть виртуальным деструкторы предков вызовутся автоматически чтобы вызвать метод предка нужно явно вызвать метод class ancestor public virtual void function printf ancestor function class descendant public ancestor public virtual void function printf descendant function ancestor function здесь будет напечатано ancestor function для вызова конструктора предка нужно указать конструктор class descendant public ancestor public descendant ancestor ещё примеры первый пример class ancestor public virtual void function cout function pointer function pointer_copy function pointer_copy function этом примере класс ancestor определяет две функции одну из них виртуальную другую нет класс descendant переопределяет обе функции однако казалось бы одинаковое обращение функциям даёт разные результаты на выводе программа даст следующее descendant function descendant function descendant function ancestor function то есть для определения реализации виртуальной функции используется информация типе объекта вызывается правильная реализация независимо от типа указателя при вызове невиртуальной функции компилятор руководствуется типом указателя или ссылки поэтому вызываются две разные реализации function несмотря на то что используется один тот же объект следует отметить что можно при необходимости указать конкретную реализацию виртуальной функции фактически вызывая её невиртуально pointer ancestor function для нашего примера выведет ancestor function игнорируя тип объекта второй пример class public virtual int function return int get return this function class public public int function return include int main std cout несмотря на то что классе отсутствует метод get его можно позаимствовать класса при этом результат работы этого метода вернет вычисления для function третий пример include using namespace std struct ibase virtual void foo int const virtual ibase void ibase foo int const cout данном примере показан пример создания интерфейса ibase на примере интерфейса показана возможность создания абстрактного класса не имеющего виртуальных методов при объявлении деструктора чистым виртуальным вынесении его определения за тело класса пропадает возможность создавать объекты такого класса но остаётся возможность создавать потомки данного предка вывод программы будет следующим foo nbase destructor как мы видим значение аргумента по умолчанию взялось от типа ссылки не от реального типа объекта также как деструктор ключевое слово final показывает что класс или метод нельзя переопределять override что виртуальный метод явно переопределён см также объектно ориентированное полиморфизм информатика абстрактный класс примечания ссылки faq lite виртуальные функции лекция виртуальные функции полиморфизм конспекты курса по санкт петербургское отделение математического института им стеклова ран категория метод информатика категория статьи примерами кода