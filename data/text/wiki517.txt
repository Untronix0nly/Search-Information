delphi де лфи произносится императивный объектно ориентированный язык со строгой статической типизацией переменных основная область использования написание прикладного программного обеспечения этот язык ранее носил название object pascal изначально это название относилось несколько другому языку который был разработан фирме apple году группой ларри теслера однако настоящее время термин object pascal чаще всего употребляется для обозначении языка среды delphi начиная delphi официальных документах компания borland имя delphi стало использовать название для обозначения языка ранее известного как object pascal целевая платформа изначально среда разработки delphi была предназначена исключительно для разработки приложений microsoft windows затем был реализован вариант для платформ linux под торговой маркой kylix однако после выпуска году kylix его разработка была прекращена вскоре было объявлено поддержке microsoft net которая свою очередь была прекращена выходом delphi настоящее время наряду поддержкой разработки разрядных программ для windows реализована возможность создавать приложения для apple mac os начиная embarcadero delphi xe ios включая симулятор начиная xe посредством собственного компилятора google android начиная delphi xe также linux server начиная версии tokyo независимая сторонняя реализация среды разработки проектом lazarus free pascal случае компиляции режиме совместимости delphi позволяет использовать его для создания приложений на delphi для таких платформ как linux mac os windows ce также предпринимались попытки использования языка проектах gnu например notepad gnu написания компилятора для gcc gnu pascal философия отличия от популярных прикладных языков при создании языка здесь качественное отличие от языка не ставилась задача обеспечить максимальную исполняемого кода или лаконичность исходного кода для экономии оперативной памяти изначально язык ставил во главу угла стройность высокую читаемость поскольку был предназначен для обучения дисциплине эта изначальная стройность дальнейшем как по мере роста аппаратных мощностей так результате появления новых парадигм упростила расширение языка новыми конструкциями так сложность объектного по сравнению выросла весьма существенно затруднила его изучение качестве первого языка чего нельзя сказать об object pascal относительно pascal ниже перечислены некоторые отличия синтаксических конструкций delphi от семейства подобных языков java delphi формальное начало любой программы четко отличается от других участков кода должно располагаться определённом единственном рамках проекта исходном файле расширением dpr тогда как другие файлы исходных текстов программы имеют расширение pas program project apptype console res uses system sysutils begin try todo ouser cconsole main insert code here except on exception do writeln classname message end end подобных языках качестве входа обычно используется глобальная функция или статический метод именем main определённым списком параметров причём такая функция может быть расположена любом из файлов исходного текста проекта delphi идентификаторы типов переменных равно ключевые слова читаются независимо от регистра например идентификатор somevar полностью эквивалентен somevar регистро зависимые идентификаторы начале компьютерной эпохи ускоряли процесс компиляции кроме того позволяли использовать очень короткие имена порой отличающиеся лишь регистром хотя настоящему времени обе эти практики использование нескольких идентификаторов различающихся лишь регистром равно как чрезмерная их лаконичность осуждены не рекомендованы применению практически все унаследованные от языки java являются регистро зависимыми что одной стороны требует достаточно большой внимательности объявлению использованию идентификаторов другой принуждает писать более строгий код когда каждая переменная имеет чётко определённое имя вариации регистра могут вызвать путаницу ошибки delphi исходных файла pas которые как правило содержат основное тело программы на уровне языковых средств введено строгое разделение на интерфейсный раздел раздел реализации интерфейсной части содержатся лишь объявления типов методов тогда как код реализации интерфейсной части не допускается на уровне компиляции подобное разделение свойственно также языкам где рамках культуры парадигмы вводится разделение на заголовочные собственно файлы реализации но подобное разделение не обеспечивается на уровне языка или компилятора java такое разделение утрачено вовсе реализация метода как правило следует сразу же после его объявления инкапсуляция обеспечивается лишь принадлежностью метода той или иной области видимости для просмотра одной только интерфейсной части модуля исходного кода используются специальные средства delphi метод или функция четко определяются для этого ключевыми словами procedure или function тогда как подобных языках различие обуславливается ключевым словом определяющим тип возвращаемого значения delphi procedure dosomething aparam integer не возвращает значения function calculate aparam aparam integer integer возвращает целочисленный результат void dosomething int aparam не возвращает значения code int calculate int aparam aparam возвращает целочисленный результат code тем сложнее выглядят такие конструкции как объявление типа указатель на метод объявление типа pcalc указателя на функцию член принимающую два целочисленных параметра возвращающую целочисленный результат typedef int tsomeclass pcalc int int вышеуказанном примере объявление типа отличается от объявления переменной ключевым словом typedef имя типа pcalc указывается середине выражения скобках объявление типа pcalc указателя на функцию член принимающую два целочисленных параметра возвращающую целочисленный результат public delegate int pcalc int aparam int aparam вышеуказанном примере объявление типа отличается от объявления переменной специальным ключевым словом delegate имя типа указывается середине выражения delphi type pcalc function aparam aparam integer integer of object вышеуказанном примере объявление типа отличается от объявления переменной специальным ключевым словом type применением знака равенства случае переменной используется двоеточие имя типа идёт сразу после ключевого слова delphi начало конец программного блока выделяются ключевыми словами begin end тогда как подобных языках для этих целей используются фигурные скобки таким образом возможно delphi достигается лучшая читаемость кода для лиц ослабленным зрением другой стороны фигурные скобки могут быть более интуитивными при визуальном восприятии выполняя функцию пиктограммы if bval код состоящий из нескольких инструкций if bval код состоящий из одной инструкции вышеуказанном примере фигурные скобки обозначают составную инструкцию то есть блок инструкций поскольку команде ветвления для одной инструкции допускается выражение без фигурных скобок то для условного выражения круглые скобки обязательны сложных условных выражениях количество вложенных скобочных конструкций может быть велико delphi if bval then begin код состоящий из нескольких инструкций end if bval then код состоящий из одной инструкции delphi условное выражение всегда отделяется от следующей инструкции ключевым словом then что избавляет от необходимости заключать условие круглые скобки подобных языках целях подобного отделения условное выражение цикла заключается круглые скобки while condition цикл предусловием тело цикла do тело другого цикла while condition конец цикла постусловием тело выполняется хотя бы однажды delphi циклы предусловием постусловием отличаются сильнее конец цикла постусловием труднее принять за начало цикла предусловием но порой такое отличие может вызвать путаницу необходимо помнить что цикле until указывается условие выхода while condition do begin условием продолжения цикла является истинность выражения следующего за словом while как тело цикла end repeat начало цикла постусловием тело цикла until not condition истинность выражения следующего за словом until это условие выхода из цикла отличие от delphi операция присвоения значения переменной обозначается при помощи двоеточия со знаком равенства что является заимствованием из математической нотации знак равенства без двоеточия это оператор проверки равенства возвращающий булево значение напротив подобных языках оператором присваивания является одинарный знак равенства оператором проверки равенства двойной силу того что этих языках присваивание является лишь выражением возвращающим значение переменной слева не так уж редки следующие неочевидные для новичка ошибки int ival while ival по замыслу программиста данное тело цикла не должно выполнятся если на входе ival имеет значение отличное от единицы однако результате ошибочной замены знака на одиночный ival будет присвоено значение цикл окажется бесконечным delphi подобная ошибка невозможна хотя бы уже потому что присваивание этом языке операция не возвращающая значения delphi объектное объектно ориентированное хоть поощряется однако не является единственно возможным так допустимо отличие от объявление использование глобальных или статических функций переменных язык принудительно объектен глобальные без привязки классу функции запрещены value типы наподобие структур struct унаследованы от общего типа несмотря на то что сами по себе они не могут быть унаследованы то есть наследование структур запрещено вместе тем экземпляры классов являются неявно ссылочными типами как delphi поскольку системные вызовы windows как впрочем posix системах наподобие linux mac os формально необъектны взаимодействие кода ними затруднено даже без учёта разной парадигмы управления временем жизни переменных памяти delphi не имеет подобных ограничений несмотря на такую акцентированную на объектность парадигму отсутствует понятие виртуального конструктора то есть создания экземпляра класса точный тип которого на этапе компиляции неизвестен известен лишь базовый класс этого экземпляра отчасти этот недостаток может быть скомпенсирован посредством интерфейсов или reflection однако подобные решения не являются стандартными для языка type tanimal class abstract protected fpersonalname string public constructor create const personalname string virtual abstract function getspeciename string virtual abstract возвращает биологический вид животного property name string read fpersonalname end tanimalclass class of tanimal метакласс могущий ссылаться на любой класс унаследованный от tanimal function createananimal const factanimalclass tanimalclass const name string tanimal begin result factanimalclass create name функция не знает животное какого именно вида будет создано хотя кличка известна конкретная реализация вида скрыта end кроме того отличие от где вызов конструктора базового класса непременно осуществляется ещё до входа тело конструктора унаследованного класса delphi этот вызов делается явно таким образом его можно отложить или вовсе опустить специальных целях очевидно отличие от возможен контроль над исключениями базовых конструкторах для наиболее гибкой эффективной реализации объектно подхода delphi введены два механизма полиморфного вызова классический виртуальный также динамический если случае классического виртуального вызова адреса всех виртуальных функций будут содержаться таблице виртуальных методов каждого класса то случае динамическим вызовом указатель на метод существует лишь таблице того класса котором он был задан или перекрыт таким образом для динамического вызова из класса метода класса потребуется выполнить поиск таблицах методов классов подобная оптимизация имеет своей целью уменьшение размера статической памяти занимаемой под таблицы методов экономия может быть существенна для длинных иерархий классов очень большим количеством виртуальных методов подобных языках динамические полиморфные вызовы не применяются отличие от язык delphi допускает создание инстанциацию экземпляра абстрактного класса то есть класса содержащего абстрактные чисто виртуальные методы при помощи специальных техник код базового абстрактного класса может определить на этапе выполнения перекрыт ли фактическом классе экземпляра конкретный абстрактный метод зависимости от этого варьировать своё поведение более полно реализуя парадигму полиморфизма также delphi допускает перекрытие любого конкретного виртуального метода базового класса абстрактным классе потомке type tmybase class tobject function integer virtual метод имеет реализованное тело разделе implementation end tmyderived class tmybase function integer override abstract метод перекрыт как абстрактный тела не имеет при этом перекрывает скрывает реализованный базовом классе end procedure test var tmybase begin tmyderived create мы создали класс абстрактным методом вызов полиморфный мы получаем исключение типа eabstracterror пытаясь выполнить абстрактный метод end отличие от язык обладает унаследованной от delphi концепцией свойств класса псевдополей которые ряде случаев могут более интуитивно по сравнению методами отражать также изменять состояние объекта public class date данный пример взят msdn private int month backing store public int month get return month set if value value аналогичный исходный текст на языке delphi может выглядеть следующим образом type tdate class private fmonth integer protected procedure setmonth const value integer реализация разделе implementation public property month integer read fmonth write setmonth end прежде чем перейти сравнению языковой реализации свойств заметим что сопоставление этих двух примеров наглядно показывает что язык провоцирует во первых злоупотребление фигурными скобками что не так страшно виду краткости их написания во вторых нагромождение обязательных спецификаторов доступа каждому члену класса delphi как однажды объявленный спецификатор применяется ко всем последующим членам также если delphi возможна привязка свойства значению поля то они всегда снабжаются методами доступа использованием скобок составной команды кроме автоматических свойств методы эти отличие от delphi не могут быть объявлены виртуальными равно как не могут быть вызваны непосредственно метод доступа всегда относится одному только одному свойству тогда как для delphi это утверждение вообще говоря неверно более того один тот же метод может быть использован для реализации доступа существенно различным свойствам type trectangle class private fcoordinates array of longint function getcoordinate index integer longint procedure setcoordinate index integer value longint public property left longint index read getcoordinate write setcoordinate property top longint index read getcoordinate write setcoordinate property right longint index read getcoordinate write setcoordinate property bottom longint index read getcoordinate write setcoordinate property integer longint read getcoordinate write setcoordinate end как delphi так допускают использование индексируемых свойств этом случае синтаксис доступа такому свойству аналогичен доступу элементу массива однако если delphi число индексируемых свойств равно как число индексаторов может быть произвольным индексатор применим лишь специальному свойству по умолчанию кроме того delphi свойство по умолчанию не только может быть индексируемым также оно может быть перегружено по типу индексатора tmyobject class protected function getstr name string string virtual function getstrbyix index integer string virtual function getby indicies integer string virtual public property valuename string string read getstr default property valueindex integer string read getstrbyix default property valuex integer string read getby indicies default количество end языки java были изначально спроектированы для создания программ работающих управляемой среде где управлением временем жизни объектов занимается эта среда так что ручное управление памятью не допускается удобство безопасность этого подхода негативно влияют на платформы net java значительно упростили разработку программ за счёт введения сборщика мусора который разрешает программисту не заботиться высвобождении памяти занимаемой объектами которые вышли из области видимости работающего кода программы это одной стороны значительно уменьшило проблему так называемых утечек памяти когда уже ненужные недостижимые по причине утраты адреса данные занимают оперативную память но другой стороны потребовало от платформы реализовать сложный ресурсоёмкий алгоритм сборки мусора который традиционно реализован как нахождение достижимых объектов высвобождение остальных на практике чтобы выполнить исчерпывающий анализ достижимости объектов сборщик мусора некоторые моменты времени работу программы всех её потоков что приводит кратковременной потере отзывчивости частота длительность таких остановок напрямую зависит от объёма доступной оперативной памяти пока есть свободная память сборщик мусора старается не проводить блокирующий анализ также от числа задействованных программе объектов таким образом лучше иметь несколько больших объектов чем много маленьких ситуация ухудшается по мере роста количества задействованных программе потоков ведь исчерпывающий анализ достижимости требует полного останова таким образом явная выгода решение проблемы утечек памяти целом автоматическое управление временем жизни объектов породила неявную проблему масштабирования провалов эта проблема малозаметна простых программах но по мере роста сложности объёма кодовой базы становится всё более острой то есть на финальном этапе разработки сложные программные комплексы как правило имеют привязку реальному времени так требования отзывчивости попытки снизить издержки сборки мусора могут привести существенному искажению стиля delphi не существует автоматического управления памятью классических компиляторах языка экземпляры классов создаются удаляются вручную тогда как для некоторых типов интерфейсов строк динамических массивов задействован механизм подсчёта ссылок ни один из этих подходов вообще говоря не гарантирует отсутствия утечек памяти но другой стороны проблема отзывчивости не актуальна временные издержки управления памяти малы что важнее очевидны также при отсутствии утечек общий объём задействованной оперативной памяти существенно меньше чем аналогичных приложений полагающихся на сборщик мусора история языка object pascal результат развития языка турбо паскаль который свою очередь развился из языка паскаль паскаль был полностью процедурным языком турбо паскаль начиная версии добавил паскаль объектно ориентированные свойства object pascal динамическую идентификацию типа данных возможностью доступа метаданным классов то есть описанию классов их членов компилируемом коде также называемую интроспекцией данная технология получила обозначение rtti так как все классы наследуют функции базового класса tobject то любой указатель на объект можно преобразовать нему после чего воспользоваться методом classtype функцией typeinfo которые обеспечат интроспекцию также отличительным свойством object pascal от является то что объекты по умолчанию располагаются динамической памяти однако можно переопределить виртуальные методы newinstance freeinstance класса tobject таким образом абсолютно любой класс может осуществить желание где хочу там буду лежать соответственно организуется многокучность object pascal delphi является результатом функционального расширения turbo pascal delphi оказал огромное влияние на создание концепции языка для платформы net многие его элементы концептуальные решения вошли состав одной из причин называют переход андерса хейлсберга одного из ведущих разработчиков дельфи из компании borland ltd microsoft corp версия способна генерировать байт код исключительно для платформы net это первая среда ориентированная на разработку мультиязычных приложений лишь для платформы net последующие версии обозначаемые годами выхода не порядковыми номерами как это было ранее могут создавать как приложения win так байт код для платформы net delphi for net среда разработки delphi также язык delphi object pascal ориентированные на разработку приложений для net первая версия полноценной среды разработки delphi для net delphi она позволяла писать приложения только для net delphi поддерживает технологию mda помощью eco enterprise core objects версии марте года компания borland приняла решение прекращении дальнейшего интегрированных сред разработки jbuilder delphi builder по причине убыточности этого направления планировалась продажа ide сектора компании группа сторонников свободного программного обеспечения организовала сбор средств для покупки borland прав на среду разработки компилятор однако ноябре того же года было принято решение отказаться от продажи ide бизнеса тем не менее разработкой ide продуктов теперь будет заниматься новая компания codegear которая будет финансово полностью подконтрольна borland августе года borland выпустил облегченную версию rad studio под именем turbo turbo delphi для win net turbo turbo марте года было объявлено прекращении развития этой линейки продуктов марте года codegear порадовала пользователей обновлённой линейкой продуктов delphi for win выходом совершенно нового продукта delphi for php июне года codegear представила свои планы на будущее то есть опубликовала так называемый roadmap embarcadero rad studio августа года компания embarcadero новый хозяин codegear опубликовала пресс релиз на delphi for win версия привнесла множество нововведений язык как то по умолчанию полная поддержка юникода во всех частях языка vcl rtl замена обращений ко всем функциям windows api на юникодные аналоги то есть messagebox вызывает messageboxw не messageboxa обобщённые типы они же generics анонимные методы новая директива компилятора pointermath off функция exit теперь может принимать параметры соответствии типом функции вышедшая году версия delphi xe добавила компилятор win кросс компиляцию для операционных систем фирмы apple macos ios вышедшая году версия delphi xe обеспечила кросс компиляцию приложений для устройств на платформе arm android компиляторы embarcadero delphi ранее наз codegear delphi borland delphi вероятно наиболее известный компилятор который является последователем borland pascal turbo pascal используется win delphi win delphi позже win delphi xe позже также net delphi delphi delphi поддержка net впоследствии выделена отдельный продукт известный как несовместимый delphi oxygene free pascal fpc свободный компилятор оbject pascal который поддерживает различные диалекты паскаля включая turbo pascal некоторыми оговорками delphi собственные диалекты на текущий момент fpc может генерировать код для powerpc sparc процессоров arm также для различных операционных систем том числе для microsoft windows linux freebsd mac os существует несколько сред разработки программного обеспечения для fpc один из самых известных представителей lazarus gnu pascal отдельно разработанная версия из gcc не ставит целью продолжение серии диалектов delphi как составляющей паскаля но тем не менее содержит режим совместимости borland pascal очень медленно приспосабливает компоненты языка delphi не подходит для компиляции больших проектов содержащих код delphi но стоит отметить что его поддерживают большинство операционных систем архитектур oxygene ранее известен как chrome компилятор ограниченно совместимого delphi языка который интегрирован microsoft visual studio также доступный виде компилятора вольной командной строкой cli использует net моно платформы прежде продавался под маркой embarcadero delphi prism midletpascal язык delphi подобным синтаксисом одноимённый компилятор который преобразует исходный код компактный быстрый байт код java pocketstudio основанная на паскале ide для palm os virtual pascal бесплатный компилятор текстовая ide для win os linux на тот момент очень быстрый весьма совместимый частично поддерживаются конструкции delphi внешне очень похож на текстовую среду borland pascal хотя отсутствует совместимая ним графика например однако разработка окончилась году исходники открыты не были тех пор fpc ушёл намного вперед целом для лучше он тем не менее vp остаётся очень неплохим вариантом быстрой замены ещё более устаревших версий borland pascal для школы института учитывая родную работу win без проблем русскими кодировками синтаксис языка система типов система типов delphi строгая статическая поддерживаются следующие типы данных целочисленные знаковые беззнаковые byte shortint word smallint cardinal integer uint int типы перечисления задаваемые пользователем вещественные типы single double extended только унаследованный тип real работающий режиме целочисленной эмуляции тип currency вещественное фиксированной точности строки тип string автоматический распределяемый памяти подсчётом ссылок парадигмой copy on write поздних версиях delphi символы двухбайтные unicode совместимые ansistring аналогичная реализация для строк шириной символа один байт такие строки содержат служебном поле информацию кодировке windows компиляторах ранних версий существует тип widestring полностью совместимый типу bstr component object model также допускается использование строк фиксированной длиной не превышающей однобайтных символов допускается использование примитивных строковых типов стиле языка pchar pwidechar массивы одномерные многомерные фиксированной длины также подобные им динамические подсчётом ссылок множества состоящие из элементов типа перечисления максимальный размер такого перечисления элементов записи структурный value тип без поддержки наследования начиная delphi добавлена поддержка инкапсуляции методов свойств перегрузка операторов классы обобщённые классы generics неявно ссылочный тип поддержка инкапсуляции наследования полиморфизма том числе виртуальных конструкторов атрибутов обобщённых параметров для класса отдельных методов также диспетчеризации методов по индексу класс может реализовать один или несколько интерфейсов том числе опосредованно делегируя реализацию интерфейса свойству или полю множественное наследование не поддерживается указатели на функции методы также указатели на анонимные функции типы метаклассы содержащие указатель на тип объекта но не сам объект основном введены для реализации виртуальных конструкторов автоматической сериализации интерфейсы com совместимые windows компиляторе унаследованные от одного предка множественное наследование не поддерживается диспинтерфейсы для работы интерфейсами idispatch режиме позднего связывания variant olevariant тип динамической типизацией старые объекты поддерживаемые для совместимости turbo pascal отличие от экземпляра класса объект может быть размещен стеке или статически операторы список операторов через пробел div mod not and or with xor shl shr in is as арифметические div mod сложение вычитание умножение деление дающее вещественный результат целочисленное деление выделение остатка по типу возвращаемого значения различаются операторы целочисленного деления div mod оператор последний применяемый как целочисленным так вещественным операндам всегда результате дает вещественный тип оператор сложения используется также для конкатенации строк когда используются встроенные строковые типы бинарные логические not and or xor инверсия отрицание или исключающее или тип операции бинарная или логическая зависит от типа первого операнда битовым операторам целочисленных типов относятся также shl shr операторы сдвига соответствующие по смыслу одноименным командам процессоров intel порядковые операторы операторы сравнения равенства неравенства соответствует оператору подобных языках больше меньше не меньше не больше применяются ко всем порядковым вещественным типам возвращают значение типа boolean операторам множества относятся in сложение вычитание пересечение множеств также оператор теста вхождения которые используются для манипуляций со встроенным типом множества первые три возвращают тип множества последний булевый тип type tdayofweek monday tuesday wednesday thursday friday saturday sunday задается тип перечислений tdays set of tdayofweek задается тип множества var day tdayofweek days tdays ismyday boolean begin days sunday tuesday saturday day monday ismyday day in days оператор in возвращает булевое значение принимая первым операндом значение типа элемент множества вторым значение типа множество end операторы приведения типов as is безусловное приведение безопасное приведение объектных интерфейсных типов также оператор теста принадлежности типу возвращает булевое значение безусловное небезопасное приведение используется функциональном стиле слева пишется идентификатор типа справа скобках приводимое нему выражение применяется порядковым вещественным структурным ссылочным строковым типам типам при этом для ссылочных включая неявно ссылочные типов не происходит действительного приведения лишь новая интерпретация тех же данных операторы as is применяются типам допускающим полиморфное поведение экземплярам класса интерфейсам первый приводит безопасное смысле невозможности неверной интерпретации приведение типа второй тестирует поддержку экземпляром класса или интерфейсом некоторого класса или интерфейса нужно помнить что отличие от языка неудавшееся приведение типа оператором as возбуждает исключение ссылочные операторы используются для работы указателями оператор разыменовывает указатель оператор выполняет обратное действие возвращая адрес переменной поддерживается простые операции сложения вычитания над типизированными указателями учётом размера типов на которые они указывают умная арифметика указателей оператор присваивания delphi оператор присваивания образует не выражение операцию таким образом не допускается нанизывание присваиваний классы языке object pascal классы это специальные типы данных используемые для описания объектов соответственно объект имеющий тип какого либо класса является экземпляром instance этого класса или переменной этого типа класс представляет собой особый тип имеющий своём составе такие элементы как поля свойства методы поля класса аналогичны полям записи служат для хранения информации об объекте методами называются процедуры функции предназначенные как правило для обработки полей свойства занимают промежуточное положение между полями методами объектно ориентированные особенности языка инкапсуляция объединение скрытие объектных данных также обрабатывающих их методов внутри конкретного класса от пользователя называется инкапсуляцией наследование при создании новых объектов способность получить все свойства методы от своих предков называют наследованием такие объекты наследуют после своего создания все поля свойства события методы прочее от своих предков наследование часто избавляет разработчиков от рутинной работы позволяет не мешкая приступить разработке чего то нового полиморфизм delphi реализует классическую модель полиморфизма принятую прикладных языках когда методы базового класса также ссылочные переменные типа базового класса способны манипулировать экземплярами классов потомков на основе контракта заданного базовом классе контрактом этом случае выступает объявление абстрактных методов базовом классе примеры структура программы каждая написанная программа на языке delphi состоит из заголовка программы program newapplication поля используемых модулей uses примеру uses windows messages sysutils который может не входить саму структуру также блоков описания исполнения начинаются составным оператором begin заканчиваются end program project заголовок программы её именем project uses forms unit in unit pas form модули которые подключены проекту используются программой res begin application initialize инициализация приложения application createform tform form создание формы окна application run запуск исполнение end пример вывод сообщения hello world консольном приложении delphi program helloworld название программы apptype console директива компилятору создании консольного приложения begin writeln hello world вывод сообщения hello world readln ожидание нажатия клавиши пользователем end конец программы пример вывод сообщения hello world разрядном gui приложении delphi procedure tform button click sender tobject обработчик события onclick генерируемый автоматически begin showmessage hello world вывод сообщения hello world end конец процедуры пример динамическое создание списка строк запись его файл обработчик события происходящего при создании формы mainform procedure tmainform formcreate sender tobject var объявление переменной типа tstrings список строк strings tstrings begin создание выделение памяти заполнение её начальными значениями объекта типа tstringlist tstringlist это потомок tstrings реализующий его абстрактные методы целью хранения строк памяти strings tstringlist create try добавление строки strings add добавляемая строка сохранение всех строк файл strings savetofile strings txt finally освобождение памяти объекта очистка ссылки на неё для предотвращения обращения не выделенной памяти freeandnil strings end end расширения файлов pas исходный код модуля pascal dpr исходный код проекта pascal dproj исходный код проекта xml dproj local исходный код проекта xml dfm исходный код формы dpk исходный код проекта пакета bpl пакет dcu модуль exe приложение res ресурсы dsk привязки файлам identcache кэшированные привязки файлам известное программное обеспечение созданное на delphi среди многих программных продуктов написанных на delphi можно найти продукция embarcadero embarcadero delphi embarcadero builder borland jbuilder версии разработка баз данных mysql tools ibexpert open server инженерное программное обеспечение altium designer sprutcam файловые менеджеры total commander frigate viewfd freecommander просмотрщики графики faststone image viewer futuriximager drcomread редакторы графики icofx видео light alloy the kmplayer aimp amp nata player программы мгновенного обмена сообщениями qip the bat poptray feeddemon mychat skype до покупки microsoft клиенты файлообменных сетей shareman ares galaxy создание музыки fl studio guitar pro до версии разработка программного обеспечения dev dunit game maker inno setup pyscripter веб разработка macromedia homesite phpedit текстовые редакторы biredit notepad gnu bred до версии bred pspad учёт налогообложение меркурий erp бюджет парус avarda до версии включительно r_keeper система электронной очереди максима программы хранения обработки медицинских изображений makhaon worsktation makhaon storage программы для создания анимаций pivot stickfigure animator программы для сжатия данных alzip powerarchiver izarc нахождение уничтожение шпионского по вредоносных программ spybot search destroy компьютерные игры age of wonders космические рейнджеры космические рейнджеры hd революция venom codename outbreak space empires правда девятой роте лаунчер портативных программ portableapps дефрагментация диска smartdefrag различные системные утилиты treesize критика критика языка на ранних этапах развития история критики pascal восходит году работе брайана кернигана аргументы которой основном устарели по мере развития языка некоторые фундаментальные особенности языка тем не менее последовательно подвергались критике том числе невозможность объявить переменную или тип внутри тела функции int fnmyfunction int if хотя пример выше искусственен он иллюстрирует парадигму локальных переменных равно как унаследованных от него java где возможно объявление рамках блока причем такое объявление допустимо совместить инициализацией значением более поздних версиях возможно также выведение типа такой переменной из выражения инициализатора static int c_add объявление статической переменной void typedef vector myvector тип шаблон std vector из еще один вид локального определения определение типа конкретизация шаблона myvector vct объявление инициализация вектора auto eit vct end вывод типа переменной eit vector iterator из выражения vct end for auto it vct begin it eit it тип переменной it выводится из vct end переменная it локальна для блока for int add c_add объявление инициализация переменной add внимание значение выражения инициализации вычисляется на каждой итерациии цикла cout ниже приводится пример для альтернативной реализации языка delphi учебной среде pascalabc net данный пример не компилируется стандартной embarcadero реализации языка procedure begin var myvector array of integer объявление инициализация массива foreach it integer in myvector do begin блок итерации контейнера foreach переменная it определена лишь внутри этого блока inc c_add var add c_add объявление вывод типа integer инициализация значением переменной add write it add end мы получаем end delphi объявление локальной переменной всегда предшествует первой инструкции кода функции причем инициализация локальных стековых переменных месте объявления не допускается очевидно невозможен также вывод типа нововведения для компиляции на мобильные платформы некоторые изменения языка осуществленные компанией embarcadero разработчиком языка так называемых nextgen компиляторах языка delphi намеренно нарушили совместимость накопленной базой исходного кода эти изменения были негативно восприняты широким кругом опытных delphi разработчиков поскольку хотя приближали язык парадигме языков net но сломали традицию высокой обратной совместимости существенно затруднили перенос имеющегося исходного кода программное обеспечение для мобильных платформ указанные ниже изменения поставили под сомнение самую парадигму разработки на базе единого исходного кода рекламируемую embarcadero введение индексации строк по нулевой базе со времен pascal исторически сложилось что встроенный строковый тип индексировался базой единицу нулевой элемент строки возвращал длину строки по мере введения новых длинных юникодных строковых типов данный порядок индексации сохранялся обеспечивая почти бесшовный перенос кодовой базы на обновленные версии языка однако введением nextgen компиляции парадигма изменилась новых компиляторах строки стали индексироваться по нулевой базе как семействе подобных языков java при этом классических компиляторах для windows mac os парадигма единичной индексации была сохранена введение механизма подсчета ссылок для экземпляров классов исторически классы их экземпляры являются неявно ссылочными структурными типами тем не менее управление временем жизни экземпляра класса изначально выполнялось вручную посредством явного вызова конструктора деструктора либо метода free такая особенность сохраняется по состоянию на год классических версиях компиляторов подсчёт ссылок работал лишь для классов реализующих интерфейсы притом том только случае когда манипуляции такими классами производились посредством переменных интерфейсного типа однако компиляторы для мобильных платформ ввели подсчёт ссылок для всех экземпляров классов тем самым корне изменив парадигму управлением временем жизни объектов поскольку ручное управление практически за исключением некоторых весьма продвинутых техник несовместимо новой парадигмой результате этого не только была сломана совместимость обширным багажом унаследованного кода но была затруднена разработка единого кода для для всех поддерживаемых платформ как уже было указано ранее для написания универсального для обеих парадигм исходного кода использованием классов требуется глубокое понимание особенностей реализации этих парадигм трудно представить нужду подобном переходе не говоря уже различной трактовке исходного кода зависимости от выбранной целевой платформы примечания литература ссылки домашняя страница среды delphi на сайте embarcadero technologies категория delphi