единичное тестирование или модульное тестирование процесс позволяющий проверить на корректность единицы исходного кода наборы из одного или более программных модулей вместе управляющими данными процедурами использования обработки идея состоит том чтобы писать тесты для каждой нетривиальной функции или метода это позволяет достаточно быстро проверить не привело ли очередное изменение кода регрессии то есть появлению ошибок уже оттестированных местах программы также облегчает обнаружение устранение таких ошибок преимущества цель модульного тестирования изолировать отдельные части программы показать что по отдельности эти части работоспособны этот тип тестирования обычно выполняется программистами поощрение изменений модульное тестирование позже позволяет программистам проводить рефакторинг будучи уверенными что модуль по прежнему работает корректно регрессионное тестирование это поощряет программистов изменениям кода поскольку достаточно легко проверить что код работает после изменений упрощение интеграции модульное тестирование помогает устранить сомнения по поводу отдельных модулей может быть использовано для подхода тестированию снизу вверх сначала тестируя отдельные части программы затем программу целом кода модульные тесты можно рассматривать как живой документ для тестируемого класса клиенты которые не знают как использовать данный класс могут использовать юнит тест качестве примера отделение интерфейса от реализации поскольку некоторые классы могут использовать другие классы тестирование отдельного класса часто на связанные ним например класс пользуется базой данных ходе написания теста программист обнаруживает что тесту приходится базой это ошибка поскольку тест не должен выходить за границу класса результате разработчик абстрагируется от соединения базой данных реализует этот интерфейс используя свой собственный mock объект это приводит менее связанному коду минимизируя зависимости системе когда модульное тестирование не работает сложный код тестирование программного обеспечения комбинаторная задача например каждое возможное значение булевской переменной потребует двух тестов один на вариант true другой на вариант false результате на каждую строку исходного кода потребуется строк тестового кода как любая технология тестирования модульное тестирование не позволяет отловить все ошибки программы самом деле это следует из практической невозможности трассировки всех возможных путей выполнения программы за исключением простейших случаев результат известен лишь приблизительно например математическом моделировании бизнес приложения зачастую работают конечными счётными множествами научные континуальными поэтому сложно подобрать тесты для каждой из ветвей программы сложно сказать верен ли результат выдерживается ли точность во многих случаях качество моделирования определяется на глаз последний результат записывается как опорный если найдено расхождение новый результат проверяют вручную выясняют какой качественнее старый или новый код системой код портами таймерами прочими нестабильными частями системы крайне сложно проверить изолированном окружении но это не значит что модульное тестирование здесь полностью непригодно оно вынуждает программиста перейти от файлов портов например на абстрактные потоки это делает код более общим например без проблем можно перейти файлов на сетевые сокеты более тестируемым можно даже проверить ситуацию пропала связь ограничивает те части которые не подлежат модульному тестированию ошибки интеграции при выполнении юнит тестов происходит тестирование каждого из модулей по отдельности это означает что ошибки интеграции системного уровня функций исполняемых нескольких модулях не будут определены кроме того данная технология бесполезна для проведения тестов на таким образом модульное тестирование более эффективно при использовании сочетании другими методиками тестирования при общей низкой культуре для получения выгоды от модульного тестирования требуется строго следовать технологии тестирования на всём протяжении процесса разработки программного обеспечения нужно хранить не только записи обо всех проведённых тестах но обо всех изменениях исходного кода во всех модулях этой целью следует использовать систему контроля версий по таким образом если более поздняя версия по не проходит тест который был успешно пройден ранее будет несложным сверить варианты исходного кода устранить ошибку также необходимо убедиться неизменном отслеживании анализе неудачных тестов игнорирование этого требования приведёт лавинообразному увеличению неудачных тестовых результатов проблемы объектами заглушками за исключением простейших случаев тестируемый объект должен другими объектами этих товарищей по взаимодействию объекты заглушки делают предельно простыми либо крайне упрощёнными память вместо бд либо рассчитанными на конкретный тест механически повторяющими сессию обмена вопросы начинаются когда протокол обмена меняется надо отыскивать эти заглушки во всех тестах переводить под новый протокол приложения модульного тестирования экстремальное экстремальное предполагает как один из постулатов использование инструментов автоматического модульного тестирования этот инструментарий может быть создан либо третьей стороной например boost test либо группой разработчиков данного приложения экстремальном используются модульные тесты для разработки через тестирование для этого разработчик до написания кода пишет тест отражающий требования модулю очевидно тест до написания кода работать не должен дальнейший процесс сводится написанию кратчайшего кода данному тесту после разработчик пишет следующий тест код так многократно техника модульного тестирования сложность написания модульных тестов зависит от самой организации кода сильное зацепление или большая зона ответственности отдельных сущностей классы для объектно ориентированных языков могут усложнить тестирование для объектов осуществляющих связь внешним миром сетевое взаимодействие файловый ввод вывод следует создавать заглушки терминологии выделяют более продвинутые заглушки mock объекты которые несут себе логику также упростить тестирование может выделение как можно большей части логики чистые функции они никак не взаимодействуют внешним миром их результат зависит только от входных параметров код тестов принято выделять отдельные каталоги желательно чтобы добавление новых тестов проекте не было сложной задачей была возможность запускать все тесты некоторые системы контроля версий например git поддерживают хуки помощью которых можно настроить запуск всех тестов перед фиксированием изменений при ошибке хотя бы одном из тестов изменения зафиксированы не будут также можно применять системы непрерывной интеграции инструментарий для большинства популярных языков высокого уровня существуют инструменты библиотеки модульного тестирования некоторые из них для actionscript язык сценариев используемый виртуальной машиной adobe flash player версии asunit as unit для actionscript скриптовый язык используемый виртуальной машиной adobe flash player версии выше flexunit asunit для cunit cunit ctesk unitesk ru cfix cfix api sanity autotest для динамических библиотек unix подобных ос unity unity для встраиваемых приложений micro unit micro_unit небольшой набор макросов примерами использования для ruby rspec test unit для objective ocunit для cxxtest cppunit boost test google testing framework symbian фреймворк для symbian os всех версий api sanity autotest для динамических библиотек unix подобных ос qt test framework для программ разработанных помощью библиотеки qt для nunit xunit net mbunit dunit для delphi eunit erlang для java groovy junit junit org testng testng org javatesk unitesk ru написан на groovy для javascript mocha тестовый фреймворк jest chai assertion library используется совместно тестовым framework ом sinon js библиотека для создания mock ов stub ов spy ев используется совместно тестовым framework ом karma runner от создателей angular js test runner организует среду выполнения тестов qunit от создателей jquery jsunit больше не поддерживается создателями jasmine рекомендован создателями jsunit для perl test test simple test more test unit test unit lite для php simpletest phpunit для python pyunit pytest nose vbunit visual basic utplsql pl sql для sql tsqlunit spunit поддержка на уровне языка некоторые языки имеют поддержку модульного тестирования на уровне синтаксиса это избавляет от необходимости выбирать какому фреймворку привязываться позволяет упростить перенос кода другие проекты пример таких языков cobra пример кода на языке class abc this val private int val public func val unittest abc func assert val val примечания см также тестирование программного обеспечения автоматическое тестирование ссылки сайты ресурсы тестирование программного обеспечения модульные тесты коллекция статей на сайте openquality ru the art of unit testing статьи модульное тестирование модульное тестирование зачем как кто the evolution of unit testing syntax and semantics unit testing guidelines from geosoft категория тестирование программного обеспечения категория модульное тестирование категория незавершённые статьи программном обеспечении