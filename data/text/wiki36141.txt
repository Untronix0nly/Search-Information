автома тное программи рование это парадигма при использовании которой программа или её фрагмент осмысливается как модель какого либо формального автомата известна также другая парадигма автоматного состоящая представлении сущностей со сложным поведением виде объектов управления каждый из которых представляет собой объект управления автомат при этом программе как автоматическом управлении предлагается думать как системе объектов управления зависимости от конкретной задачи автоматном могут использоваться как конечные автоматы так автоматы более сложным строением определяющими для автоматного являются следующие особенности временной период выполнения программы разбивается на шаги автомата каждый из которых представляет собой выполнение определённой одной той же для каждого шага секции кода единственной точкой входа такая секция может быть оформлена например виде отдельной функции может быть разделена на подсекции соответствующие отдельным состояниям или категориям состояний передача информации между шагами автомата осуществляется только через явно обозначенное множество переменных называемых состоянием автомата между шагами автомата программа или её часть оформленная автоматном стиле не может содержать неявных элементов состояния таких как значения локальных переменных стеке адреса возврата из функций значение текущего счётчика команд иначе говоря состояние программы на любые два момента входа шаг автомата могут различаться между собой только значениями переменных составляющих состояние автомата причём такие переменные должны быть явно обозначены качестве таковых полностью выполнение кода автоматном стиле представляет собой цикл возможно неявный шагов автомата название автоматное оправдывается ещё тем что стиль мышления восприятия процесса исполнения при этой технике практически точно воспроизводит стиль мышления при составлении формальных автоматов таких как машина тьюринга автомат маркова др пример использованием конечного автомата пусть примеру требуется написать на языке си программу читающую из потока стандартного ввода текст состоящий из строк для каждой строки печатающую первое слово этой строки перевод строки ясно что для этого во время чтения каждой строки следует сначала пропустить пробелы если таковые есть начале строки затем читать буквы составляющие слово печатать их пока слово не кончится то есть либо не кончится строка либо не будет встречен пробельный символ наконец когда первое слово успешно считано напечатано необходимо дочитать строку до конца ничего при этом не печатая встретив на любой фазе символ перевода строки следует напечатать перевод строки продолжить начала при возникновении опять таки на любой фазе ситуации конец файла следует прекратить работу императивная программа программа решающая эту задачу традиционном императивном стиле может выглядеть например так язык include int main int do getchar while getchar while eof putchar getchar putchar while eof getchar while eof return программа автоматном стиле ту же задачу можно решить применив мышление терминах конечных автоматов заметим что разбор строки разделяется на три фазы пропуск лидирующих пробелов печать слова пропуск символов остатка строки назовём эти три фазы состояниями before inside after программа теперь может выглядеть например так include int main enum states before inside after state int state before while getchar eof switch state case before if putchar else if putchar state inside break case inside switch case state after break case putchar state before break default putchar break case after if putchar state before return несмотря на то что код явно стал более длинным него имеется одно несомненное достоинство чтение то есть вызов функции getchar теперь выполняется ровно одном месте кроме того необходимо заметить что вместо четырёх циклов предыдущей версии цикл теперь используется только один тело цикла за исключением действий выполняемых заголовке представляет собой шаг автомата сам же цикл задаёт цикл работы автомата диаграмма конечного автомата программа реализует моделирует работу конечного автомата изображённого на рисунке буквой на диаграмме обозначен символ конца строки буквой символ пробела буквой все остальные символы за один шаг автомат делает ровно один переход зависимости от текущего состояния прочитанного символа некоторые переходы сопровождаются печатью прочитанного символа такие переходы на диаграмме обозначены звёздочками строго соблюдать разделение кода на обработчики отдельных состояний вообще говоря не обязательно более того некоторых случаях само понятие состояния может складываться из значений нескольких переменных так что учесть все возможные их комбинации окажется практически невозможно рассматриваемом примере можно сэкономить объём кода если заметить что действия выполняемые по символу конец строки от состояния не зависят программа эквивалентная предыдущей но написанная учётом такого замечания будет выглядеть так include int main enum states before inside after state int state before while getchar eof if putchar state before continue switch state case before if putchar state inside break case inside if state after else putchar case after break return выделение шага автомата отдельную функцию вышеприведённой программе является по прежнему чёткое выделение кода отвечающего за шаг автомата это обстоятельство можно подчеркнуть ещё сильнее если выделить шаг автомата отдельную функцию include enum states before inside after void step enum states state int if putchar state before switch state case before if putchar state inside break case inside if state after else putchar case after break int main int enum states state before while getchar eof step state return этот пример наглядно демонстрирует основное свойство благодаря которому код можно считать оформленным стиле автоматного отдельные шаги автомата выполняются временные периоды единственным средством передачи информации между шагами является явно определённое состояние данном случае переменная state программа явно заданной таблицей переходов конечный автомат как известно может быть задан таблицей переходов вообще говоря код программы моделирующей конечный автомат вполне может отражать это свойство автомата следующей программе массив the_table задаёт таблицу переходов строки таблицы соответствуют трём состояниям автомата столбцы читаемым символам первый столбец пробел второй столбец перевод строки третий столбец все остальные символы каждая ячейка таблицы содержит номер нового состояния признак необходимости печати символа приведённом коде используются битовые поля для экономии памяти конечно реальной задаче могла бы потребоваться гораздо более сложная структура таблицы содержащая например указатели на функции для выполнения каких либо действий связанных переходами но рассматриваемом примере это не нужно include enum states before inside after typedef struct branch enum states new_state int should_putchar branch branch the_table others before before before inside inside after before inside after after before after void step enum states state int int idx branch the_table stateidx state new_state if should_putchar putchar int main int enum states state before while getchar eof step state return использование объектно ориентированных возможностей если используемый язык поддерживает объектно ориентированные возможности логично будет инкапсулировать конечный автомат объект скрыв детали реализации например аналогичная программа на языке может выглядеть так include class statemachine enum states before inside after state struct branch enum states new_state unsigned should_putchar static struct branch the_table public statemachine state before void feedchar int int idx struct branch state new_state if should_putchar putchar struct statemachine branch statemachine the_table others before before before inside inside after before inside after after before after int main int statemachine machine while getchar eof machine feedchar return отметим что этом примере мы использовали для ввода вывода библиотеку языка си чтобы избежать появления лишних отвлекающих внимание изменений сравнении предыдущим примером сфера применения автоматное широко применяется при построении лексических анализаторов классические конечные автоматы синтаксических анализаторов автоматы магазинной памятью кроме того мышление терминах конечных автоматов то есть разбиение исполнения программы на шаги автомата передача информации от шага шагу через состояние необходимо при построении событийно ориентированных приложений этом случае стиле конечных автоматов оказывается единственной альтернативой порождению множества процессов или потоков управления тредов часто понятие состояний машин состояний используется для спецификации программ так при проектировании программного обеспечения помощью uml для описания поведения объектов используются диаграммы состояний state machine diagrams кроме того явное выделение состояний используется описании сетевых протоколов см например rfc мышление терминах автоматов шагов состояний находит применение при описании семантики некоторых языков так исполнение программы на языке рефал представляет собой изменений поля зрения рефал машины или иначе говоря шагов рефал автомата состоянием которого является содержимое поля зрения произвольное рефал выражение не содержащее переменных механизм продолжений языка scheme для своей реализации также требует мышления терминах состояний шагов несмотря на то что сам язык scheme никоим образом не является автоматным тем не менее чтобы обеспечить возможность замораживания продолжения приходится при реализации вычислительной модели языка scheme объединять все компоненты среды исполнения включая список действий которые осталось выполнить для окончания вычислений единое целое которое также обычно называется продолжением такое продолжение оказывается состоянием автомата процесс выполнения программы состоит из шагов каждый из которых выводит следующее значение продолжения из предыдущего александр оллонгрен своей книге описывает так называемый венский метод описания семантики языков основанный целиком на формальных автоматах качестве одного из примеров применения автоматной парадигмы можно назвать систему stat эта система частности включает встроенный язык statl имеющий чисто автоматную семантику существуют также предложения по использованию автоматного качестве универсального подхода созданию компьютерных программ вне зависимости от предметной области так авторы статьи утверждают что автоматное способно сыграть роль легендарной серебряной пули история наиболее ранние случаи применения парадигмы автоматного относятся по видимому предметным областям которых наработана алгоритмическая теория основанная на теории автоматов прежде всего анализу текстов на формальных языках качестве одной из наиболее ранних работ на эту тему можно назвать статью одним из первых упоминаний использования техники автоматного независимо от теоретических наработок основанных на конечных автоматах является статья питера наура этой статье автор называет применённый подход подходом машины тьюринга turing machine approach но реально никакая машина тьюринга статье не строится приведённый статье подход удовлетворяет определению автоматного сравнение императивным процедурным понятие состояния программы не является эксклюзивной особенностью автоматного вообще говоря состояние возникает при выполнении любой компьютерной программы представляет собой совокупность всей информации которая во время исполнения может изменяться так состояние программы выполненной традиционном императивном стиле состоит из совокупности значений всех глобальных переменных содержимого динамической памяти содержимого регистров общего назначения содержимого стека включая адреса возвратов значения локальных переменных текущего значения счётчика команд то есть текущей позиции коде программы составные части состояния можно разделить на явные такие как значения переменных неявные адреса возвратов значение счётчика команд контексте введённых определений программу оформленную виде модели конечного автомата можно считать частным случаем императивной программы таким котором роль неявной составляющей состояния сведена минимуму если рассмотреть автоматную программу моменты начала очередного шага автомата то состояния программы эти моменты будут различаться только явной составляющей это обстоятельство существенно упрощает анализ свойств программы связь объектно ориентированным теории объектно считается что объект имеет внутреннее состояние способен получать сообщения отвечать на них отправлять сообщения другим объектам процессе обработки сообщений изменять своё внутреннее состояние более приближенное практике понятие вызова метода объекта считается синонимом понятия отправки сообщения объекту таким образом одной стороны объекты объектно ориентированном могут рассматриваться как конечные автоматы или если угодно модели конечных автоматов состояние которых представляет собой совокупность внутренних полей качестве же шага автомата могут рассматриваться один или несколько методов объекта при условии что эти методы не вызывают ни сами себя ни друг друга ни прямо ни косвенно другой стороны очевидно что понятие объекта представляет собой удачный инструмент реализации модели конечного автомата при применении парадигмы автоматного объектно ориентированных языках обычно модели автоматов представляются виде классов состояние автомата описывается внутренними закрытыми полями класса код шага автомата оформляется виде метода класса причём такой метод скорее всего оказывается единственным открытым методом не считая конструкторов деструкторов изменяющим состояние автомата другие открытые методы могут служить для получения информации состоянии автомата но не меняют его все вспомогательные методы например методы обработчики отдельных состояний или их категорий таких случаях обычно убирают закрытую часть класса языки язык функциональных схем sfc sequential function chart графический язык широко используется для промышленных логических контроллеров plc sfc программа описывается виде схематической шагов объединенных переходами дракон схемы графический язык используется для ракетно космической технике буран морской старт тополь существует бесплатный дракон редактор язык рефлекс си подобный язык ориентированный на описание сложных алгоритмов управления задачах промышленной автоматизации примечания литература practical uml statecharts in книга реализации uml state machine на нацелена главным образом на встроенных систем реального времени научно технический вестник спбгу итмо выпуск автоматное http ntv ifmo ru file journal pdf ссылки автоматное проекты архив проектов открытой документацией кузнецов психология автоматного кузнецов настраиваемые автоматные программы см также событийно ориентированное категория парадигмы