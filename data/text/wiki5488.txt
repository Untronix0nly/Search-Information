си компилируемый статически типизированный язык общего назначения разработанный годах сотрудником bell labs деннисом ритчи как развитие языка би первоначально был разработан для реализации операционной системы unix но впоследствии был перенесён на множество других платформ согласно дизайну языка его конструкции близко сопоставляются типичным машинным инструкциям благодаря чему он нашёл применение проектах для которых был свойственен язык ассемблера том числе как операционных системах так различном прикладном программном обеспечении для множества устройств от до встраиваемых систем язык си оказал существенное влияние на развитие индустрии программного обеспечения его синтаксис стал основой для таких языков как java objective история язык был разработан лабораториях bell labs период по годы согласно ритчи самый активный период творчества пришёлся на год язык назвали си третья буква английского алфавита потому что многие его особенности берут начало от старого языка би вторая буква английского алфавита существует несколько различных версий происхождения названия языка би кен томпсон указывает на язык bcpl однако существует ещё язык bon также созданный им названный так честь его жены бонни существует несколько легенд касающихся причин разработки си его отношения операционной системе unix включая следующие разработка си стала результатом того что его будущие авторы любили компьютерную игру подобную популярной игре asteroids астероиды они уже давно играли неё на главном сервере компании который был недостаточно мощным должен был обслуживать около ста пользователей томпсон ритчи посчитали что им не хватает контроля над космическим кораблём для того чтобы избегать столкновений некоторыми камнями поэтому они решили перенести игру на свободный pdp стоящий офисе однако этот компьютер не имел операционной системы что заставило их её написать конце концов они решили перенести эту операционную систему ещё на офисный pdp что было очень тяжело потому что её код был целиком написан на ассемблере было вынесено предложение использовать какой нибудь высокоуровневый портируемый язык чтобы можно было легко переносить ос одного компьютера на другой язык би который они хотели сначала задействовать для этого оказался лишён способной использовать новые возможности pdp поэтому они остановились на разработке языка си самый первый компьютер для которого была первоначально написана unix предназначался для создания системы автоматического заполнения документов первая версия unix была написана на ассемблере позднее для того чтобы переписать эту операционную систему был разработан язык си году язык си стал достаточно силён большая часть ядра unix первоначально написанная на ассемблере pdp была переписана на си это было одно из самых первых ядер операционных систем написанное на языке отличном от ассемблера более ранними были лишь системы multics написана на пл tripos написана на bcpl году брайан керниган деннис ритчи опубликовали первую редакцию книги язык си эта книга известная среди программистов как служила многие годы неформальной спецификацией языка версию языка си описанную ней часто называют вторая редакция этой книги посвящена более позднему стандарту ansi описанному ниже ввёл следующие особенности языка структуры тип данных struct длинное целое тип данных long int целое без знака тип данных unsigned int оператор подобные ему старые операторы вводили анализатор лексики компилятора си заблуждение например при сравнении выражений часто считают самой главной частью языка которую должен поддерживать компилятор си многие годы даже после выхода ansi он считался минимальным уровнем которого следовало придерживаться программистам желающим добиться от своих программ максимальной переносимости потому что не все компиляторы тогда поддерживали ansi хороший код на был верен для ansi после публикации язык было добавлено несколько возможностей поддерживаемых компиляторами at некоторых других производителей функции не возвращающие значение типом void указатели не имеющие типа типом void функции возвращающие объединения структуры имена полей данных структур разных пространствах имён для каждой структуры присваивания структур спецификатор констант const стандартная библиотека реализующая большую часть функций введённых различными производителями перечислимый тип enum дробное число одинарной точности float iso конце годов си начал вытеснять бейсик позиции ведущего языка для годах он был адаптирован для использования ibm pc что привело резкому росту его популярности то же время бьёрн страуструп другие лабораториях bell labs начали работу по добавлению си возможностей объектно язык который они итоге сделали оказал большое влияние на разработку по но так не смог сравняться по популярности си особенно unix подобных системах году американский национальный институт стандартов ansi сформировал комитет для разработки стандартной спецификации си по окончании этого долгого сложного процесса году он был наконец утверждён как язык си ansi эту версию языка принято называть ansi или году стандарт ansi был принят небольшими изменениями международной организацией по стандартизации iso как iso iec одной из целей этого стандарта была разработка надмножества включающего многие особенности языка созданные позднее однако комитет по стандартизации также включил него несколько новых возможностей таких как прототипы функций заимствованные из более сложный препроцессор ansi сейчас поддерживают почти все существующие компиляторы почти весь код си написанный последнее время соответствует ansi любая программа написанная только на стандартном си гарантированно будет правильно выполняться на любой платформе имеющей соответствующую реализацию си однако большинство программ написаны так что они будут компилироваться исполняться только на определённой платформе потому что они используют нестандартные библиотеки например для графических дисплеев они используют специфические платформо зависимые средства они рассчитаны на определённое значение размера некоторых типов данных или на определённый способ хранения этих данных памяти для конкретной платформы после стандартизации ansi спецификация языка си оставалась относительно неизменной течение долгого времени то время как продолжал развиваться году стандарт си была внесена первая нормативная поправка но её почти никто не признавал однако конце годов стандарт подвергся пересмотру что привело публикации iso году этот стандарт обычно называют марте года он был принят адаптирован ansi некоторые новые особенности подставляемые функции inline объявление локальных переменных любом операторе программного текста как новые типы данных такие как long long int для облегчения перехода от битным числам явный булевый тип данных тип complex для представления комплексных чисел поддержка ограниченных указателей restrict именованная инициализация структур struct int point поддержка однострочных комментариев начинающихся на заимствованных из многие компиляторы си поддерживали их ранее качестве дополнения несколько новых библиотечных функций таких как snprintf несколько новых заголовочных файлов таких как stdint декабря опубликован новый стандарт для языка си iso iec основные изменения поддержка многопоточности улучшенная поддержка юникода обобщённые макросы type generic expressions позволяют статичную перегрузку анонимные структуры объединения упрощают обращение ко вложенным конструкциям управление выравниванием объектов статичные утверждения static assertions удаление опасной функции gets пользу безопасной gets_s функция quick_exit спецификатор функции новый режим эксклюзивного открытия файла принципы язык си отличается минимализмом авторы языка хотели чтобы программы на нём легко компилировались помощью однопроходного компилятора чтобы каждой элементарной составляющей программы после компиляции соответствовало весьма небольшое число машинных команд использование базовых элементов языка не задействовало библиотеку времени выполнения однопроходный компилятор компилирует программу не возвращаясь назад уже обработанному тексту поэтому использованию функций переменных должно предшествовать их объявление код на си можно легко писать на низком уровне абстракции почти как на ассемблере иногда си называют универсальным ассемблером или ассемблером высокого уровня что отражает различие языков ассемблера для разных платформ единство стандарта си код которого может быть скомпилирован без изменений практически на любой модели компьютера си часто называют языком среднего уровня или даже низкого уровня учитывая то как близко он работает реальным устройствам однако строгой классификации он является языком высокого уровня компиляторы си разрабатываются сравнительно легко благодаря простоте языка малому размеру стандартной библиотеки поэтому данный язык доступен на самых различных платформах возможно круг этих платформ шире чем любого другого существующего языка тому же несмотря на свою низкоуровневую природу язык позволяет создавать переносимые программы поддерживает этом программиста программы соответствующие стандарту языка могут компилироваться на самых различных компьютерах си как операционная система unix которой он долгое время был связан создавался программистами для программистов круг которых был бы ненамного шире круга разработчиков языка несмотря на это область использования языка значительно шире задач системного язык создавался целью сделать более простым написание больших программ минимумом ошибок по сравнению ассемблером следуя принципам процедурного но избегая всего что приведёт дополнительным накладным расходам обычным для языков высокого уровня си имеет следующие основные особенности простую языковую базу из которой вынесены библиотеки многие существенные возможности вроде математических функций или функций управления файлами ориентацию на процедурное обеспечивающую удобство применения структурного стиля систему типов предохраняющую от бессмысленных операций использование препроцессора для например определения макросов включения файлов исходным кодом доступ памяти компьютера через использование указателей минимальное число ключевых слов передачу параметров функцию по значению не по ссылке при этом передача по ссылке эмулируется помощью указателей указатели на функции статические переменные области действия имён структуры объединения определяемые пользователем собирательные типы данных которыми можно манипулировать как одним целым то же время си отсутствуют вложенные функции сопрограммы средства автоматического управления памятью средства объектно средства функционального часть отсутствующих возможностей может имитироваться встроенными средствами например сопрограммы можно имитировать помощью функций setjmp longjmp часть добавляется помощью сторонних библиотек например для поддержки многозадачности для сетевых функций можно использовать библиотеки pthreads sockets тому подобными существуют библиотеки для поддержки автоматической сборки мусора часть реализуется некоторых компиляторах виде расширений языка например вложенные функции gcc существует несколько громоздкая но вполне работоспособная методика позволяющая имитировать на си основные механизмы ооп базирующаяся на фактической полиморфности указателей си поддержке этом языке указателей на функции после появления язык был хорошо принят потому что он позволял быстро создавать компиляторы для новых платформ также позволял программистам довольно точно представлять как выполняются их программы благодаря близости языкам низкого уровня программы на си работали эффективнее написанных на многих других языках высокого уровня лишь вручную код на ассемблере мог работать ещё быстрее потому что давал полный контроль над машиной на сегодняшний день развитие компиляторов усложнение процессоров привело тому что вручную написанный ассемблерный код кроме разве что очень коротких программ практически не выигрывает по сравнению кодом генерируемым компиляторами при этом си продолжает оставаться одним из наиболее эффективных языков высокого уровня одним из последствий высокой эффективности переносимости языка стало то что многие компиляторы интерпретаторы библиотеки других языков высокого уровня часто написаны на языке си синтаксис лексемы языке используются являются допустимыми все символы латинского алфавита цифры специальные символы запятая точка амперсанд тильда апостроф кавычки двоеточие знак подчёркивания из допустимых символов формируются лексемы константы идентификаторы знаки операций свою очередь лексемы являются частью выражений из выражений составляются инструкции операторы при трансляции программы на си из программного кода выделяются лексемы максимальной длины содержащие допустимые символы если программе имеется недопустимый символ то лексический анализатор или компилятор выдаст ошибку трансляция программы окажется невозможной также имеется символ который не может быть частью никакой лексемы используется препроцессоре идентификаторы допустимый идентификатор это слово лексема составленное из допустимых символов алфавита языка не являющееся знаком некоторой операции или разделителем идентификаторы это те имена которые даются программным объектам именованным константам переменным типам функциям некоторые лексемы являются или что то же самое ключевыми словами см ниже поэтому не могут быть использованы программе качестве идентификаторов программных объектов константы для введения программе на си именованных констант используется директива препроцессора define define имя константы значение введённая таким образом константа будет действовать всюду начиная момента задания константы до конца программного кода или до тех пор пока действие заданной константы не отменено другой директивой undef имя константы как для всякого макроса для именованной константы происходит автоматическая подстановка значения константы программном коде всюду где употреблено имя константы если для именованной константы указано некоторое значение то для константы определяется так же тип соответствующий виду задаваемого значения различают следующие типы констант числовые целочисленные или вещественные символьные выделяются знаком апострофа текстовые строки выделяются знаком двойных кавычек ключевые слова ключевые слова это лексемы слова которые зарезервированы компилятором для обозначения типов переменных класса хранения элементов операторов стандартом предусмотрены следующие ключевые слова для указания операции получения размера объекта sizeof для описания прототипа объекта typedef для объявления переменных для обозначения класса хранения переменных auto register для обозначения того что объект описывается другом месте extern для обозначения того что объект статический static для обозначения типа переменных char short int long signed unsigned float double void для указания на произвольный родовой тип для обозначения специальных типов данных struct структура enum перечисление union для обозначения операторов их элементов для обозначения операторов цикла do for while для обозначения условного оператора if else для обозначения оператора выбора switch case default для обозначения операторов перехода операторы прерывания исполнения кода break continue для обозначения оператора безусловного перехода goto для обозначения оператора возврата из функции return стандарте добавлены следующие ключевые слова для обозначения того что функция является встраиваемой inline для обозначения типа переменной bool complex imaginary для обозначения того что объявляемый указатель указывает на блок памяти на который не указывает никакой другой указатель restrict комментарии текст программы на си может содержать фрагменты которые не являются частью программного кода комментарии комментарии специальным образом помечаются тексте программы пропускаются при компиляции первоначально стандарте были предусмотрены символы для обозначения начала комментария символ для обозначения завершения комментария при этом невозможно вложить один комментарий другой поскольку первый встреченный символ завершит комментарий текст следующий непосредственно за символом если этот текст не является программным кодом содержит произвольный текст вызовет ошибку компиляции следующий стандарт стандарт ввёл ещё один способ оформления комментариев комментарием считается текст начинающийся символа заканчивающийся конце строки операции операция это некоторая функция которая выполняется над операндами которая возвращает вычисленное значение результат выполнения операции каждой операции си соответствует свой знак операции см выше операнд это константа переменная выражение или вызов какой либо определённой программе функции операции различают по количеству задействованных операндов именно различают унарные операции операции вида знак операции операнд бинарные операции операнд знак операции операнд тернарные операции унарные операции унарные операции это операции содержащие единственный операнд унарным операциям си относятся следующие операции унарный плюс унарный минус взятие обратного кода логическое отрицание взятие адреса операция разыменовывания указателя sizeof операция определения занимаемого объектом объёма памяти бинарные операции бинарные операции это операции содержащие два операнда между которыми расположен знак операции бинарным операциям си относятся следующие операции сложение вычитание умножение деление взятие остатка от деления поразрядное поразрядное или поразрядное исключающее или логический сдвиг влево логический сдвиг вправо логическое логическое или также бинарным операциям си относятся операции по сути представляющие собою присваивание добавление левому операнду значения представленного правым операндом вычитание из левого операнда значения представленного правым операндом умножение левого операнда на значение представленное правым операндом деление левого операнда на значение представленное правым операндом поразрядное логическое над левым правым операндом поразрядное логическое или над левым правым аргументом поразрядное логическое исключающее или над левым правым аргументом поразрядный сдвиг влево левого аргумента на количество бит заданное правым аргументом поразрядный сдвиг вправо левого аргумента на количество бит заданное правым аргументом данные операции предполагают что левый операнд представляет собою лево допустимое выражение тернарные операции си имеется единственная тернарная операция условная операция которая имеет следующий вид условие выражение выражение которая имеет три операнда условие логическое условие которое проверяется на истинность выражение выражение значение которого возвращается качестве результата выполнения операции если условие истинно выражение выражение значение которого возвращается качестве результата выполнения операции если условие ложно знаком операции здесь служит целое сочетание выражения выражение это упорядоченный набор операций над переменными выражения содержат операнды знаки операций см выше порядок выполнения операций зависит от формы записи от приоритета выполнения операций см ниже каждого выражения имеется значение результат выполнения всех операций входящих выражение вычислением значения выражения может быть связан побочный эффект когда ходе выполнения операций меняется некоторая переменная другим возможным побочным эффектом является неявное преобразование типов простейшее выражение содержит только имя переменной её идентификатор значением такого выражения будет то значение или тот объект которое хранится данной переменной среди выражений выделяют класс лево допустимых выражений выражений которые могут присутствовать слева от знака присваивания приоритет выполнения операций операции си выполняются соответствии следующей таблице приоритетов операций лексемы операция класс приоритет ассоциативность имена литералы простые лексемы первичный нет индексы постфиксный слева направо вызов функции постфиксный слева направо прямой выбор постфиксный слева направо опосредованный выбор постфиксный слева направо положительное отрицательное приращение постфиксный слева направо положительное отрицательное приращение префиксный справа налево составной литерал постфиксный справа налево размер унарный справа налево побитовое не унарный справа налево логическое не унарный справа налево изменение знака плюс унарный справа налево адрес унарный справа налево опосредование разыменование унарный справа налево имя типа приведение типа унарный справа налево операции бинарный слева направо аддитивные операции бинарный слева направо сдвиг влево вправо бинарный слева направо отношения бинарный слева направо равенство неравенство бинарный слева направо побитовое бинарный слева направо побитовое исключающее или бинарный слева направо побитовое или бинарный слева направо логическое бинарный слева направо логическое или бинарный слева направо условие тернарный справа налево присваивание бинарный справа налево вычисление бинарный слева направо операторы операторы предназначены для осуществления действий для управления ходом выполнения программы несколько идущих подряд операторов образуют операторов пустой оператор самая простая языковая конструкция это пустое выражение называемое пустым оператором пустой оператор не совершает никаких действий может находиться любом месте программы инструкции инструкция это некое элементарное действие выражение действие этого оператора заключается выполнении указанного теле оператора выражения несколько идущих подряд инструкций образуют инструкций блок вычислений инструкции могут быть сгруппированы специальные вычислительные блоки следующего вида инструкций ограниченные при помощи двух разделителей левая фигурная скобка обозначает начало вычислительного блока правая фигурная скобка обозначает конец вычислительного блока вычислительный блок называют ещё составным оператором каждая функция см ниже содержит такой блок который обозначает тело функции является частью определения функции условные операторы языке существует два условных оператора реализующих ветвление программы оператор if содержащий проверку одного условия оператор switch содержащий проверку нескольких условий самая простая форма оператора if if условие оператор следующий оператор оператор if работает следующим образом если выполнено условие указанное скобках то выполняется первый оператор затем выполняется оператор указанный после оператора if если условие указанное скобках не выполнено то сразу выполняется оператор указанный после оператора if частности следующий ниже код случае выполнения заданного условия не будет выполнять никаких действий if условие поскольку фактически выполняется пустой оператор более сложная форма оператора if содержит ключевое слово else if условие оператор else альтернативный оператор следующий оператор здесь если условие указанное скобках не выполнено то выполняется оператор указанный после ключевого слова else операторы выполнения цикла цикл это фрагмент программного кода содержащий условие выполнения цикла условие которое постоянно проверяется тело цикла простой или составной оператор выполнение которого зависит от условия цикла соответствии этим различают два вида циклов цикл предусловием где сначала проверяется условие выполнения цикла если условие выполнено то выполняется тело цикла цикл постусловием где сначала выполняется тело цикла уже потом проверяется условие выполнения цикла если условие выполнено то тело цикла всегда выполняются до тех пор пока выполняется указанное цикле условие таким образом цикл постусловием гарантирует что тело цикла обязательно выполнится хотя бы один раз си предусмотрен оператор цикла предусловием while условие тело цикла оператор постусловием do while do тело цикла while условие также имеется оператор for блок инициализации условие оператор тело цикла который эквивалентен следующему блоку операторов блок инициализации while условие тело цикла оператор обычной ситуации блок инициализации содержит задание начального значения переменной которая называется переменной цикла оператор который выполняется сразу после тела цикла меняет значения используемой переменной условие содержит сравнение значения используемой переменной цикла некоторым заранее заданным значением как только сравнение перестаёт выполняться цикл прерывается начинает выполняться программный код следующий сразу за оператором цикла условие цикла это логическое выражение однако неявное приведение типов позволяет использовать качестве условия цикла арифметическое выражение это позволяет организовать бесконечный цикл while или то же самое но уже применением оператора for for такие бесконечные циклы используются совместно операторами прерывания работы цикла см ниже операторы безусловного перехода операторы безусловного перехода позволяют прервать выполнение любого блока вычислений перейти другое место программы операторы безусловного перехода обычно используются совместно условными операторами оператор goto метка где метка это некоторый числовой идентификатор передаёт управление тому оператору который помечен программе указанной меткой метка оператор если указанная метка отсутствует программе или если существует несколько операторов одной той же меткой компилятор сообщает об ошибке передача управления возможна только пределах той функции где используется оператор перехода следовательно при помощи оператора goto нельзя передать управление другую функцию другие операторы перехода связаны циклами позволяют прервать выполнения тела цикла оператор break немедленно прерывает выполнение тела цикла происходит передача управления на оператор следующий непосредственно сразу за оператором цикла оператор continue прерывает выполнение тела цикла передаёт управление начало цикла что инициирует проверку условия цикла оператор continue может быть использован только внутри операторов do while for оператор break также может использоваться внутри оператора switch существует два особых случая применения операторов break continue если оператор continue встретился теле оператора for то сначала происходит выполнение оператора уже затем происходит проверка условия цикла таким образом оператор continue предназначен для немедленного перехода следующей итерации выполнения цикла если имеется несколько вложенных циклов то оператор break зависимости от реализации либо полностью прерывает выполнение всех вложенных циклов либо прерывает выполнение только того цикла котором расположен сам оператор break оператор возврата из функции си определён оператор return который прерывает выполнение функции где использован данный оператор если функция не должна возвращать значение то используется вызов return если функция должна возвращать какое либо значение то использует вызов return значение если после оператора возврата теле функции имеются ещё какие то операторы то эти операторы никогда не будут выполняться этом случае компилятор может выдать предупреждение функции функция это самостоятельный фрагмент программного кода который может многократно использоваться программе функции могут иметь аргументы могут возвращать значения для того чтобы задать функцию си необходимо её объявить сообщить имя идентификатор функции перечислить входные параметры аргументы указать тип возвращаемого значения также необходимо привести определение функции которое содержит блок операторов реализующих поведение функции отсутствие определения ранее определённой функции является ошибкой что зависимости от реализации приводит выдаче сообщений или предупреждений когда компилятор встречает программном коде идентификатор функции то он оформляет операцию вызова функции рамках которой частности адрес точки вызова помещается стек создаются переменные отвечающие за параметры функции передаётся управление коду реализующему вызываемую функцию после выполнения функции происходит освобождение памяти выделенной при вызове функции возврат точку вызова если вызов функции является частью некоторого выражения передача точку возврата вычисленного внутри функции значения особый класс функций представляют встраиваемые или подставляемые функции функции объявленные указанием ключевого слова inline определения таких функций непосредственно подставляются точку вызова что одной стороны увеличивает объём исполняемого кода но другой стороны позволяет экономить время его выполнения поскольку не используется дорогая по времени операция вызова функции объявление функции объявление функции имеет следующий формат описатель имя список где описатель описатель типа возвращаемого функцией значения имя имя функции уникальный идентификатор функции список список формальных параметров функции признаком объявления функции является символ таким образом объявление функции это инструкция самом простом случае описатель содержит указание на конкретный тип возвращаемого значения функция которая не должна возвращать никакого значения объявляется как имеющая тип void при необходимости описателе могут присутствовать дополнительные элементы модификатор extern указывает на то что определение функции находится другом модуле модификатор static задаёт статическую функцию модификаторы pascal или cdecl влияют на обработку формальных параметров связаны подключением внешних модулей список параметров функции задаёт сигнатуру функции си не допускает объявление нескольких функций имеющих одно то же имя перегрузка функций не поддерживается определение функции определение функции имеет следующий формат описатель имя список тело где описатель имя список те же что объявлении тело это составной оператор который представляет собою конкретную реализацию функции компилятор различает определения одноимённых функций по их сигнатуре таким образом по сигнатуре устанавливается связь между определением соответствующим ему объявлением тело функции имеет следующий вид операторов return возвращаемое значение вызов функции вызов функции заключается выполнении следующих действий сохранение точки вызова стеке выделение памяти под переменные соответствующие формальным параметрам функции инициализация переменных значениями переменных фактических параметров функции переданных функцию при её вызове также инициализация тех переменных для которых объявлении функции указаны значения по умолчанию но для которых при вызове не были указаны соответствующие им фактические параметры передача управления тело функции зависимости от реализации компилятор либо строго следит за тем чтобы тип фактического параметра совпадал типом формального параметра либо если существует такая возможность осуществляет неявное преобразование типа что очевидно приводит побочным эффектам если функцию передаётся переменная то при вызове функции создаётся её копия стеке выделяется память копируется значение например передача структуры функцию вызовет копирование всей структуры целиком если же передаётся указатель на структуру то копируется только значение указателя передача функцию массива также вызывает лишь копирование указателя на его первый элемент при этом для явного обозначения того что на вход функции принимается адрес начала массива не указатель на единичную переменную вместо объявления указателя после названия переменной можно поставить квадратные скобки например void example_func int array array указатель на первый элемент массива типа int си допускает вложенные вызовы глубина вложенности вызовов имеет очевидное ограничение связанное размером выделяемого программе стека поэтому реализациях си устанавливается некое предельное значение для глубины вложенности частный случай вложенного вызова это вызов функции внутри тела вызываемой функции такой вызов называется рекурсивным применяется для организации единообразных вычислений учитывая естественное ограничение на вложенные вызовы рекурсивную реализацию заменяют на реализацию при помощи циклов возврат из функции при возврате из функции освобождается память выделенная под параметры функции под переменные объявленные внутри функции управление возвращается точку вызова препроцессор препроцессор читает преобразует текст программы перед обработкой его компилятором технически препроцессор может быть реализован по разному но логически его удобно представлять именно как отдельный модуль целиком обрабатывающий программу формирующий текст попадающий затем на вход компилятора препроцессор ищет тексте строки начинающиеся со специальных символов называемых директивами препроцессора зависимости от этих директив формирует выходной текст текст программы не относящийся директивам препроцессора не исключённый из компиляции согласно этим директивам см ниже передаётся на вход компилятора неизменном виде си все директивы препроцессора начинаются символа используются следующие директивы препроцессора последующем тексте программы имя заменяется на значение если значение не указано то имя запоминается как определённое но не получает значения директива может использоваться для определения именованных констант для установки флагов условной компиляции аналогично предыдущему но скобках после имени идёт список параметров через запятую обращение этому коде должно выглядеть как имя параметры препроцессор заменит его на значение котором любое вхождение имени одного из параметров будет заменено на фактическое значение параметра указанное обращении если ранее имя было определено то это определение отменяется или текст файла именем имя_файла включается текст обрабатываемого файла исходного кода заменяя собой данную директиву варианты записи имени угловых скобках или кавычках управляют способом поиска включаемого файла обычно если файл указан кавычках то компилятор пытается найти его каталоге где находится текущий обрабатываемый файл если угловых скобках то специальном системном каталоге начало составной директивы условной компиляции проверяет определено ли имя то есть была ли ранее обработана директива данным именем если имя определено то следующие за директивой строки программы до директивы или будут включены выходной текст если не определено не будут включены завершает первую часть составной директивы условной компиляции начинающейся строки программы находящиеся после неё до директивы будут включены состав выходного текста если имя указанное предыдущей директиве не определено завершает составную директиву условной компиляции то же что но проверка успешна тогда когда указанное имя не определено важно понимать что препроцессор обеспечивает чисто текстовые подстановки не учитывая синтаксис семантику языка так например могут встречаться внутри функций или определений типов директивы условной компиляции могут приводить исключению из компилируемого текста программы любой части кода без оглядки на грамматику языка например следующем фрагменте define dummy int main int argc char argv ifndef dummy return int additional endif printf this is an additional function body return определение макроса dummy первой строке приведёт тому что фрагмент последними двумя строками функции main всеми кроме последних трёх строк функции additional будет удалён то есть функция main которую обработает компилятор примет вид int main int argc char argv printf this is an additional function body return выдаст конце своего исполнения строку this is an additional function body параметрами широко используются си программах для создания аналогов обобщённых функций ранее они также применялись для реализации встраиваемых функций но позднейших стандартах эта необходимость исчезла после добавления возможности явного описания inline функций однако параметрами могут приводить неожиданным проблемам define mul mul приведённом выше примере казалось бы переменной должно быть итоге присвоено значение но препроцессор не будет обрабатывать сумму разность последней строке он просто раскроет обращение mul строка попадёт на вход компилятора виде что итоге даст не чтобы избежать подобных эффектов выражение параметры его тексте окружают скобками define mul mul этом случае всё будет правильно так как mul раскроется виде структура программы модули программа представляет собой набор файлов кодом на языке си которые могут компоноваться включаться один другой посредством директивы препроцессора каждый файл исходного кода переданный компилятору формирует самостоятельную монолитную единицу компиляции которая после обработки компилятором некоторых случаях ассемблером превращается объектный файл объектные файлы собираются вместе компоновщиком который обеспечивает межмодульные вызовы присоединяет результатам компиляции объектный код библиотек заголовок на уровне языка понятия модуля си не существует функция или глобальная переменная описанная одной единице компиляции доступна во всех остальных входящих ту же программу при условии наличия них форварда специального объявления внешнего объекта форварды нужны для того чтобы компилятор обрабатывая обращение объекту мог правильно сформировать код этого обращения некоторые описания например объявления типов должны быть просто продублированы модуле использующем внешние объекты таким образом для си единица компиляции равнозначна модулю функцию интерфейса модуля выполняет заголовочный файл обычно имеющий имя вида содержащий форварды экспортируемых объектов модуля дополнительные описания необходимые для их использования для обращения внешним объектам модуля прочие файлы программы включают себя посредством этот заголовочный файл который таким образом становится частью текста единицы компиляции использующей модуль файлы исходного кода текст файла исходного кода на языке си состоит из набора глобальных определений данных типов функций глобальные переменные функции объявленные со спецификаторами statiс inline доступны только пределах того файла где они объявлены глобальные переменные функции объявленные со спецификатором extern считаются описанными других файлах то есть их допускается использовать соответствии описанием предполагается что после сборки программы редактором связей они будут связаны оригинальными объектами функциями описанными своих файлах глобальные переменные функции кроме inline могут быть доступны из других файлов при условии их надлежащего объявления там со спецификатором extern объявления типов typedef struct union не могут импортироваться других файлах при необходимости использования других файлах они должны быть там продублированы то же самое относится inline функциям ранних версиях си было допустимо ссылаться на функции объявленные позже ниже по тексту файла ansi стандарте языка обращение переменной типу или функции требует наличия объявления выше по тексту текущего файла исходного текста точка входа программы для исполняемой программы стандартной точкой входа является функция именем main которая должна быть не статической единственной программе исполнение программы начинается первого оператора функции main продолжается до выхода из неё после чего программа завершается управление передаётся операционной системе сигнатура функции выглядит следующим образом int main int argc char argv первый параметр argc при вызове передаётся количество элементов строке запуска программы считая имя самой программы то есть типичных случаях argc не может быть меньше единицы во второй параметр argv передаётся сама строка запуска программы виде массива текстовых строк массивов типа char содержащих элементы строки запуска программы каждый из которых завершается нулевым символом компилятор гарантирует что на момент запуска функции main все глобальные переменные программе будут качестве результата функция main может вернуть любое целое число диапазоне значений типа int которое будет передано операционной системе качестве кода возврата программы стандарт языка не определяет смысла кодов возврата обычно операционная система где работают программы имеет те или иные средства позволяющие получить значение кода возврата его также определённые соглашения значениях этих кодов типичным является соглашение том что нулевое значение кода возврата сигнализирует об успешном завершении программы ненулевое представляет собой код возникшей ошибки типы данных примитивные типы целые числа размер целочисленных типов данных варьируется от не менее до не менее бит стандарт увеличивает максимальный размер целого числа не менее бит целочисленные типы данных используются для хранения целых чисел тип char также используется для хранения ascii символов все размеры диапазонов представленных ниже типов данных минимальны на отдельно взятой платформе могут быть больше стандарт требует чтобы для размеров целочисленых типов выполнялось условие sizeof char таким образом размеры различных типов могут совпадать даже char long могут иметь одинаковый размер но такие платформы очень редки стандарт гарантирует что тип char всегда равен байту минимальный диапазон значений целых типов по стандарту определяется по где разрядность типа реализация компиляторов может расширять этот диапазон по своему усмотрению на практике чаще используется диапазон по минимальное максимальное значения каждого типа указывается файле limits виде макросов отдельное внимание стоит уделить типу char формально это отдельный тип но фактически char эквивалентен либо signed char либо unsigned char зависимости от компилятора для того чтобы избежать путаницы между размерами типов стандарт ввел новые типы данных описанные файле stdint среди них такие типы как intn_t int_leastn_t int_fastn_t где или приставка least обозначает минимальный тип способный вместить бит приставка fast обозначает тип размером не менее бит работа которым наиболее быстрая на данной платформе типы без приставок обозначают типы фиксированном размером равным бит типы приставками least fast можно считать заменой типам int short long той лишь разницей что первые дают программисту выбрать между скоростью размером тип данных размер минимальный диапазон значений первое появление signed char минимум бит от до unsigned char минимум бит от до char минимум бит от до или от до зависимости от компилятора short int минимум бит от до unsigned short int минимум бит от до int минимум бит от до unsigned int минимум бит от до long int минимум бита от до unsigned long int минимум бита от до long long int минимум бита от до unsigned long long int минимум бита от до int бит от до uint бит от до int бит от до uint бит от до int бита от до uint бита от до int бита от до uint бита от до типы int_leastn_t uint_leastn_t int_fastn_t uint_fastn_t или введенные стандартом размером диапазоном совпадают типами char short int long таблице приведён минимальный диапазон значений согласно стандарту языка компиляторы языка си могут расширять диапазон значений элементы си хранение данных одной из самых важных функций любого языка является предоставление возможностей для управления памятью объектами хранящимися ней си есть три разных способа выделения памяти классы памяти для объектов статическое выделение памяти пространство для объектов создаётся сегменте данных программы момент компиляции время жизни таких объектов совпадает со временем жизни этого кода изменение таких объектов ведёт так называемому стандарте неопределённому поведению на практике эта операция приводит ошибке во время выполнения автоматическое выделение памяти объекты можно хранить стеке эта память затем автоматически освобождается может быть использована снова после того как программа выходит из блока использующего его динамическое выделение памяти блоки памяти нужного размера могут запрашиваться во время выполнения программы помощью библиотечных функций malloc realloc calloc из области памяти называемой кучей эти блоки освобождаются могут быть использованы снова после вызова для них функции free все три этих способа хранения данных пригодны различных ситуациях имеют свои преимущества недостатки например статическое выделение памяти не имеет накладных расходов по выделению автоматическое выделение лишь малые расходы при выделении вот динамическое выделение потенциально требует больших расходов на выделение на освобождение памяти другой стороны память стека гораздо больше ограничена чем статическая или память куче только динамическая память может использоваться случаях когда размер используемых объектов заранее неизвестен большинство программ на си интенсивно используют все три этих способа там где это возможно является автоматическое или статическое выделение памяти такой способ хранения объектов управляется компилятором что освобождает программиста от трудностей ручного выделения освобождения памяти как правило служащего источником трудно отыскиваемых ошибок утечек памяти повторного освобождения программе сожалению многие структуры данных имеют переменный размер во время выполнения программы поэтому из за того что автоматически статически выделенные области должны иметь известный фиксированный размер во время компиляции очень часто требуется использовать динамическое выделение массивы переменного размера самый пример такого использования памяти представление памяти представление памяти данном разделе рассмотрено представление памяти программы операционной системе gnu linux архитектуре amd порядок расположения кучи стека других областей может отличаться других архитектурах операционных системах при запуске программы из исполняемого файла оперативную память импортируются инструкции процессора машинный код данные то же время старшие адреса импортируются аргументы командной строки доступные функции main со следующей сигнатурой во втором аргументе int argc char argv переменные окружения области данных хранятся неизменяемые данные это могут быть например строковые литералы глобальные переменные хранятся области данных процессе запуска эта область изначально нулевыми значениями память выделенная динамически предоставляется из кучи heap для выделения памяти во время работы программы используется функция malloc из stdlib для освобождения функция free область стека предназначена для размещения вызовов функций каждый раз как вызывается какая либо функция стек увеличивается после того как функция завершила свою работу стек уменьшается функции объявленные квалификатором inline могут не использовать стек подставляться код компилятор волен игнорировать inline также немаловажной деталью является наличие случайного отступа между стеком верхней областью также между областью данных кучей делается это целях безопасности например для предотвращения встраивания стек других функций динамически подключаемые библиотеки отображения файлов файловой системы находится между стеком кучей также стоит учитывать что переменные квалификатором register скорее всего будут размещены прямо памяти процессора регистрах тем не менее количество регистров ограничено поэтому компилятор может игнорировать такую рекомендацию для таких переменных отсутствует операция взятия адреса примеры на си простейшая программа на си простейшая программа на си имеет следующий вид main по умолчанию предполагается что основная функция программы функция main возвращает целое число поэтому такая программа должна компилироваться возможно выдачей одного или нескольких предупреждений если компилятор реализует стандарт ansi если однако компилятор следует стандарту то такой код не будет компилироваться потребуется явное описание типа возвращаемого функцией main значения допускается не писать оператор return функции main таком случае согласно стандарту функция main возвращает включая исполнение всех обработчиков назначенных на exit подразумевая что программа успешно завершилась hello world программа hello world приведена ещё первом издании книги язык си кернигана ритчи include int main void не принимает аргументы printf hello world новая строка return удачное завершение программы эта программа печатает сообщение hello world на стандартном устройстве вывода функциональное пример программы которая использует так называемые функции высшего порядка чистые функции include include int add_one const int const int subtract_one const int const int modify const int int const int int add_one const int num return num int subtract_one const int num return num int modify const int num int const int return num int main int num_ modify add_one printf num_ num_ modify subtract_one printf num_ return exit_success stdout приведенном выше примере атрибут const указывает компилятору что возвращаемое функцией значение зависит только от входных параметров функция не использует глобальные переменные более мягким аналогом атрибутом const является атрибут pure который позволяет функции использовать глобальные переменные языки потомки язык си был остаётся одним из самых языков течение более чем сорока лет естественно что его влияние можно проследить той или иной мере во многих более поздних языках тем не менее среди языков достигших определённого распространения прямых потомков си немного часть языков потомков надстраивают си дополнительными средствами механизмами добавляющими поддержку новых парадигм ооп функциональное обобщённое пр таким языкам относятся прежде всего objective опосредованно их потомки swift также известны попытки улучшить си исправив его наиболее существенные недостатки но сохранив его привлекательные черты среди них можно упомянуть язык cyclone его потомок rust иногда оба направления развития объединяются одном языке примером может служить go отдельно необходимо упомянуть целой группе языков которые большей или меньшей мере унаследовали базовый синтаксис си использование фигурных скобок качестве ограничителей блоков кода описание переменных характерные формы операторов for while if switch параметрами скобках комбинированные операции другие из за чего программы на этих языках имеют характерный внешний вид ассоциирующийся именно си это такие языки как java javascript php perl awk структура семантика этих языков сильно отличается от си обычно они предназначены для тех сфер применения где оригинальный си никогда не использовался язык был создан из си унаследовал его синтаксис дополнив его новыми конструкциями духе языков simula smalltalk modula ada mesa clu основными дополнениями стали поддержка ооп описание классов множественное наследование полиморфизм основанный на виртуальных функциях обобщённого механизм шаблонов но помимо этого язык внесено множество самых различных дополнений на данный момент является одним из наиболее языков мире он позиционируется как универсальный язык предназначенный главным образом для разработки крупных программных комплексов изначально сохранял совместимость си которая была заявлена как одно из преимуществ нового языка первые реализации просто переводили новые конструкции чистый си после чего код обрабатывался обычным си компилятором для сохранения совместимости создатели отказались от исключения из него некоторых часто критикуемых особенностей си вместо этого создав новые параллельные механизмы которые рекомендуется применять при разработке нового кода на шаблоны вместо явное приведение типов вместо автоматического контейнеры стандартной библиотеки вместо ручного динамического выделения памяти так далее однако дальнейшем языки развивались независимо сейчас си последних выпущенных стандартов являются лишь частично совместимыми не гарантируется успешная компиляция программы на си компилятором случае успеха нет гарантии что программа будет работать правильно особенно неприятны некоторые тонкие семантические различия которые могут приводить разному поведению одного того же кода синтаксически корректного для обоих языков например символьные константы символы заключённые одинарные кавычки имеют тип int си тип char так что объём памяти занимаемый такими константами разных языках различается если программа чувствительна размеру символьной константы она будет работать по разному будучи откомпилирована трансляторами си подобные различия затрудняют написание программ библиотек которые могли бы нормально компилироваться работать одинаково си что конечно запутывает тех кто программирует на обоих языках среди разработчиков пользователей как си так есть сторонники максимального сокращения различий между языками что объективно принесло бы ощутимую пользу существует однако противоположная точка зрения согласно которой совместимость не особенно важна хоть полезна усилия по уменьшению несовместимости не должны препятствовать улучшению каждого языка отдельности objective ещё одним вариантом расширения си объектными средствами является язык objective созданный году объектная подсистема была заимствована из smalltalk причём все элементы связанные этой подсистемой реализованы собственном синтаксисе достаточно резко отличающемся от синтаксиса си вплоть до того что описании классов синтаксис объявления полей противоположен синтаксису описания переменных си сначала пишется имя поля затем его тип отличие от objective является надмножеством классического си то есть сохраняет совместимость исходным языком правильная программа на си является правильной программой на objective другим существенным отличием от идеологии является то что objective реализует взаимодействие объектов путём обмена полноценными сообщениями тогда как реализована концепция отправка сообщения как вызов метода полноценная обработка сообщений является значительно более гибкой тому же она естественным образом сочетается параллельными вычислениями objective также его прямой потомок swift являются одними из самых популярных на платформах поддерживаемых apple реализация си некоторые компиляторы идут комплекте компиляторами других языков включая или являются составной частью среды разработки программного обеспечения bds borland builder clang digital mars djgpp gnu compiler collection intel compiler lcc microsoft visual studio mingw open watcom oracle solaris studio pelles portable compiler tiny compiler topspeed jpi компиляторы на динамические языки платформы иногда целях переноса тех или иных библиотек функций инструментов написанных на си иную среду требуется компиляция си кода на язык более высокого уровня или код виртуальной машины предназначенной для такого языка следующие проекты предназначены для этих целей emscripten компилятор из llvm байтокода например полученный из javascript старое название alchemy компилятор из си actionscript virtual machine avm позволяет использовать си библиотеки flash adobe air приложениях clue компилятор из ansi си lua javascript perl java common lisp ampc компилятор из си виртуальную машину java проблемы критика язык си уникален той точки зрения что именно он стал первым языком высокого уровня всерьёз потеснившим ассемблер разработке системного программного обеспечения он остаётся языком реализованным на максимальном количестве аппаратных платформ одним из самых популярных языков особенно мире свободного программного обеспечения тем не менее язык имеет множество недостатков он момента появления подвергается критике многих специалистов общая критика не только критики но апологеты си признают что этот язык весьма сложен наполнен опасными элементами которые очень легко использовать неправильно своей структурой правилами он никак не поддерживает нацеленное на создание надёжного удобного сопровождении программного кода напротив рождённый среде хакеров язык стимулирует соответствующий стиль часто небезопасный поощряющий написание запутанного кода см также керниган говорит си инструмент острый как бритва его помощью можно создать элегантную программу кровавое месиво по выражению алена голуба си си дают вам столько гибкости что если вас нет желания способности призвать себя порядку то итоге вы можете получить гигантский модуль не поддающейся сопровождению тарабарщины притворяющийся тому же компьютерной программой вы можете поистине делать всё при помощи этих языков даже если вы этого не хотите многие элементы си потенциально опасны последствия неправильного использования этих элементов зачастую непредсказуемы связи со сравнительно низким уровнем языка многие случаи неправильного использования опасных элементов не обнаруживаются не могут быть обнаружены ни при компиляции ни во время исполнения до момента когда они приведут явной ошибке это часто приводит поведению программы результатом неграмотного на си могут стать уязвимости системе безопасности си достаточно высокий порог вхождения что затрудняет его использование обучении качестве первого языка наконец за более чем лет существования язык успел несколько устареть нём достаточно проблематично использовать многие современные приёмы парадигмы недостатки отдельных элементов языка примитивная поддержка модульности языке нет понятия модуля механизмов управляющих межмодульным интерфейсом моделирование данного механизма через крайне примитивно не позволяет обеспечить настройку импорта экспорта объявлений не обеспечивает проверки компилятором правильности объявлений форвардов так что ошибки межмодульного взаимодействия такие например как изменение заголовка экспортируемой функции модуле где она определена без изменения заголовочного файла либо обнаруживаются на этапе компоновки либо не обнаруживаются вообще приводят ошибкам времени выполнения включение большого количества заголовочных файлов приводит тому что многократно возрастает фактический объём текста модулей попадающего на компиляцию что является причиной относительно низкой скорости работы си компиляторов необходимость согласования описаний основном модуле заголовочных файлах затрудняет сопровождение программы отсутствие инициализации переменных по умолчанию автоматически динамически создаваемые объекты по умолчанию не после создания содержат значения оставшиеся памяти от ранее находившихся там объектов такое значение полностью непредсказуемо оно меняется от одной машины другой от запуска запуску от вызова функции вызову если программа из за случайного пропуска инициализации использует такое значение то результат будет непредсказуемым не обязательно проявится сразу современные компиляторы пытаются диагностировать эту проблему некоторым анализом исходного кода хотя общем случае статическим анализом это решить нельзя указатели адресная арифметика источником опасных ситуаций служит совместимость указателей числовыми типами возможность использования адресной арифметики это даёт возможность получить указатель на любой объект включая исполняемый код обратиться по этому указателю если только механизм защиты памяти системы этому не воспрепятствует неправильное использование указателей может порождать непредсказуемые эффекты приводить последствиям примеру указатель может быть или результате неверных арифметических операций указывать произвольное место памяти на одних платформах работа таким указателем может вызвать принудительную остановку программы на других это может привести порче произвольных данных памяти последняя ошибка опасна тем что её последствия непредсказуемы могут проявиться произвольный момент времени том числе намного позже момента собственно ошибочного действия массивы доступ массивам реализованный си посредством адресной арифметики проблемы которой описаны выше не предполагает средств проверки корректности обращения элементам массива по индексу выражение ai просто транслируется аналогично проверка на выход за границы массива не проводится обращение по индексу превышающему верхнюю границу массива приводит обращению данным размещённым памяти после массива частный случай такой ошибки называется ошибкой переполнения буфера когда подобное обращение происходит ошибочно оно может привести поведению программы на некоторых архитектурах даже краху операционной системы намеренное использование этой особенности может быть хакерским приёмом используемым для нелегального доступа памяти другого приложения или памяти ядра операционной системы динамически выделяемая память системные функции для работы динамической памятью malloc calloc realloc free не обеспечивают контроля за правильностью выделения освобождения памяти соблюдение правильного порядка работы динамической памятью полностью возлагается на программиста его ошибки соответственно приводят обращению по некорректным повисшим ссылкам когда память освобождается преждевременно либо утечке памяти когда память не освобождена но указатель на неё утрачен память невозможно ни освободить ни использовать до завершения работы программы радикальным решением данной проблемы является автоматическое управление памятью вряд ли приемлемое для языка промежуточного уровня каковым является си единственным движением этом направлении является введение язык локальных массивов переменным размером стандарте также конкретные реализации сторонние библиотеки предоставляют расширения такие как умные указатели ограниченные формы сборки мусора но все эти средства не являются стандартными что естественно ограничивает их применение функции переменным числом аргументов поддерживая функции переменным числом аргументов си не содержит ни средств определения числа типов фактических параметров переданных такой функции ни механизма безопасного доступа ним информирование функции составе фактических параметров лежит на программисте для доступа их значениям необходимо отсчитать правильное количество байтов от адреса последнего фиксированного параметра стеке либо вручную либо пользуясь набором макросов из библиотеки ошибка вызове или работе параметрами внутри функции проявится только во время исполнения программы приведя непредсказуемым последствиям от чтения неверных данных до разрушения стека при этом данный небезопасный механизм широко используется семейство функций printf scanf стандартной библиотеки языка си обеспечивающих стандартный форматированный ввод вывод известно потенциальной опасностью из за использования произвольного списка аргументов описываемого строкой формата многие современные компиляторы проверяют список аргументов для каждого их вызова генерируя предупреждения случаях когда список аргументов не соответствует строке формата однако общем случае подобная проверка невозможна так как каждая функция переменным числом аргументов получает информацию списке аргументов обрабатывает этот список аргументов по своему невозможно статически даже все вызовы функции printf поскольку строка формата может создаваться программе динамически способы преодоления недостатков языка недостатки си давно хорошо известны момента появления языка предпринималось множество попыток повысить качество безопасность кода на си не принося жертву его возможности компиляторы как правило обеспечивают статическую проверку кода на наличие известных типичных ошибок как например упомянутая выше ошибка несоответствия параметров вызова printf содержанию форматной строки выдают предупреждения при обнаружении потенциально опасного кода может поддерживаться возможность встраивания код некоторых дополнительных проверок таких как проверки на выход за границы массивов обычно используется только на этапе отладки существуют специальные программные средства для статического анализа кода на си для выявления не синтаксических ошибок их применение не гарантирует безошибочности программ но позволяет выявить значительную часть типичных ошибок потенциальных уязвимостей максимальный эффект данных средств достигается не при эпизодическом использовании при применении составе отработанной системы постоянного контроля качества кода частности может требоваться аннотирование кода специальными комментариями чтобы исключить ложные срабатывания системы на определённых участках кода формально попадающих под критерии ошибочных выпущено значительное количество исследований правильном на си от небольших статей до объёмных книг для поддержания качества кода на си принимаются корпоративные или отраслевые правила стандарты так известен стандарт misra первоначально разработанный motor industry software reliability association для использования си создании программного обеспечения встроенных систем транспортных средств сейчас misra используется во многих отраслях том числе военной медицинской аэрокосмической редакция года содержит директив правила включающие требования коду ограничения на использование определённых языковых средств так например misra запрещает использование функций переменным числом параметров на рынке имеется около десятка инструментов проверки кода на соответствие misra несколько компиляторов си проверяющих ограничения этого стандарта на этапе компиляции см также cyclone язык стандартная библиотека языка си модель памяти языке си примечания литература ссылки