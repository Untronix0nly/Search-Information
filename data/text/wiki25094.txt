objective компилируемый объектно ориентированный язык используемый корпорацией apple построенный на основе языка си парадигм smalltalk частности объектная модель построена стиле smalltalk то есть объектам посылаются сообщения язык objective является надмножеством языка си поэтому си код полностью понятен компилятору objective компилятор objective входит gcc доступен на большинстве основных платформ язык используется первую очередь для mac os cocoa gnustep реализаций объектно интерфейса openstep также язык используется для ios cocoa touch история начале годов было популярно структурное позволяющее разделить алгоритм на небольшие блоки однако ростом сложности задач структурное приводило снижению качества кода приходилось писать всё больше функций которые очень редко могли использоваться других программах многие увидели объектно ориентированном потенциальное решение возникшей проблемы одной стороны smalltalk использовали почти все более менее сложные системы другой использование виртуальных машин повышало требования ресурсам objective был создан брэдом коксом начале его компании stepstone он пытался решить проблему повторного использования кода целью кокса было создание языка поддерживающего концепцию software ic подразумевающей возможность собирать программы из готовых компонентов объектов подобно тому как сложные электронные устройства могут быть собраны из набора готовых интегральных микросхем при этом язык должен быть простым основанным на языке чтобы облегчить переход разработчиков на него одной из целей было также создание модели которой сами классы являются полноценными объектами поддерживалась бы интроспекция динамическая обработка сообщений objective является расширением любая программа на является программой на objective одной из отличительных черт objective является динамичность решения обычно принимаемые на этапе компиляции здесь откладываются до этапа выполнения objective message oriented язык то время как function oriented objective вызовы метода не как вызов функции хотя этому обычно все сводится как посылка сообщения именем аргументами объекту подобно тому как это происходит smalltalk любому объекту можно послать любое сообщение объект может вместо обработки сообщения переслать его другому объекту для обработки делегирование частности так можно реализовать распределённые то есть находящиеся различных адресных пространствах даже на разных компьютерах объекты привязка сообщения соответствующей функции происходит на этапе выполнения язык objective поддерживает работу метаинформацией так на этапе выполнения можно узнать класс объекта список его методов типами передаваемых аргументов instance переменных проверить является ли класс потомком заданного поддерживает ли он заданный протокол языке есть поддержка протоколов понятия интерфейса объекта протокола четко разделены поддерживается наследование не множественное для протоколов поддерживается множественное наследование объект может быть унаследован от другого объекта сразу нескольких протоколов хотя это скорее не наследование протокола его поддержка на данный момент язык objective поддерживается компиляторами clang gcc под управлением windows используется составе mingw или cygwin некоторые функции языка перенесены runtime библиотеку сильно зависят от неё вместе компилятором gcc поставляется минимальный вариант такой библиотеки также можно свободно скачать runtime библиотеку компании apple apple objective runtime эти две runtime библиотеки похожи основные отличия именах методов далее примеры будут ориентироваться на runtime библиотеку apple синтаксис языка языке objective для обозначения объектов используется специальный тип id это аналог типа object java переменная типа id фактически является указателем на произвольный объект для обозначения нулевого указателя на объект используется константа nil null при этом вместо id можно использовать более привычное обозначение явным указанием класса частности последнее позволяет компилятору осуществлять некоторую проверку поддержки сообщения объектами если компилятор из типа переменной не может сделать вывод поддержке объектом данного сообщения то он выдаст предупреждение тем самым язык поддерживает проверку типов но нестрогой форме то есть найденные несоответствия возвращаются как предупреждения не ошибки для посылки сообщений используется следующий синтаксис receiver message этой конструкции receiver является указателем на объект message именем метода отличие от языка посылка сообщения nil является законной операцией всегда возвращающей нулевое значение nil сообщение может также содержать параметры myrect setorigin этом примере именем метода сообщения является setorigin обратите внимание что каждому передаваемому аргументу соответствует ровно одно двоеточие при этом приведенном примере первый аргумент имеет метку текст перед двоеточием второй нет язык objective позволяет снабжать метками каждый аргумент что заметно повышает читаемость кода снижает вероятность передачи неправильного параметра именно такой стиль принят большинством разработчиков myrect setwidth height этом примере качестве имени сообщения выступает setwidth height также поддерживается возможность передачи произвольного количества аргументов сообщении myobject makegroup obj obj obj obj nil как функции сообщения могут возвращать значения при этом отличие от языка типом значения возвращаемым по умолчанию является id float area myrect area результат одного сообщения можно сразу же использовать другом сообщении myrect setcolor otherrect color как уже говорилось objective классы сами являются объектами основной задачей таких объектов называемых class objects является создание экземпляров данного класса это очень похоже на паттерн abstract factory при этом само имя класса играет двойную роль одной стороны оно выступает как тип данных то есть он может быть использован для описания указателей на объекты данного класса другой стороны имя класса может выступать качестве объекта которому посылается сообщение сообщениях имя класса может принимать участие только как receiver rect myrect rect alloc init языке objective нет встроенного типа для булевских величин поэтому обычно такой тип вводится искусственно далее для логических величин будет использоваться тип bool возможными значениями yes no как это делается операционных системах nextstep mac os первым достаточно серьёзным применением языка objective было его использование операционной системе nextstep для этой системы было написано большое количество различных классов на objective многие из которых до сих пор используются mac os имена всех этих классов начинаются префикса ns обозначающего свою принадлежность операционной системе nextstep сейчас они входят библиотеку foundation на которой строятся приложения для os ios одним из них nsstring мы столкнемся данной статье этот класс служит для работы со строками при этом качестве внутреннего представления символов используется юникод компилятор поддерживает данный тип автоматически переводя конструкции вида my string указатель на объект класса nsstring содержащий данную строку точнее его подкласса константным строкам свойства допустим классе company существует instance переменная name interface company nsobject nsstring name для доступа ней извне лучше всего воспользоваться свойствами которые появились objective для объявления свойств используется ключевое слово property property retain nsstring name скобках перечисляются атрибуты доступа instance переменной атрибуты разделяются на основные группы имена акцессора мутатора getter gettername используется для задания имени функции используемой для извлечения значения instance переменной setter settername используется для задания имени функции используемой для установки значения instance переменной ограничение чтения записи readwrite свойства есть как акцессор так мутатор является атрибутом по умолчанию readonly свойства есть только акцессор эти атрибуты взаимоисключают друг друга последняя группа атрибуты мутатора assign для задания нового значения используется оператор присваивания используется только для pod типов либо для объектов которыми мы не владеем retain указывает на то что для объекта используемого качестве нового значения instance переменной управление памятью происходит вручную не забываем потом освободить память copy указывает на то что для присваивания будет использована копия переданного объекта weak аналог assign при применении режима автоматического подсчёта ссылок arc должен поддерживаться компилятором strong аналог retain при применении режима автоматического подсчёта ссылок arc должен поддерживаться компилятором при работе под gc никакой разницы между использованием assign retain copy нет для создания кода свойств соответствии тем как они описаны объявлении можно воспользоваться автогенерацией кода synthesize name автоматически созданный код не всегда подходящее решение может потребоваться создание методов доступа instance переменным вручную язык часто критикуют за перегруженный по сравнению другими языками синтаксис однако при этом нередко отмечается его более высокая читабельность создание новых классов все ключевые слова языка objective отсутствующие начинаются символа как описание класса его реализация разделены обычно описание помещается заголовочные файлы расширением реализации файлы расширением ниже приводится общая структура описания нового класса interface classname superclass instance variable declarations method declarations end версии runtime от apple все классы имеют общего предка класс nsobject содержащий целый ряд важных методов описание переменных ничем не отличается от описания переменных структурах языке если вас не apple то скорее всего вместо nsobject вам потребуется object import interface rect nsobject float width float height bool isfilled nscolor color end описания же методов заметно отличаются от принятых очень сильно похожи на описания методов языке smalltalk каждое описание начинается со знака плюс или минус знак плюс обозначает что данный метод является методом класса то есть его можно посылать только class object не экземплярам данного класса фактически методы класса являются аналогами статических методов классах языке знак минус служит для обозначения методов объектов экземпляров данного класса обратите внимание что objective все методы являются виртуальными то есть могут быть переопределены ниже приводятся описания возможных методов для класса rect interface rect nsobject float float width float height bool isfilled nscolor color newrect void display float width float height float area void setwidth float thewidth void setheight float theheight void setx float thex float they end обратите внимание что имя метода может совпадать именем instance переменной данного класса например width height тип возвращаемого методом значения указывается круглых скобках сразу же после знака плюс или минус но перед названием метода если тип не указан то считается что возвращается значение типа id далее идет имя метода где после каждого двоеточия задается тип аргумента круглых скобках сам аргумент язык objective позволяет для аргументов метода задавать также один из следующих описателей oneway in out inout bycopy byref данные описатели служат для задания направления передачи данных способа передачи их наличие заметно упрощает реализацию работу распределенными объектами которые были реализованы операционной системе nextstep началу годов прошлого века метод принимающий произвольное количество параметров может быть описан следующим образом makegroup id object для подключения заголовочного файла objective вместо директивы include используется директива import аналогичная include но гарантирующая что данный файл будет подключен всего один раз ряде случаев возникает необходимость объявлении того что данное имя является именем класса но без явного его описания такая необходимость возникает при описании двух классов каждый из которых ссылается на другой класс этом случае можно воспользоваться директивой class объявляющей что следующие за ней имена являются именами классов class shape rect oval реализация методов класса выглядит следующим образом import classname implementation classname method implementations end ниже приводится пример реализации методов класса rect описанного выше import rect implementation rect newrect rect rect rect alloc init rect setwidth rect setheight rect setx return rect float width return width float height return height float area return self width self height void setwidth float thewidth width thewidth void setheight float theheight height theheight void setx float thex float they thex they end как видно из примера выше методах доступны все instance переменные однако как есть возможность управлять видимостью переменных видимостью методов управлять нельзя при помощи директив private protected public действующих полностью аналогично языку interface worker nsobject char name private int age char evaluation protected int job float wage public id boss при этом public переменным класса можно обращаться непосредственно используя оператор например objptr fieldname как работает механизм сообщений компилятор переводит каждую посылку сообщения то есть конструкцию вида object msg вызов функции objc_msgsend эта функция качестве своего первого параметра принимает указатель на объект получатель сообщения качестве второго параметра выступает селектор служащий для идентификации посылаемого сообщения если сообщении присутствуют аргументы то они также передаются objc_msgsend как третий четвёртый параметры каждый объект objective содержит себе атрибут isa указатель на class object для данного объекта class object автоматически создается компилятором существует как один экземпляр на который через isa ссылаются все экземпляры данного класса каждый class object обязательно содержит себе указатель на class object для родительского класса superclass dispatch table последняя представляет собой словарь сопоставляющий селекторам сообщений фактические адреса реализующих их методов функций таким образом функция objc_msgsend ищет метод данным селектором dispatch table для данного объекта если его там нет то поиск продолжается dispatch table для его родительского класса если метод то есть соответствующая ему функция находится то осуществляется его вызов передачей всех необходимых аргументов противном случае объекту дается последний шанс обработать сообщение перед вызовом исключения селектор сообщения вместе параметрами заворачивается специальный объект типа nsinvocation объекту посылается сообщение где качестве параметра выступает объект класса nsinvocation если объект поддерживает то он может либо сам обработать посылаемое сообщение либо переслать другому объекту для обработки void nsinvocation aninvocation if someotherobject aninvocation selector aninvocation someotherobject else для ускорения поиска сообщений по dispatch table используется кэширование позволяющее заметно снизить затраты на пересылку сообщений также облегчает поиск метода по таблицам использование так называемых селекторов вместо обычных имен обычно селектор представляет собой битовую величину позволяющую однозначно метод тип селектора обозначается как sel существует ряд функций конструкций позволяющих осуществлять преобразование имени селектор обратно так для получения селектора сообщения непосредственно по имени служит конструкция selector sel setwidth selector setwidth sel setpos selector setposition для получения селектора по строке символов на этапе выполнения перевода селектора строку служат функции sel setwidth setwidth nsstring methodname setpos мощная поддержка метаинформации objective позволяет прямо на этапе выполнения проверить поддерживает ли объект метод данным селектором при помощи посылки ему сообщения if anobject selector setwidth anobject setwidth довольно легко можно послать сообщение соответствующее данному селектору без аргументов одним двумя или тремя аргументами при помощи метода performselector performselector withobject performselector withobject withobject performselector withobject withobject withobject так далее myobject performselector sel withobject nil обратите внимание что методы performselector всегда возвращают значение типа id можно получить класс для данного объекта послав ему сообщение class это сообщение возвращает класс виде указателя на объект типа class class cls anobject class nsstring clsname cls другой стороны также можно легко получить соответствующий class object по имени класса class cls clsname каждый метод фактически представляет собой функцию двумя невидимыми аргументами self первый является аналогом this то есть указывает на сам объект получатель сообщения второй содержит селектор данного метода аргумент self может использоваться для посылки сообщений самому себе как например следующем методе float area return self width self height однако кроме self есть ещё одна величина которой могут посылаться сообщения super на самом деле super не является нормальной переменной это всего лишь ещё одно обозначение для указателя на текущий объект но при посылке сообщения super поиск метода начинается не dispatch table текущего объекта dispatch table родительского объекта таким образом посылая сообщения super мы тем самым вызываем старые версии методов данным классом языке objective можно по селектору метода получить адрес реализующей его функции именно как функции языка такая функция отличается от описания метода только вставкой начало списка аргументов двух дополнительных параметров указателя на сам объект self селектора данного метода послав объекту сообщение мы получаем ответ адрес реализующей этот метод функции typedef float widthfunc id sel typedef void setwidthfunc id sel float widthfunc widthfunc widthfunc myrect selector width setwidthfunc setwidthfunc setwidthfunc myrect selector setwidth setwidthfunc myrect selector setwidth это позволяет при необходимости многократного вызова одного того же метода заданного объекта полностью избежать всех расходов связанных пересылкой сообщений протоколы язык objective содержит полноценную поддержку протоколов это аналог интерфейса java абстрактного класса который также иногда принято называть интерфейсом протокол представляет собой просто список описаний методов объект реализует протокол если он содержит реализации всех методов описанных протоколе протоколы удобны тем что позволяют выделять общие черты разнородных объектов передавать информацию об объектах заранее неизвестных классов простейшее описание протокола выглядит следующим образом protocol protocolname method declarations end так протокол serializable может быть описан следующим образом protocol serializable id initwithcoder nscoder coder void encodewithcoder nscoder coder end протокол может быть унаследован от произвольного количества других протоколов protocol myproto точно также можно при описании класса задать не только родительский класс но набор протоколов interface myclass superclass для проверки во время выполнения программы поддерживается ли объектом заданный протокол объектов можно использовать сообщение if myobject protocol serializable myobject encodewithcoder mycoder кроме того имя протокола протоколов можно использовать при описании переменных для явного указания компилятору поддержке объектами протокола протоколов так если переменная myobject содержит указатель на объект заранее неизвестного класса но при этом удовлетворяющий протоколам serializable drawable то её можно описать следующим образом id myobject точно так же если заранее известно что myobject будет содержать указатель на объект унаследованный от класса shape поддерживающего протокол serializable то эту переменную можно описать следующим образом shape myobject обратите внимание что подобное описание служит только для сообщения компилятору какие сообщения поддерживает данный объект как классы все протоколы objective представлены при помощи объектов класса protocol protocol myproto protocol serializable для объявления протоколов можно использовать следующую конструкцию protocol myproto serializable drawable эта конструкция сообщает компилятору том что myproto serializable drawable являются именами протоколов которые будут определены позже обработка исключений языке objective поддерживается обработка исключений очень похожая на используемую языках java для этого служат директивы try catch finally throw cup cup cup alloc init try cup fill catch nsexception exc nslog exception caught exc catch id exc nslog unknown exception caught finally cup release для запуска исключения используется директива throw качестве аргумента берущая указатель на объект исключение обычно mac os nextstep для этой цели используются объекты класса nsexception nsexception exc nsexception my exception reason unknown error userinfo nil throw exc внутри catch блоков директива throw может использоваться без параметра для повторного запуска обрабатываемого исключения rethrowing exception синхронизация язык objective поддерживает синхронизацию для многопоточных приложений при помощи директивы synchronized можно защитить фрагмент кода от одновременного выполнения сразу несколькими потоками synchronized берёт на вход указатель на объект языка objective можно использовать для этой цели любой объект том числе self который играет роль мьютекса mutex при попытке потока начать выполнение защищенного фрагмента проверяется выполняется ли уже этот фрагмент каким либо потоком если да то сравниваются объекты переданные этими потоками synchronized если эти указатели совпадают то поток пытающийся войти защищенный блок будет приостановлен suspended до тех пор пока первый поток не выйдет из блока тогда выполнение второго потока продолжится уже он запрёт этот блок для всех остальных потоков наличие подобной возможности заметно облегчает жизнь при написании многопоточных приложений когда необходимо отслеживать попытки одновременного изменения одних тех же данных сразу несколькими потоками void criticalmethod synchronized self perform modifications to shared objects качестве мьютекса параметра инструкции synchronized рекомендуется указывать объект недоступный извне поскольку это может привести взаимной блокировке если один тот же объект используется качестве мьютекса двумя потоками частности не рекомендуется synchronized self создание уничтожение объектов самом языке objective нет специальных команд для создания уничтожения объектов подобных new delete эта задача ложится на runtime библиотеку реализуется при помощи механизма посылки сообщений реально используемой наиболее широко схемой создания уничтожения объектов objective является используемая операционных системах nextstep mac os которая будет описана ниже создание нового объекта разбивается на два шага выделение памяти инициализация объекта первый шаг реализуется методом класса alloc реализованном классе nsobject который выделяет необходимое количество памяти данный метод используется для выделения памяти не только для объектов класса nsobject но любого унаследованного от него класса при этом атрибут isa записывается указатель на class object класса обратите внимание что сообщение alloc посылается class object требуемого класса это сообщение возвращает указатель на выделенную под объект память собственно сама инициализация объекта то есть установка значений его instance переменных выделение дополнительных ресурсов осуществляется другими методами по традиции имена этих методов начинаются init обычно такое сообщение посылается сразу же после сообщение alloc по адресу возвращенному этим сообщением id anobject rectangle alloc init приведённая выше конструкция является правильным способом создания объекта обратите внимание что следующая конструкция может ряде случаев не работать id anobject rectangle alloc anobject init это связано тем что для ряда классов метод init может вернуть совсем другой указатель не self простейшими примерами того когда может возникать подобная ситуация являются синглтоны тогда если один экземпляр класса уже существует то метод init освободит выделенную alloc ом память вернет указатель на уже созданный единственный экземпляр кэширование объектов когда для увеличения выделение объектов происходит сразу блоками объекты не уничтожаются сохраняются для при создании нового класса обычно нет необходимости переопределять метод alloc вот необходимость переопределения метода init возникает достаточно часто обратите внимание что метод init является обычным методом ничем не выделяющимся среди остальных отличие от где конструктор это особый метод которого например нельзя взять адрес поэтому при создании нового класса метода init вызов метода init при помощи super init должен быть произведен явно самом начале метода довольно часто объектов бывает сразу несколько методов начинающихся init например init initwithname установившейся практикой таком случае является выделение среди всех init методов одного называемого designated initializer все остальные init методы должны вызывать его только он вызывает унаследованный init метод id initwithname const char thename designated initializer self super init call inherited method if self name strdup thename return self id init return self initwithname ряде случаев оказывается удобным совместить выделение памяти инициализацию объекта один метод класса например классе nsstring есть ряд методов класса возвращающих уже готовый объект id const char cstring encoding enc id nsstring format mac os как nextstep для управления временем жизни объектов используют reference counting каждый объект содержит внутри себя некоторый счетчик при создании устанавливаемый единицу посылка объекту сообщения retain увеличивает значение этого счетчика на единицу так все контейнерные классы библиотеки foundation при помещении них объекта посылают ему сообщение retain установившейся практикой является посылка объекту сообщения retain всеми нём сторонами объектами то есть если вы запоминаете ссылку на объект то следует послать ему сообщение retain когда объект перестает быть нужен то ему просто посылается сообщение release данное сообщение уменьшает значение счетчика на единицу если это значение стало меньше единицы уничтожает данный объект перед уничтожением объекта ему посылается сообщение dealloc позволяющее объекту произвести свою деинициализацию при этом это также является обычным сообщением нём вы явно должны конце вызвать унаследованную реализацию через super dealloc void dealloc super dealloc управление памятью базовые принципы управление памятью objective базируется на принципе владения объектом основные правила управления памятью objective можно записать так для получения объекта во владение необходимо вызвать метод содержащий названии alloc new либо copy например alloc newobject mutablecopy для освобождения объекта который был получен при помощи перечисленных выше функций необходимо вызвать функцию release либо autorelease во всех остальных случаях освобождение объекта не требуется если полученный объект должен быть сохранен необходимо либо стать его владельцем вызвав retain либо создать его копию вызов содержащий названии copy данные правила базируются на соглашении по именованию objective то же время сами являются основой этого соглашения базовые принципы на практике предположим программе существует класс company которого есть метод workers interface company nsobject nsarray workers nsarray workers end рассмотрим небольшой пример использования такого класса company company company alloc init nsarray workers company workers company release так как объект класса company создается явно он должен быть удален по окончании использования company release то же время название метода workers не говорит том кто должен удалять массив такой ситуации считается что списком работников управляет объект компания его удалять не требуется convenience конструкторы многие классы позволяют совместить создание объекта его инициализацией при помощи методов называемых convenience конструкторы такие методы обычно называются classname можно предположить что вызывающая сторона ответственна за управление временем жизни объекта но подобное поведение противоречило бы соглашению по именованию objective company company company company company release приведенном коде вызов company release недопустим так как данном случае управление временем жизни объекта должно осуществляться при помощи autorelease пула ниже приводится пример корректной реализации метода company company company id ret company alloc init return ret autorelease autorelease вернемся методу workers класса company так как возвращается массив временем жизни которого вызывающая сторона не управляет реализация метода workers будет выглядеть приблизительно так nsarray workers nsarray copy nsarray alloc initwitharray workers return copy autorelease вызов autorelease добавляет объект copy autorelease пул вследствие чего возвращаемый объект получит сообщение release при удалении пула который он был добавлен если объекту добавленному autorelease пул послать сообщение release самостоятельно при удалении autorelease пула возникнет ошибка возвращение объекта по ссылке ряде случаев объекты возвращаются по ссылке например метод класса nsdata options error качестве параметра error принимает nserror errorptr этом случае так же работает соглашение по именованию из которого следует что явного запроса на владение объектом нет соответственно удалять его не требуется удаление объектов когда счетчик ссылок объекта становится равным нулю объект удаляется при этом объекта вызывается метод void dealloc если объекте содержатся какие то данные их необходимо удалить этой функции void dealloc workers release super dealloc после того как всем переменным класса было послано сообщение release необходимо вызвать метод dealloc базового класса это единственный случай котором допустим вызов метода dealloc напрямую не существует никаких гарантий относительно времени вызова метода dealloc ряде случаев он вообще может не вызываться при завершении работы приложения для экономии времени так как по завершении приложения ос любом случае освободит выделенную память соответственно методе dealloc не должно располагаться никаких методов отвечающих за закрытие сокетов файлов autorelease pool autorelease пул используется для хранения объектов которым будет послано сообщение release при удалении пула для того чтобы добавить объект autorelease пул ему необходимо отправить сообщение autorelease приложениях cocoa autorelease пул всегда доступен по умолчанию для не appkit приложений необходимо создавать управлять временем жизни autorelease пула самостоятельно autorelease пул реализуется классом int main int argc const char argv pool alloc init company company company company nsarray workers company workers pool drain return удалить объекты из autorelease пула можно не только посредством отправки пулу сообщения release но помощью сообщения drain поведение release drain среде подсчетом ссылок идентично но случае работы gc среде drain вызывает функцию autorelease пул многопоточной среде cocoa для каждого из потоков создается свой собственный autorelease пул по завершении потока autorelease пул уничтожается всем содержащимся нём объектам посылается сообщение release autorelease пул главного потока периодически пересоздается целью уменьшения используемой памяти приложением во всех остальных потоках заниматься пересозданием autorelease пула необходимо самостоятельно что крайне актуально для долгоживущих потоков копирование объектов все объекты objective потенциально поддерживают копирование для того чтобы создать копию объекта необходимо вызвать метод copy определённый классе nsobject для создания копии будет вызван метод copywithzone протокола nscopying nsobject не имеет поддержки этого протокола при необходимости протокол nscopying должен быть реализован классах наследниках копии бывают двух видов поверхностная копия shallow copy полная копия deep copy разница между этими копиями состоит том что при создании поверхностной копии копируются не данные ссылка на объект данными случае полной копии копируется объект данными пример реализации реализация копирования может различаться зависимости от того поддерживает ли класс родитель протокол nscopying пример кода для ситуации когда родитель не реализует протокол nscopying interface company nsobject nsstring name property retain nsstring name id copywithzone nszone zone end implementation company synthesize name id copywithzone nszone zone id copy self class allocwithzone zone init copy setname self name return copy end если родитель поддерживает протокол nscopying реализация будет несколько иной вызов allocwithzone заменяется на copywithzone id copy super copywithzone zone копирование неизменяемых объектов для immutable объектов создание копии нецелесообразно можно ограничиться отправкой самому себе сообщения retain id copywithzone nszone zone return self retain категории язык objective обладает возможностью добавлять новые методы уже существующим классам аналогичной возможностью обладают языки ruby javascript другие при этом не требуется исходников класса добавленные методы автоматически становятся доступными всем классам унаследованным от изменяемого так можно добавить новый метод классу nsobject этот метод автоматически добавится во все остальные классы механизм позволяющий расширять уже существующие классы путём добавления новых методов новые instance переменные добавить таким образом нельзя называется категорией категория имеет своё имя список методов имя класса который она расширяет описание категории имеет следующий вид import classname interface classname categoryname methods declarations end реализация категории выглядит следующим образом import categoryname implementation classname categoryname methods bodies end помощью категорий можно создавать свойства property которые будут доступны только для чтения другим классам readwrite внутри своего класса interface classname bool flag property assign readonly bool flag end import classname implementation classname пустая категория property assign readwrite bool flag end implementation classname synthesize flag void someaction self flag yes end кроме всего прочего категории можно использовать для того чтобы обеспечить реализацию классом какого либо нового протокола например protocol printable сущности которые можно распечатать void print end interface nsstring printable добавляем системному классу nsstring возможность быть распечатанным end implementation nsstring printable реализуем новую void print nslog меня распечатали self end это избавляет от необходимости писать класс адаптер printablestring для nsstring class objects objective runtime при компиляции программы на языке objective компилятор для каждого введённого класса автоматически создаёт так называемый class object полноценный объект содержащий себе всю информацию данном классе включая название суперкласс список методов instance переменных при этом такой объект является полноценным объектом то есть ему можно посылать сообщения передавать качестве параметра одной из особенностей class object является поддержка всех методов класса nsobject то есть при отправке сообщения поиск по селектору сначала ведётся среди методов класса если метод не найден поиск продолжается среди instance методов класса nsobject ещё одной особенностью является возможность инициализации class object ов начале работы приложения каждому class object посылается сообщение класса initialize это сообщение гарантированно посылается каждому class object причём всего один раз до того как ему будет послано любое другое сообщение простейшим примером применения такого сообщения является реализация singleton ов именно методе initialize следует создать тот самый единственный экземпляр объекта запомнить его static переменной objective runtime от apple содержит большое количество функций служащих для работы классами непосредственно во время выполнения программы наиболее интересными являются следующие method class aclass sel aselector method class aclass sel aselector struct class theclass void iterator void class aclass struct methodlist void class aclass struct methodlist unsigned method method unsigned method method unsigned method method int argindex const char type int offset ivar class aclass const char avariablename функция возвращает указатель на структуру objc_method описывающую заданный instance метод данного класса функция возвращает указатель на структуру objc_method описывающую заданный метод данного класса функция возвращает один из списков методов для заданного класса приводимый ниже фрагмент кода позволяет перебрать все методы для данного класса void iterator struct methodlist each call to returns one methodlist methodlist classobject iterator while methodlist nil do something with the method list here methodlist classobject iterator функция позволяет добавлять новые методы заданному классу функция позволяет убирать методы из заданного класса функция возвращает количество аргументов для заданного метода функция возвращает размер места на стеке занимаемого всеми аргументами данного метода функция возвращает информацию об одном из аргументов для заданного метода функция возвращает информацию об instance переменной класса виде указателя на структуру objc_ivar для кодирования информации типах используется специальное строковое представление однозначно сопоставляющее каждому типу данных некоторую строку явно получить такую строку для произвольного типа можно при помощи конструкции encode char buf encode int char buf encode struct key char buf encode rectangle разное официальный сайт apple главный источник информации языке форум разработчиков примеры кода полная версия документации доступны только разработчикам ide xcode основное средство разработки на языке objective ide поддерживает только ос mac os бесплатно через магазин приложений apple app store полезную информации по языку objective можно найти news группе архивах списка рассылки проект gnustep попытка создания аналогов закрытых библиотек foundation appkit используемых nextstep mac os исходный код библиотек написан на языке objective бесплатно на сайте проекта доступны примеры использования языка исходный код нескольких приложений objective доступен практически каждом дистрибутиве gnu linux благодаря компилятору gobjc созданному проектом gcc для работы objective под ос windows используют эмуляторы среды posix бесплатные mingw cygwin сервисы microsoft windows для unix примечания литература ссылки ресурсы форум стивена кохана посвященный objective мост для работы objective из среды выполнения net macintosh mono статьи introduction to the objective programming language apple developer connection pdf изучаем objective букварь язык objective advanced flow control for objective debugging family languages fun with the objective runtime objective for programmers перевод steve kochan on the evolution of objective the dynamic languages renaissance категория языки семейства категория объектно ориентированные языки категория языки динамической типизацией категория свободные компиляторы интерпретаторы категория программное обеспечение apple категория next категория gnustep