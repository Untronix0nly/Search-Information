быстрая сортировка сортировка хоара часто называемая по имени стандартной библиотеке языка си широко известный алгоритм сортировки разработанный английским информатиком чарльзом хоаром во время его работы мгу году один из самых быстрых известных универсальных алгоритмов сортировки массивов среднем обменов при упорядочении элементов из за наличия ряда недостатков на практике обычно используется некоторыми доработками общее описание quicksort является существенно улучшенным вариантом алгоритма сортировки помощью прямого обмена его варианты известны как пузырьковая сортировка шейкерная сортировка известного том числе своей низкой эффективностью принципиальное отличие состоит том что первую очередь производятся перестановки на наибольшем возможном расстоянии после каждого прохода элементы делятся на две независимые группы любопытный факт улучшение самого неэффективного прямого метода сортировки дало результате один из наиболее эффективных улучшенных методов общая идея алгоритма состоит следующем выбрать из массива элемент называемый опорным это может быть любой из элементов массива от выбора опорного элемента не зависит корректность алгоритма но отдельных случаях может сильно зависеть его эффективность см ниже сравнить все остальные элементы опорным переставить их массиве так чтобы разбить массив на три непрерывных отрезка следующие друг за другом меньшие опорного равные большие для отрезков меньших больших значений выполнить рекурсивно ту же операций если длина отрезка больше единицы на практике массив обычно делят не на три на две части например меньшие опорного равные большие такой подход общем случае эффективнее так как упрощает алгоритм разделения см ниже хоар разработал этот метод применительно машинному переводу словарь хранился на магнитной ленте сортировка слов обрабатываемого текста позволяла получить их переводы за один прогон ленты без перемотки её назад алгоритм был придуман хоаром во время его пребывания советском союзе где он обучался московском университете компьютерному переводу занимался разработкой русско английского разговорника алгоритм пример быстрой сортировки здесь опорным является последний элемент массива ячейка чёрного цвета что отсортированных массивах может приводить ухудшению общий механизм сортировки быстрая сортировка относится алгоритмам разделяй властвуй алгоритм состоит из трёх шагов выбрать элемент из массива назовём его опорным разбиение элементов массиве таким образом что элементы меньше опорного помещаются перед ним больше или равные после рекурсивно применить первые два шага двум подмассивам слева справа от опорного элемента рекурсия не применяется массиву котором только один элемент или отсутствуют элементы наиболее общем виде алгоритм на псевдокоде где сортируемый массив lo hi соответственно нижняя верхняя границы сортируемого участка этого массива выглядит следующим образом algorithm quicksort lo hi is if lo pivot создать массив элементами больше опорного return quicksort la pivot quicksort ra вернуть массив состоящий из отсортированной левой части опорного отсортированной правой части на практике она не используется служит лишь образовательных целях так как использует дополнительную память чего можно избежать выбор опорного элемента ранних реализациях как правило опорным выбирался первый элемент что снижало на отсортированных массивах для улучшения эффективности может выбираться средний случайный элемент или для больших массивов медиана первого среднего последнего элементов медиана всей является оптимальным опорным элементом но её вычисление слишком трудоёмко для использования сортировке выбор опорного элемента по медиане трёх для разбиения ломуто mid lo hi if amid каждый раз когда находится элемент меньше или равный опорному индекс увеличивается элемент вставляется перед опорным хоть эта схема разбиения проще компактнее чем схема хоара она менее эффективна используется обучающих материалах сложность данной быстрой сортировки падает до когда массив уже отсортирован или все его элементы равны существуют различные методы оптимизации данной сортировки алгоритмы выбора опорного элемента использование сортировки вставками на маленьких массивах данном примере сортируются элементы массива от до включительно algorithm partition lo hi is pivot ahi lo for lo to hi do if aj pivot then swap ai with aj swap ai with ahi return сортировка всего массива может быть выполнена помощью выполнения разбиение хоара данная схема использует два индекса один начале массива другой конце которые приближаются друг другу пока не найдётся пара элементов где один больше опорного расположен перед ним второй меньше расположен после эти элементы меняются местами обмен происходит до тех пор пока индексы не пересекутся алгоритм возвращает последний индекс схема хоара эффективнее схемы ломуто так как происходит среднем три раза меньше обменов swap элементов разбиение эффективнее даже когда все элементы равны подобно схеме ломуто данная схема также показывает эффективность когда входной массив уже отсортирован сортировка использованием данной схемы нестабильна следует заметить что конечная позиция опорного элемента необязательно совпадает возвращённым индексом псевдокод algorithm partition lo hi is pivot alo lo hi loop forever do while ai pivot if then return swap ai with aj повторяющиеся элементы для улучшения при большом количестве одинаковых элементов массиве может быть применена процедура разбиения массива на три группы элементы меньшие опорного равные ему больше него бентли макилрой называют это толстым разбиением данное разбиение используется функции седьмой версии unix псевдокод algorithm quicksort lo hi is if lo оценка сложности алгоритма ясно что операция разделения массива на две части относительно опорного элемента занимает время поскольку все операции разделения проделываемые на одной глубине рекурсии обрабатывают разные части исходного массива размер которого постоянен суммарно на каждом уровне рекурсии потребуется также операций следовательно общая сложность алгоритма определяется лишь количеством разделений то есть глубиной рекурсии глубина рекурсии свою очередь зависит от сочетания входных данных способа определения опорного элемента лучший случай наиболее варианте при каждой операции разделения массив делится на две одинаковые плюс минус один элемент части следовательно максимальная глубина рекурсии при которой размеры обрабатываемых подмассивов достигнут составит результате количество сравнений совершаемых быстрой сортировкой было бы равно значению рекурсивного выражения что даёт общую сложность алгоритма среднее среднюю сложность при случайном распределении входных данных можно оценить лишь вероятностно прежде всего необходимо заметить что необязательно чтобы опорный элемент всякий раз делил массив на две одинаковых части например если на каждом этапе будет происходить разделение на массивы длиной от исходного глубина рекурсии будет равна это по прежнему даёт сложность вообще при любом фиксированном соотношении между левой правой частями разделения сложность алгоритма будет той же только разными константами будем считать удачным разделением такое при котором опорный элемент окажется среди центральных элементов разделяемой части массива ясно вероятность удачи при случайном распределении элементов составляет при удачном разделении размеры выделенных подмассивов составят не менее не более от исходного поскольку каждый выделенный подмассив также будет иметь случайное распределение все эти рассуждения применимы любому этапу сортировки любому исходному фрагменту массива удачное разделение даёт глубину рекурсии не более поскольку вероятность удачи равна для получения удачных разделений среднем потребуется рекурсивных вызовов чтобы опорный элемент раз оказался среди центральных массива применяя эти соображения можно заключить что среднем глубина рекурсии не превысит что равно поскольку на каждом уровне рекурсии по прежнему выполняется не более операций средняя сложность составит худший случай самом варианте каждое разделение даёт два подмассива размерами то есть при каждом рекурсивном вызове больший массив будет на короче чем предыдущий раз такое может произойти если качестве опорного на каждом этапе будет выбран элемент либо наименьший либо наибольший из всех обрабатываемых при простейшем выборе опорного элемента первого или последнего массиве такой эффект даст уже отсортированный прямом или обратном порядке массив для среднего или любого другого фиксированного элемента массив худшего случая также может быть специально подобран этом случае потребуется операций разделения общее время работы составит операций то есть сортировка будет выполняться за квадратичное время но количество обменов соответственно время работы это не самый большой его недостаток хуже то что таком случае глубина рекурсии при выполнении алгоритма достигнет что будет означать кратное сохранение адреса возврата локальных переменных процедуры разделения массивов для больших значений худший случай может привести исчерпанию памяти переполнению стека во время работы программы достоинства недостатки достоинства один из самых на практике из алгоритмов внутренней сортировки общего назначения прост реализации требует лишь дополнительной памяти для своей работы не улучшенный рекурсивный алгоритм худшем случае памяти хорошо сочетается механизмами кэширования виртуальной памяти допускает естественное сортировка выделенных подмассивов параллельно выполняющихся подпроцессах допускает эффективную модификацию для сортировки по нескольким ключам частности алгоритм седжвика для сортировки строк благодаря тому что процессе разделения автоматически выделяется отрезок элементов равных опорному этот отрезок можно сразу же сортировать по следующему ключу работает на связных списках других структурах доступом допускающих эффективный проход как от начала концу так от конца началу недостатки сильно деградирует по скорости до худшем или близком нему случае что может случиться при неудачных входных данных прямая реализация виде функции двумя рекурсивными вызовами может привести ошибке переполнения стека так как худшем случае ей может потребоваться сделать вложенных рекурсивных вызовов неустойчив улучшения улучшения алгоритма направлены основном на устранение или смягчение вышеупомянутых недостатков вследствие чего все их можно разделить на три группы придание алгоритму устойчивости устранение деградации специальным выбором опорного элемента защита от переполнения стека вызовов из за большой глубины рекурсии при неудачных входных данных проблема неустойчивости решается путём расширения ключа исходным индексом элемента массиве случае равенства основных ключей сравнение производится по индексу исключая таким образом возможность изменения взаимного положения равных элементов эта модификация не бесплатна она требует дополнительно памяти одного полного прохода по массиву для сохранения исходных индексов деградация по скорости случае неудачного набора входных данных решается по двум разным направлениям снижение вероятности возникновения худшего случая путём специального выбора опорного элемента применение различных технических приёмов обеспечивающих устойчивую работу на неудачных входных данных для первого направления выбор среднего элемента устраняет деградацию для предварительно отсортированных данных но оставляет возможность случайного появления или намеренного подбора плохого массива выбор медианы из трёх элементов первого среднего последнего снижает вероятность возникновения худшего случая по сравнению выбором среднего элемента случайный выбор вероятность случайного возникновения худшего случая становится исчезающе малой намеренный подбор практически неосуществимым ожидаемое время выполнения алгоритма сортировки составляет lg недостаток всех усложнённых методов выбора опорного элемента дополнительные накладные расходы впрочем они не так велики во избежание отказа программы из за большой глубины рекурсии могут применяться следующие методы при достижении нежелательной глубины рекурсии переходить на сортировку другими методами не требующими рекурсии примером такого подхода является алгоритм introsort или некоторые реализации быстрой сортировки библиотеке stl можно заметить что алгоритм очень хорошо подходит для такого рода модификаций так как на каждом этапе позволяет выделить непрерывный отрезок исходного массива предназначенный для сортировки то каким методом будет отсортирован этот отрезок никак не влияет на обработку остальных частей массива модификация алгоритма устраняющая одну ветвь рекурсии вместо того чтобы после разделения массива вызывать рекурсивно процедуру разделения для обоих найденных подмассивов рекурсивный вызов делается только для меньшего подмассива больший обрабатывается цикле пределах этого же вызова процедуры точки зрения эффективности среднем случае разницы практически нет накладные расходы на дополнительный рекурсивный вызов на организацию сравнения длин подмассивов цикла примерно одного порядка зато глубина рекурсии ни при каких обстоятельствах не превысит худшем случае вырожденного разделения она вообще будет не более вся обработка пройдёт цикле первого уровня рекурсии применение этого метода не спасёт от падения но переполнения стека не будет разбивать массив не на две на три части см также список алгоритмов сортировки примечания литература ссылки анимированное сравнение алгоритмов сортировки визуализаторы динамическая визуализация алгоритмов сортировки открытым исходным кодом категория алгоритмы сортировки