языках теории типов полиморфизмом называется способность функции обрабатывать данные разных типов существует несколько разновидностей полиморфизма две принципиально различных из них были описаны году это параметрический полиморфизм полиморфизм причём первая является истинной формой вторая мнимой прочие формы являются их подвидами или сочетаниями параметрический полиморфизм подразумевает исполнение одного того же кода для всех допустимых типов аргументов тогда как полиморфизм подразумевает исполнение потенциально разного кода для каждого типа или подтипа аргумента бьерн страуструп определил полиморфизм как один интерфейс много реализаций но это определение покрывает лишь ad hoc полиморфизм общие сведения принципиальная возможность для одного того же кода обрабатывать данные разных типов определяется свойствами системы типов языка этой точки зрения различают статическую неполиморфную типизацию потомки алгола bcpl динамическую типизацию потомки lisp smalltalk apl статическую полиморфную типизацию потомки ml использование полиморфизма наиболее характерно для неполиморфной типизации параметрический полиморфизм динамическая типизация намного существеннее чем полиморфизм повышают коэффициент повторного использования кода поскольку определённая единственный раз функция реализует без дублирования заданное поведение для бесконечного множества вновь определяемых типов удовлетворяющих требуемым функции условиям другой стороны временами возникает необходимость обеспечить различное поведение функции зависимости от типа параметра тогда необходимым оказывается специальный полиморфизм параметрический полиморфизм является синонимом абстракции типа он повсеместно используется функциональном где он обычно обозначается просто как полиморфизм сообществе объектно под термином полиморфизм обычно подразумевают наследование использование полиморфизма называют обобщённым или иногда статическим полиморфизмом классификация впервые классификацию разновидностей полиморфизма осуществил если параметру функции сопоставлен ровно один тип то такая функция называется мономорфной многие языки предоставляют синтаксический механизм для назначения нескольким мономорфным функциям единого имени идентификатора этом случае исходном коде становится возможным осуществлять вызов функции фактическими параметрами разных типов но коде фактически происходит вызов различных функций см перегрузка процедур функций назвал такую возможность полиморфизмом если параметру функции сопоставлено более одного типа то такая функция называется полиморфной разумеется каждым фактическим значением может быть связан лишь один тип но полиморфная функция рассматривает параметры на основе внешних свойств не их собственной организации содержания стрэчи назвал такую возможность параметрическим полиморфизмом дальнейшем классификацию уточнил выделив четыре разновидности полиморфизма универсальный параметрический включения или перегрузка приведение типов джон митчел выделяет три разновидности полиморфизма как независимые параметрический ad hoc подтипов латинский фразеологизм буквально случаю имеет двойственное значение спонтанный непродуманный сделанный на коленке специальный устроенный конкретно для данной цели или данного случая двойственность содержания термина долгие годы была заслуженной стрэчи выбрал этот термин руководствуясь первым значением работе он подчеркивает что при полиморфизме нет единого систематичного способа вывести тип результата из типа аргументов хотя возможно построение определённого набора правил для сужения спектра его поиска но эти правила по своей природе являются спонтанными как по содержанию так по контексту применения действительно ad hoc полиморфизм не является истинным полиморфизмом перегрузка функций даёт не значение имеющее множество типов символ имеющий множество типов но значения этим символом имеют разные потенциально типы аналогично приведение типов не является истинным полиморфизмом кажется будто оператор принимает значения множества типов но значения должны быть преобразованы некоторому представлению до того как он сможет их использовать так что на самом деле оператор работает лишь над одним типом то есть имеет один тип более того тип возвращаемого значения здесь не зависит от типа входного параметра как случае полиморфизма тем не менее определение специальных реализаций функций для разных типов некоторых случаях является необходимостью не случайностью классическими примерами служат реализация арифметических операций физически различная для целых чисел плавающей запятой которые на протяжении десятилетий не имели общепринятой универсальной формализации решением стали классы типов представляющие собой механизм явного дискретного перечисления допустимых значений переменных типа для статической диспетчеризации слое типов они сводят воедино две разновидности полиморфизма разделённые стречи делая менее игра на двойственности смысла дальнейшее обобщение классов типов привело построению теории типов единообразно формализующей самые экзотичные системы типов включая расширяемые записи подтипы отличие от перегрузки приведения типов полиморфизм является истинным полиморфизмом объектами подтипа можно манипулировать единообразно как если бы они принадлежали своим супертипам но сказанное не верно для языков реализующих полиморфизм при наследовании посредством приведения типов перегрузки функций как случае наиболее чистым является параметрический полиморфизм один тот же объект или функция может единообразно использоваться разных контекстах типизации без изменений приведений типов или любых других проверок времени исполнения или преобразований однако для этого требуется некое единообразное представление данных например посредством указателей основные разновидности полиморфизма ad hoc полиморфизм ad hoc полиморфизм русской литературе чаще всего переводится как или хотя оба варианта не всегда верны поддерживается во многих языках посредством перегрузки функций методов слабо типизированных также посредством приведения типов следующем примере язык pascal функции add выглядят как реализующие одну ту же над разными типами но компилятор определяет их как две совершенно разные функции program adhoc function add integer integer begin add end function add string string begin add concat end begin writeln add writeln add hello world end динамически типизируемых языках ситуация может быть более сложной так как выбор требуемой функции для вызова может быть осуществлён только во время исполнения программы перегрузка представляет собой синтаксический механизм позволяющий по единому идентификатору вызывать разные функции приведение типов представляет собой семантический механизм осуществляемый для преобразования фактического типа аргумента ожидаемому функцией при отсутствии которого произошла бы ошибка типизации то есть при вызове функции приведением типа происходит исполнение различного кода для различных типов предваряющего вызов самой функции параметрический полиморфизм параметрический полиморфизм позволяет определять функцию или тип данных обобщённо так что значения обрабатываются идентично вне зависимости от их типа параметрически полиморфная функция использует аргументы на основе поведения не значения апеллируя лишь необходимым ей свойствам аргументов что делает её применимой любом контексте где тип объекта удовлетворяет заданным требованиям поведения развитые системы типов такие как хиндли милнер предоставляют механизмы для определения полиморфных типов что делает использование полиморфных функций более удобным обеспечивает статическую такие системы являются системами типов второго порядка добавляющими системам типов первого порядка используемым большинстве процедурных языков параметризацию типов посредством ти повой переменной абстракцию типов посредством квантификации над ними системах типов второго порядка нет необходимости поддержке примитивных типов так как они могут быть выражены посредством более развитых средств классическим примером полиморфного типа служит список элементов произвольного типа для которого во многих языках типизируемых по хиндли милнеру большинство статически типизируемых функциональных языков предоставляется синтаксический сахар следующий пример демонстрирует определение нового алгебраического типа параметрически полиморфный список двух функций над ним data list nil cons list length list integer length nil length cons xs length xs map list list map nil nil map cons xs cons map xs при подстановке ти повую переменную конкретных типов int string будут построены соответственно конкретные типы list int list string эти конкретные типы свою очередь снова могут быть подставлены эту ти повую переменную порождая типы list list string list int list string при этом для всех объектов всех построенных типов будет использоваться одна та же физическая реализация функций length map ограниченные формы полиморфизма доступны также некоторых императивных частности объектно ориентированных языках где для его обозначения обычно используется термин обобщённое частности языке си параметрический полиморфизм традиционно обеспечивается за счёт использования указателя void хотя возможна типизированная форма использование шаблонов внешне похоже на параметрический полиморфизм но семантически реализуется сочетанием ad hoc механизмов сообществе его называют статическим полиморфизмом для динамическому полиморфизму параметричность формализация полиморфизма ведёт понятию состоящему возможности предсказывать поведение программ глядя только на их типы например если функция имеет тип forall то без каких либо дополняющих язык внешних средств можно доказать что она может быть только тождественной поэтому параметричность часто сопровождается лозунгом теоремы забесплатно важным следствием этого является также независимость представлений означающее что функции над абстрактным типом нечувствительны его структуре различные реализации этого типа могут свободно подменять друг друга даже рамках одной программы не влияя на поведение этих функций наиболее развитые параметрически полиморфные системы см лямбда куб зависимые типы доводят идею до возможности полного доказательства корректности программ они позволяют записывать программы которые верны по построению так что прохождение проверки согласования типов само по себе даёт гарантию что поведение программы соответствует ожидаемому полиморфизм записей вариантов отдельную проблему представляет распространение полиморфизма на агрегатные типы размеченные произведения типов традиционно называемые записями размеченные суммы типов также известные как различные исчисления записей служат формальной базой для объектно модульного val true hello val val многоточие означает некоторый ряд типизированных полей то есть абстракцию кода от конкретных типов записей которые могли бы здесь обрабатываться причём длина этого ряда также может варьироваться компиляция полиморфного обращения полям которые могут располагаться разном порядке разных записях представляет сложную проблему как точки зрения контроля безопасности операций на уровне языка так точки зрения быстродействия на уровне машинного кода наивным решением может быть динамический поиск по словарю при каждом обращении скриптовые языки его применяют однако очевидно что это чрезвычайно неэффективно эта проблема активно исследуется на протяжении уже нескольких десятилетий построено множество теоретических моделей практичных систем на их основе различающихся по выразительной мощности сложности важнейшими достижениями этой области считаются рядный полиморфизм предложенный митчелом вандом mitchell wand полиморфное исчисление записей построенное ацуси охори более но отстающей по многим характеристикам моделью является подтипизация на записях поддержка полиморфизма записей той или иной форме может открывать полиморфном языке такие возможности как наиболее мощную форму объектно бесшовное встраивание операций над элементами баз данных sql код на языке общего назначения др вплоть до расширяемого то есть свободного от гарантии отсутствия необработанных исключений программах определённых форм полиморфизм подтипов полиморфизм включения является обобщённой формализацией наследования эти понятия не следует путать определяют отношения на уровне интерфейсов тогда как наследование определяет отношения на уровне реализации подтипизация или полиморфизм подтипов означает что поведение параметрически полиморфной функции ограничивается множеством типов ограниченных иерархию супертип подтип например если имеются типы number rational integer ограниченные отношениями number rational number integer то функция определённая на типе number также сможет принять на вход аргументы типов integer или rational её поведение будет идентичным действительный тип объекта может быть скрыт как чёрный ящик предоставляться лишь по запросу идентификации объекта на самом деле если тип number является абстрактным то конкретного объекта этого типа даже не может существовать см абстрактный класс но не следует путать абстрактным типом данных данная иерархия типов известна особенно контексте языка scheme как обычно содержит большее количество типов идея подтипов мотивируется увеличением множества типов которые могут обрабатываться уже написанными функциями за счёт этого повышением коэффициента повторного использования кода условиях сильной типизации то есть увеличением множества типизируемых программ это обеспечивается правилом включения если выражение принадлежит типу контексте типизации выполняется то принадлежит также типу отношения подтипизации возможны на самых разных категориях типов примитивных типах как integer типах суммах типах произведениях функциональных типах др более того предложил концепцию степенны родо для описания подтипизации степенью данного типа слое родо он назвал род всех его подтипов особое место информатике занимает подтипизация на записях подтипизация на записях подтипизация на записях также известная как включение или вхождение см принцип подстановки барбары лисков служит наиболее теоретическим обоснованием объектно ооп но не единственным см полиморфизм записей вариантов мартин абади формализовали подтипизацию на записях посредством над параметрически полиморфными типами при этом параметр типа задаётся неявно подтипизации на записях выделяются две разновидности ширину глубину подтипизация ширину подразумевает добавление запись новых полей например type object age int type vehicle age int speed int type bike age int speed int gear int type machine age int fuel string одной стороны можно записать отношения подтипизации vehicle bike поскольку подтипизация транзитивна то bike machine другой стороны можно говорить что типы vehicle bike machine включают наследуют все свойства типа object здесь подразумевается семантика системы типов поскольку интуитивно тип зачастую рассматривается как множество значений то увеличение количества полей подтипе может выглядеть контр интуитивно точки зрения теории множеств типы это не множества они предназначены для верификации поведения программ идея подтипизации состоит том что подтип обладает по меньшей мере свойствами своего супертипа таким образом способен эмулировать его как минимум там где ожидается объект супертипа или иначе супертип определяет минимальный набор свойств для множества объектов тогда тип обладающий этими свойствами возможно какими то другими формирует подмножество этого множества следовательно является его подтипом отношения подтипов терминах множеств выглядят более интуитивно случае вариантными типами type day mon tue wed thu fri sat sun type workday mon tue wed thu fri type weekend sat sun здесь workday weekend именование полей позволяет от порядка их следования записях отличие от кортежей что даёт возможность строить произвольные направленные ацикличные графы наследования формализуя множественное наследование type car age int speed int fuel string теперь car одновременно car очевидно также что car см ромбовидное наследование подтипизация глубину подразумевает что типы конкретных полей записи могут подменяться на их подтипы type voyage veh vehicle date day type sports veh bike date day type vacation veh car date weekend из определений выше можно вывести что sports vacation методы подтипах записей полноценная поддержка объектно предполагает включение число полей записей также функций обрабатывающих значения типов записей которым они принадлежат такие функции традиционно называются методами обобщённой моделью связывания записей методами является матрица диспетчеризации на практике большинство языков раскладывают её на вектора по строкам либо по столбцам соответственно реализуя либо организацию на основе классов либо организацию на основе методов при этом следует отличать переопределение методов подтипах от подтипизации функций переопределение методов не связывает их отношениями подтипизации на функциях но позволяет изменять сигнатуры их типов при этом возможны три варианта инвариантное ковариантное переопределение два последних используют подтипизацию своих параметров подробнее см ковариантность исчисление абади карделли рассматривает только инвариантные методы что необходимо для доказательства безопасности многие объектно ориентированные языки предусматривают встроенный механизм связывания функций методы реализуя таким образом организацию программ на основе классов языки рассматривающие функции как объекты первого класса типизирующие их см функции первого класса функциональный тип не путать типом возвращаемого значения функции позволяют произвольно выстраивать организацию на основе методов что обеспечивает возможность производить объектно ориентированное проектирование без прямой поддержки со стороны языка некоторые языки например ocaml поддерживают обе возможности языки системами типов основанными на формальной теории подтипизации ocaml проект рассматривают системы объектов системы классов независимо это значит что объектом связывается прежде всего объектный тип лишь при явном указании объектный тип связывается неким классом при этом осуществляется на уровне объекта значит таких языках два объекта относящиеся одному классу вообще говоря могут иметь различный набор методов вместе формально определённой семантикой множественного наследования это даёт всестороннюю поддержку примесей clos реализует матрицу диспетчеризации посредством мультиметодов то есть методов полиморфных сразу по нескольким аргументам некоторые языки используют своеобразные ad hoc решения например система типов языка предусматривает автоматическое приведение типов то есть является слабой эмулирует через наследование инвариантными сигнатурами методов не поддерживает абстракцию типов не путать сокрытием полей наследование реализуется набором однако его использование называется сообществе языка полиморфизмом сокрытие полей абстракцией имеется возможность управлять графом наследования ромбовидное наследование называется виртуальным наследованием задаётся явным атрибутом virtual по умолчанию же осуществляется дублирование унаследованных полей доступом ним по имени использование такого языка может быть небезопасно нельзя гарантировать устойчивость программ язык называется безопасным если программы на нём которые могут быть приняты компилятором как правильно построенные динамике никогда не выйдут за рамки допустимого поведения подтипизация высшего порядка система читается саб омега является расширением системы не представленным лямбда кубе формализующим над ти повыми операторами распространяя отношения подтипизации рода на типы высших родо существует несколько вариантов системы различающихся по выразительной мощности сложности но большинство основных идей заложил сочетание разновидностей полиморфизма классы типов класс типов реализует единую независимую таблицу виртуальных методов для множества универсально типов этим классы типов отличаются от классов объектно ориентированном где всякий объект всякого типа сопровождается указателем на таблицу виртуальных методов классы типов являются не типами но категориями типов их экземпляры представляют собой не значения типы например class num where negate это объявление читается так тип принадлежит классу num если на нём определены функции negate заданными сигнатурами instance num int where addint mulint negate negint instance num float where addfloat mulfloat negate negfloat первое объявление читается так существуют функции negate соответствующих сигнатур которые определены над типом int аналогично читается второе утверждение теперь можно корректно типизировать следующие функции причём выведение типов разрешимо square num square squares num num num squares square square square поскольку операция умножения реализуется физически различным образом для целых чисел плавающей запятой отсутствии классов типов уже здесь потребовались бы две перегруженные функции square восемь перегруженных функций squares реальных программах со сложными структурами данных дублирующегося кода оказывается намного больше объектно ориентированном проблемы такого рода решаются посредством накладными расходами класс типов осуществляет диспетчеризацию статически сводя параметрический полиморфизм единую модель точки зрения полиморфизма класс типов имеет параметр переменную типа пробегающий множество типов точки зрения полиморфизма это множество не только дискретно но задано явным образом до уровня реализации проще говоря сигнатура square num означает что функция параметрически полиморфна но спектр типов её параметра ограничен лишь теми типами что принадлежат классу типов num благодаря этому функция типизируется единственным образом несмотря на обращение перегруженной функции из её тела встроенная поддержка классов типов была впервые реализована языке haskell но они также могут быть введены любой параметрически полиморфный язык путём простого препроцессинга также реализованы идиоматически см например язык модулей ml реализация альтернативных моделей однако поддержка может упрощать автоматическое рассуждение смысле программ haskell реализуются как инстансы класса типов eq обобщая переменные типа допускающего проверку на равенство из eq bool для снижения рутинного кодирования некоторых часто очевидно необходимых свойств типов haskell дополнительно предусмотрен синтаксический сахар конструкция deriving допустимая для ограниченного набора стандартных классов типов таких как eq русскоязычном сообществе её использование нередко путается понятием наследования из за особенностей перевода слова derive обобщённые алгебраические типы данных политипизм иногда используется термин политипизм или обобщённость типа данных по сути политипизм означает встроенную язык поддержку полиморфизма конструкторов типов предназначенную для унификации программных интерфейсов повышения повторного использования кода примером политипизма является обобщённый алгоритм сопоставления образцом по определению политиповой функции хотя возможно наличие конечного числа ветвей для некоторых типов но комбинатор отсутствует политипизм может быть реализован посредством использования универсального типа данных или полиморфизма высших рангов расширение polyp языка haskell представляет собой синтаксическую конструкцию упрощающую определение политиповых функций haskell политиповая функция является некотором смысле более обобщённой чем полиморфная но другой стороны функция может быть политиповой при этом не полиморфной что видно на примере следующих сигнатур функциональных типов head num length regular int sum regular int int первая функция head является полиморфной параметрически полиморфной вторая инфиксный оператор перегруженной полиморфной третья четвёртая политиповыми переменная типа их определении варьируется над конструкторами типов при этом третья функция length является политиповой полиморфной она вычисляет длину для некоторого множества полиморфных агрегатных типов например количество элементов списках деревьях четвёртая sum является политиповой но не полиморфной мономорфной над агрегатными типами принадлежащими классу типов regular для которых она вероятно вычисляет сумму целых образующих объект конкретного агрегатного типа прочее динамически типизируемые языки единообразно представляют разновидности полиморфизма что формирует самобытную идеологию них влияет на применяемые методологии декомпозиции задач например smalltalk любой класс способен принять сообщения любого типа либо обработать его самостоятельно том числе посредством интроспекции либо ретранслировать другому классу таким образом любой метод формально является параметрически полиморфным при этом его внутренняя структура может ветвиться по условию динамического типа аргумента реализуя специальный полиморфизм clos мультиметоды одновременно являются функциями первого класса что позволяет рассматривать их одновременно как как обобщённые истинно полиморфные статически полиморфно типизированные языки напротив могут реализовать разновидности полиморфизма ортогонально независимо друг от друга позволяя выстраивать их хитросплетение типобезопасным образом например ocaml поддерживает параметрические классы по возможностям аналогичные шаблонам классов но верифицируемые без необходимости инстанцирования их наследование вширь вглубь том числе множественное идиоматическую реализацию классов типов посредством сигнатур см соответствующий пример использования языка модулей ml рядный полиморфизм параметрический полиморфизм рангов выше го посредством так называемых локально абстрактных типов реализующих типы обобщённые алгебраические типы данных история термин полиморфизм происходит от др греч πολύς много μορφή форма облик устройство термины полиморфизм параметрический полиморфизм впервые упоминаются году конспекте лекций под названием году формализовали полиморфизм включения для моделирования наследования хотя реализации подтипов наследования появились намного раньше языке симула году полиморфизм включения основан на нотацию полиморфизма как развитие лямбда исчисления названную полиморфным лямбда исчислением или системой формально описал логик год независимо от него похожую систему описал информатик год первым языком целиком основанным на полиморфном лямбда исчислении был ml год независимо от него параметрические типы были реализованы clu год многие современные языки java другие предоставляют параметрические типы форме более или менее близкой их реализации clu году митчел уэнд формализовал рядный полиморфизм выведение типов для него эта работа оказала огромное влияние на последующее развитие систем типов году стивен блотт предложили классы типов для формализации полиморфизма см также система типов каламбур типизации ковариантность инкапсуляция наследование примечания литература повторно опубликовано перевод на русский язык перевод на русский язык перевод на русский язык категория типы данных категория информатика