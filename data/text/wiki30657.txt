алгоритм рабина карпа это алгоритм поиска строки который ищет шаблон то есть подстроку тексте используя хеширование он был разработан году майклом рабином ричардом карпом алгоритм редко используется для поиска одиночного шаблона но имеет значительную теоретическую важность очень эффективен поиске совпадений множественных шаблонов одинаковой длины для текста длины шаблона длины его среднее лучшее время исполнения равно при правильном выборе хеш функции смотрите ниже но худшем случае он имеет эффективность nm что является одной из причин того почему он не слишком широко используется для приложений которых допустимы ложные срабатывания при поиске то есть когда некоторые из найденных вхождений шаблона на самом деле могут не соответствовать шаблону алгоритм рабина карпа работает за гарантированное время при подходящем выборе хеш функции смотрите ниже вероятность ошибки можно сделать очень малой также алгоритм имеет уникальную особенность находить любую из заданных строк одинаковой длины среднем при правильном выборе хеш функции за время независимо от размера одно из простейших практических применений алгоритма рабина карпа состоит определении плагиата скажем например что студент пишет работу по моби дику коварный профессор находит различные исходные материалы по моби дику автоматически извлекает список предложений этих материалах затем алгоритм рабина карпа может быстро найти проверяемой статье примеры вхождения некоторых предложений из исходных материалов для устранения алгоритма небольшим различиям можно игнорировать детали такие как регистр или пунктуация при помощи их удаления поскольку количество строк которые мы ищем очень большое обычные алгоритмы поиска одиночных строк становятся неэффективными поиск подстрок сдвигом конкурирующие алгоритмы основной задачей алгоритма является нахождение строки длины называемой образцом тексте длины один из простейших алгоритмов для этой задачи просто ищет подстроку во всех возможных местах function naivesearch string string sub for from to for from to if si subj перейти следующей итерации внешнего цикла return return not found этот алгоритм хорошо работает во многих практических случаях но совершенно неэффективен например на поиске строки из тысяч символов за которыми следует строке из миллионов символов этом случае он показывает своё худшее время исполнения mn алгоритм кнута морриса пратта уменьшает это время до единожды используя предвычисления для каждого символа текста алгоритм бойера мура пропускает не один символ столько сколько максимально возможно для того чтобы поиск удался эффективно уменьшая количество итераций через внешний цикл поэтому количество символов которыми производится сравнение может быть сравнимо лучшем случае алгоритм рабина карпа вместо этого фокусируется на ускорении действия строк что будет рассмотрено следующем разделе использование хеширования для поиска подстрок сдвигом вместо того чтобы использовать более умный пропуск алгоритм рабина карпа пытается ускорить проверку эквивалентности образца подстроками тексте используя хеш функцию хеш функция это функция преобразующая каждую строку числовое значение называемое хеш значением хеш например мы можем иметь хеш от строки hello равным алгоритм использует тот факт что если две строки одинаковы то их хеш значения также одинаковы таким образом всё что нам нужно это посчитать хеш значение искомой подстроки затем найти подстроку таким же хеш значением однако существуют две проблемы связанные этим первая состоит том что так как существует очень много различных строк между двумя различными строками может произойти коллизия совпадение их хешей таких случаях необходимо посимвольно проверять совпадение самих подстрок что занимает достаточно много времени если данные подстроки имеют большую длину эту проверку делать не нужно если ваше приложение допускает ложные срабатывания при использовании достаточно хороших хеш функций смотрите далее коллизии случаются крайне редко результате среднее время поиска оказывается невелико пример алгоритма исходного кода приложения function rabinkarp string string sub hsub hash sub hs hash for from to if hs hsub if si sub return hs hash si return not found строки затрачивают для исполнения время каждая однако строки исполняются только один раз строка выполняется только когда хеш значения совпадают что происходит нечасто строка выполняется раз но всегда требует постоянного времени вторая проблема заключается пересчитывании хеша при наивном пересчёте хеш значения подстроки si затрачивается время так как это делается каждом цикле алгоритм будет затрачивать время то есть такое же какое тратят наиболее простые алгоритмы метод решения данной проблемы состоит предположении того что переменная hs уже содержит хеш значение подстроки si если использовать его для подсчёта следующего хеш значения за постоянное время тогда проблема будет решена это достигается использованием так называемого кольцевого хеша самым простым примером кольцевого хеша является добавление значений каждого следующего символа подстроке последующее использование данной формулы для подсчёта каждого следующего хеш значения за фиксированное время si si si si такая формула не даёт никаких гарантий нечастого возникновения коллизий действительно несложно убедиться что большинстве приложений при её использовании выражение строке будет выполняться чаще чем при использовании других более умных кольцевых хеш функций заметим что если мы очень неудачливы или имеем очень плохую хеш функцию например такую как постоянную функцию hash const строка высокой вероятностью будет выполняться раз то есть при каждой итерации цикла так как она затрачивает время сам алгоритм будет требовать время используемая хеш функция ключами алгоритма рабина карпа являются низкая вероятность коллизий эффективное вычисление хеш значения подстрок текста рабин карп предложили использовать так называемый полиномиальный хеш хотя любой другой кольцевой хеш также подойдёт для данного шаблона такой хеш определён следующим образом где некоторое простое число число от до хеш значения подстрок для полиномиального хеша вычисляются следующим образом заметим что для эффективности число считается перед основной процедурой поиска алгоритма рабина карпа например пусть произвольно мы имеем текст abracadabra ищем образец длины мы можем рассчитать хеш подстроки bra из хеша подстроки abr предыдущая подстрока вычитая число добавленное для первой буквы из abr то есть ascii для умножая на основание наконец добавляя последнее число для bra то есть чтобы избежать переполнения целых чисел большинстве реализаций после каждой из этих четырёх операций умножение при вычислении это отдельная операция нужно брать результат по модулю рабин карп доказали что если то есть фиксируется простое число выбирается случайно из диапазона то вероятность коллизии при поиске шаблона тексте длины не превосходит но такой хеш функции два существенных недостатка во первых алгоритм выбора случайного простого числа достаточно громоздкий во вторых модульная арифметика делает такой хеш очень медленным на практике отметим что вся арифметика формуле для хешей подстрок должна быть по модулю то есть взятие модуля выполнится четыре раза современная модификация полиномиального хеша предложенная дитзфелбингером др лишена этих недостатков отличие этого варианта том что простое число фиксируется число случайно выбирается из диапазона от до перед началом работы алгоритма при этом совсем не обязательно должно быть простым доказано что для такой хеш функции вероятность коллизии при поиске шаблона строке при для какого то не превосходит при естественном условии что для всех для ускорения модульной арифметики можно выбирать равным степени двойки минус один так называемые простые числа мерсенна для битовых машин лучше всего подходит для битовых взятие по модулю для таких значений вычисляется помощью быстрых побитовых операций другой возможный выбор значения или для которых тоже существуют быстрые алгоритмы взятия остатка от деления на при этом диапазон допустимых значений немного сужают можно выбирать лишь один раз при старте программы затем использовать его во всех хешах заблуждения полиномиальном хеше ещё раз отметим что предоставляемые полиномиальным хешем гарантии отсутствия коллизий весьма сильны даже если кто то зная но не зная специально будет подбирать шаблон строку длины для поиска так чтобы алгоритм рабина карпа полиномиальным хешем давал как можно больше коллизий всё равно при для какого то то есть при достаточно большом не сверхбольшом если выбирается действительно случайно вероятность даже одной коллизии будет не больше то есть очень мала для достижения этого результат важно что является простым числом например частая ошибка полагать или то есть вообще не использовать модульную арифметику примером строки которой можно найти много коллизий полиномиального хеша для таких причём независимо от выбора числа является морса туэ имеет популярность следующая интерпретация полиномиального хеша каждая строка представляется числом основанием затем это число берётся по модулю такая интерпретация не добавляет ясности природу эффективности данного хеша то время как интерпретация полиномиального хеша как собственно полинома коэффициентами равными значениям символов достаточно просто приводит доказательству малой вероятности коллизии при случайном выборе рассмотрим две различные строки полиномиальные хеши этих строк равны тогда только тогда когда но из теоремы безу следует что нетождественный нулю полином степени поле вычетов по модулю выбирается простым именно чтобы превратить кольцо вычетов поле имеет не более корней значит вероятность коллизии при случайном выборе не превосходит поэтому если для какого то вероятность коллизии двух различных строк длины не превосходит отсюда частности получается вероятность ошибки для поиска шаблона строке также иногда можно встретить рекомендацию использовать простое число качестве но по видимому кроме эмпирических наблюдений на некоторых весьма ограниченных объёмах данных такие советы ничем более не обоснованы рабин карп поиск множества образцов из за медленного поведения худшем случае алгоритм рабина карпа хуже алгоритма кнута морриса пратта алгоритма бойера мура других быстрых алгоритмов поиска строк тем не менее алгоритм рабина карпа можно использовать для поиска набора образцов за линейное время лучшем случае квадратичное худшем случае хотя здесь он проигрывает худшем случае алгоритму ахо корасик имеющему линейное время работы если мы хотим найти данном тексте любой образец из большого набора скажем образцов фиксированной одинаковой длины мы можем модифицировать алгоритм рабина карпа используя хеш таблицу или любую другую структуру данных для проверки того когда хеш данной строки принадлежит набору хеш значений образцов которые мы ищем function rabinkarpset string set of string subs set hsubs for each sub in subs hsubs hsubs hash sub hs hash for from to if hs hsubs if si string из subs хешем hs return hs hash si return не найдено другие алгоритмы могут искать одиночный образец за время следовательно они могут быть использованы для поиска образцов за время им вариант алгоритма рабина карпа выше может найти все образцов за ожидаемое время потому что хеш таблица используемая для проверки случая когда хеш подстроки равен хешу любого из образцов использует времени на практике из за относительной простоты реализации быстроты работы этот вариант нередко может оказаться алгоритма алгоритма ахо корасик см также алгоритм бойера мура алгоритм кнута морриса пратта алгоритм ахо корасик примечания литература рабина карпа рабина карпа категория хеширование