паска ль один из наиболее известных языков используется для обучения старших классах на первых курсах вузов является базой для ряда других языков история язык был создан никлаусом виртом годах после его участия работе комитета разработки стандарта языка алгол язык назван честь французского математика физика литератора философа блеза паскаля который создал одну из первых мире механических машин складывающую два числа первая публикация вирта языке датирована годом представляя язык автор качестве цели его создания указывал построение небольшого эффективного языка способствующего хорошему стилю использующему структурное данные последующая работа вирта была направлена на создание на основе паскаля языка системного сохранением возможности вести на его базе систематический целостный курс обучения результат этой работы язык модула реализации диалекты ucsd pascal году калифорнийском университете сан диего была разработана система ucsd system включавшая порт компилятора вирта языка паскаль переносимый код редактор исходных кодов файловую систему прочее также реализовывавшая значительное число расширений языка паскаль такие как модули строки символов переменной длины директивы трансляции обработка ошибок ввода вывода обращение файлам по именам другое впоследствии основные реализации языка паскаль основывались на этом диалекте object pascal году фирма apple разработала объектное расширение языка паскаль получив результате object pascal он был разработан группой ларри теслера который никлаусом виртом turbo pascal object pascal году появилась первая версия интегрированной среды разработки turbo pascal фирмы borland основывавшаяся на одноимённой реализации паскаля году объектное расширение языка было добавлено turbo pascal версии последняя версия была переименована borland pascal объектные средства были позаимствованы из object pascal от apple языковые различия между объектным turbo pascal object pascal от apple крайне незначительны почти то же самое время что borland microsoft выпустил свою версию объектно языка паскаль эта версия паскаля не получила широкого распространения дальнейшее развитие реализации паскаля от borland породило вариант object pascal от borland впоследствии ходе развития среды delphi получивший одноимённое название современные версии object pascal важным шагом развитии языка является появление свободных реализаций языка паскаль free pascal gnu pascal которые не только вобрали себя черты множества других диалектов языка но обеспечили чрезвычайно широкую переносимость написанных на нём программ например gnu pascal поддерживает более различных платформ под более чем различными операционными системами free pascal обеспечивает специальные режимы совместимости различными диалектами языка такими как turbo pascal полная совместимость delphi другими начиная delphi создана реализация языка для платформы net хотя разработчики продолжают использовать delphi более ранних версий коммерческих разработках на free pascal gnu pascal tmt pascal на данный момент известно мало кроме того южном федеральном университете разработан pascalabc net язык паскаль включающий большинство возможностей языка delphi также ряд собственных расширений он основан на платформе microsoft net содержит практически все современные языковые средства классы перегрузку операций интерфейсы обработку исключений обобщенные классы подпрограммы сборку мусора лямбда выражения особенности языка особенностями языка являются строгая типизация наличие средств структурного процедурного паскаль был одним из первых таких языков по мнению вирта язык должен способствовать поэтому наряду со строгой типизацией паскале сведены минимуму возможные синтаксические неоднозначности сам синтаксис автор постарался сделать интуитивно понятным даже при первом знакомстве языком тем не менее первоначально язык имел ряд ограничений невозможность передачи функциям массивов переменной длины отсутствие нормальных средств работы динамической памятью ограниченная библиотека ввода вывода отсутствие средств для подключения функций написанных на других языках отсутствие средств раздельной компиляции подробный разбор недостатков языка паскаль того времени был выполнен брайаном керниганом статье почему паскаль не является моим любимым языком эта статья вышла начале когда уже существовал язык модула потомок паскаля избавленный от большинства его пороков также более развитые диалекты паскаля некоторые недостатки паскаля были исправлены iso стандарте года частности языке появились открытые массивы давшие возможность использовать одни те же процедуры для обработки одномерных массивов различных размеров однако многие недостатки языка не проявляются или даже становятся достоинствами при обучении кроме того по сравнению основным языком академической среде которым был фортран обладавший гораздо более существенными недостатками паскаль представлял собой значительный шаг вперёд годам паскаль стал основой для многочисленных учебных программ отдельных случаях на его основе были созданы обучающие языки так начале годов ссср для обучения школьников основам информатики вычислительной техники андрей ершов разработал алголо паскалеподобный учебный алгоритмический язык наиболее известной реализацией паскаля обеспечившей широкое распространение развитие языка является turbo pascal фирмы borland выросшая затем объектный паскаль для dos начиная версии windows далее delphi которой были внедрены значительные расширения языка стандарты после начала использования паскаля году появления реализаций расходящихся не только дополнениях но синтаксисе был поднят вопрос стандартизации языка стандарт языка был разработан никлаусом виртом году совместно кетлин йенсен kathleen jensen дальнейшем были приняты международный стандарт от iso американский от ansi на данный момент выделяют три принципиально разных стандарта unextended pascal исходный extended pascal расширенный object oriented extensions to pascal объектно ориентированное расширение паскаля стандарты языка pascal исходный международные iso американские ansi название вариант кем где разработан год создания pascal standard исходный вирт кетлин йенсен pascal standard исходный iso ansi ieee unextended pascal исходный iso extended pascal расширенный ansi ieee iso iec object to pascal объектно ориентированное расширение ansi tr одним из главных дополнительных свойств объектно расширения extended pascal стала модульность средства облегчающие раздельную компиляцию стандартизация языка была запаздывающей по отношению реальному появлению языке тех или иных возможностей коммерческие реализации расширяли стандартный паскаль так было сделано ucsd pascal модификации object pascal фирмой apple turbo pascal от borland незначительно версия apple его ответвлений ни одна из коммерческих реализаций паскаля не соответствует точности ни одному из официальных стандартов языка синтаксис языковые конструкции паскаль его первоначальном виде представляет собою чисто процедурный язык включает себя множество алголоподобных структур конструкций словами наподобие if then else while for repeat тем не менее паскаль также содержит большое количество возможностей для информации абстракций которые отсутствуют изначальном алголе такие как определение типов записи указатели перечисления множества эти конструкции были частично унаследованы или инспирированы от языков симула алгол созданного никлаусом виртом предложены хоаром современных диалектах delphi pascal free pascal доступны такие операции как перегрузка операторов функций hello world программы на паскале начинаются ключевого слова program следующего за ним имени программы точкой запятой некоторых диалектах является необязательным за именем может скобках следовать список внешних файловых дескрипторов окружение качестве параметров за ним следует тело программы состоящее из секций описания констант const типов type переменных var объявлений процедур procedure функций function следующего за ними блока операторов являющегося точкой входа программу языке паскаль блок ограничивается ключевыми словами begin end операторы разделяются точками запятой после тела помещается точка служащая признаком конца программы регистр символов паскале не имеет значения таким образом простейшая пустая программа на паскале будет выглядеть следующим образом program begin end приведённая выше программа не выполняет никаких действий содержит пустой блок операторов пример программы выводящей строку hello world begin writeln hello world оператор вывода строки end типы данных простые типы стандартном расширенном паскале есть такие простые типы числа плавающей запятой real целые integer символьный char логический boolean перечисления конструктор нового типа введённый pascal turbo pascal дополнил язык вариациями этих типов например shortint будет короче integer longint длиннее современные диалекты pascal такие как fpc или delphi считают что integer это наиболее подходящий для данной машины целый применяемый например для индексов массива shortint longint другие целые определённой длины это удобно при аналогично дробными числами ещё раз расширили типы при переходе на просто целое integer осталось битным но потребовался особый тип который равен longint на int на целочисленные типы тип диапазон формат размер байтах примечания byte беззнаковый shortint знаковый smallint знаковый может не существовать вместо него integer тем же диапазоном word беззнаковый longword беззнаковый longint знаковый int знаковый qword беззнаковый integer знаковый наиболее быстрый целый smallint или longint cardinal беззнаковый наиболее быстрый целый обычно longword nativeint знаковый соответствует машинному регистру longint или int nativeuint беззнаковый соответствует машинному регистру longword или qword числа плавающей запятой тип диапазон кол во значащих цифр размер байтах поддержка real зависит от платформы все компиляторы на современных обычно эквивалентен double real borland turbo pascal назывался real не использует сопроцессора потому результат повторяем до бита single большинство вариантов под ieee совместимые машины double большинство вариантов под ieee совместимые машины extended большинство вариантов под comp borland рассчитываемое на сопроцессоре байтовое целое актуально для битного currency borland другие компиляторы под windows связано ole фиксированная запятая единицей равной var секция объявления переменных real переменная вещественного типа integer переменная целого типа char переменная символ boolean логическая переменная string переменная строки text переменная для объявления текстового файла apple pear banana orange lemon переменная типа перечисления pascal над целыми типами byte shortint word integer longint их диапазоны допустимы побитовые операции логические операции над битами над битами двух целых операндов можно выполнять ранее рассмотренные логические операции not and or xor отличие между побитовыми логическими операциями состоит том что побитовые поразрядные операции выполняются над отдельными битами операндов не над их значением десятичном обычно представлении выделяется понятие порядковых типов данных ordinal ним относятся целые типы знаковые беззнаковые логический boolean символьный char перечислимые типы типы диапазоны порядковые типы задаются целым числом кодом которое можно получить помощью функции ord все операции выполняемые над порядковыми типами выполняются их кодами диапазоны содержат подмножество значений других порядковых типов var pear orange для порядковых типов определены операции inc dec succ pred ord операции сравнения их можно использовать операторах case for как счётчик цикла как границы массивов для задания элементов множеств типов диапазонов pascal отличие от си подобных языков типами boolean char арифметические целочисленные операции не определены множества отличие от многих языков pascal поддерживает специальный тип данных множество var set set of set set of set set of pear orange множество фундаментальное понятие современной математике которое может быть использовано во многих алгоритмах паскале тип множество может содержать только однотипные элементы порядкового типа эта особенность широко используется обычно быстрее эквивалентной конструкции языке не поддерживающем множества примеру для большинства компиляторов паскаля if in then проверка на принадлежность элемента множеству обработается быстрее чем if and для задания значения множества используется список элементов множества отделенных запятыми заключённый квадратные скобки как уже было показано выше var секция объявления переменных set of char begin начало блока паскале йенсен вирта строки представлялись как упакованные массивы символов следовательно они имели фиксированную длину обычно дополнялись до этой длины пробелами составные типы новые типы могут быть определены из существующих type секция объявления типов integer более того из примитивных типов могут быть сконструированы составные type секция объявления типов array of integer определение массива record определение записи integer char end file of определение файла файловые типы паскале делятся на типизированные текстовые файлы без типов как показано вышеприведённом примере типизированные файлы паскале это однотипных элементов для каждого файла существует переменная указатель на буфер которая обозначается процедуры get для чтения put для записи перемещают указатель следующему элементу чтение реализовано так что read представляет собою то же что get соответственно запись реализована так что write представляет собою то же что put текстовые файлы text определены как расширение типа file of char помимо стандартных операций над типизированными файлами чтение запись символа позволяют осуществлять символьный ввод вывод файл всех типов данных аналогично консольному вводу выводу файлы без типов объявляются как переменные типа file ними можно проводить операции побайтового ввода вывода по несколько блоков байт указанной длины через буфер для этого служат специальные процедуры blockread blockwrite расширение ucsd строки современном паскале для работы со строками используется встроенный тип string поддерживающий операции конкатенации сравнения строки сравниваются порядке например строки считаются равными если они имеют одинаковую длину коды всех символов одинаковыми индексами совпадают тип string или просто string диалектах языка годов определялся виде массива символов array of char по умолчанию принимало значение ucsd pascal turbo borland pascal нулевой элемент массива при таком представлении служит для задания длины строки соответственно строка могла иметь максимальный размер символов по умолчанию delphi freepascal качестве string используется тип ansistring память под который выделяется освобождается компилятором динамически максимальный размер строки текущих реализациях составляет гигабайта кроме того delphi free pascal качестве string может использоваться тип unicodestring где применяется битное представление символов кодировке ucs при этом средства преобразования из однобайтовых строк многобайтовые обратно стандартной библиотеке fpc отсутствуют но имеются delphi delphi выше имеется конструкция для объявления ansistring определённой кодовой страницей type cyrillicstring ansistring cp string ansistring указатели паскаль поддерживает использование указателей типизированные тип pointer type record integer char end var pointer_to_b здесь переменная pointer_to_b указатель на тип данных являющийся записью типизированный указатель может быть определён опережающее определение перед объявлением типа на который он ссылается это одно из исключений правилу которое гласит что любой элемент константа тип переменная процедура функция должен быть объявлен перед тем как используется введение этого исключения позволяет организовывать рекуррентные определения структур данных том числе такие как линейные списки стеки очереди деревья включая указатель на запись описание этой записи см также нулевой указатель nil для типизированного указателя определена операция разыменования её синтаксис указатель чтобы создать новую запись присвоить значение символ полям ней необходимы следующие операторы new pointer_to_b выделение памяти указателю pointer_to_b разыменовывание указателя обращение полю записи pointer_to_b pointer_to_b nil dispose pointer_to_b освобождение памяти из под указателя для целей обращения полям записей объектов можно также использовать оператор with как показано примере new pointer_to_b with pointer_to_b do begin nil end dispose pointer_to_b процедурный тип оригинальном языке паскаль йенсен вирта процедурный тип использовался только при описании формального параметра уже tp существовал полноправный процедурный тип объявлении типа ставится заголовок процедуры либо функции без имени обобщённо описывающий интерфейс подпрограммы значение этого типа содержит указатель на подпрограмму заголовком соответствующую описанному объявлении типа помощью идентификатора переменной может происходить вызов соответствующей процедуры или функции операторы управления паскаль язык структурного что означает что программа состоит из выполняющихся последовательно отдельных стандартных операторов идеале без использования команды goto операторах while for if case качестве выполняемого оператора может использоваться блок такая конструкция представляющая собой обычный оператор или блок называется сложным оператором turbo pascal для управления процессом компиляции существуют директивы которые помещаются комментарии позволяют переключать режимы работы компилятора например включать отключать проверку операций ввода вывода переполнения существуют директивы аналогичные директивам препроцессора ifdef define include они обрабатываются компилятором процессе компиляции процедуры функции паскале подпрограммы делятся на процедуры функции при этом функции явно возвращают значение результат определённого типа процедуры явно ничего не возвращают синтаксически описание процедуры или функции состоит из заголовка содержащего ключевое слово procedure или function имени за которым может следовать описание передаваемых формальных параметров скобках для функции через символ двоеточие указывается тип возвращаемого значения заголовок заканчивается символом точка запятой после заголовка следует тело возможно содержащее секции описания локальных констант типов переменных процедур функций обязательно содержащее блок операторов после которого ставится символ точка запятой тело процедуры как программы свою очередь может содержать описания процедур функций таким образом процедуры функции могут быть вложены друг друга как угодно глубоко при этом тело программы самое верхнее цепочке причём содержимое секций описания переменных типов констант внешнего тела процедуры функции программы расположенных перед описанием процедуры функции доступны внутри неё также большинстве диалектов из процедуры можно обращаться параметрам внешней процедуры вслед за заголовком процедур функций вместо тела может помещаться ключевое слово forward это делается том случае если описание процедуры функции располагается программе после её вызова связано поддерживаемой паскале возможностью компиляции программы за один проход стандартные математические функции процедуры паскаля математические функции наименование функции тип аргумента тип значения результат вычисления abs целый вещественный целый вещественный абсолютное значение sin вещественный вещественный синус рад cos вещественный вещественный косинус рад arctan вещественный вещественный арктангенс pi power вещественный вещественный значение степени exp вещественный вещественный значение степени где ln вещественный вещественный натуральный логарифм frac вещественный вещественный дробная часть int вещественный вещественный целая часть вещественный случайное число include языке си помощью специальной директивы оформляемой виде например include файл содержимое указанного файла прямо включалось текст программы исходном текстовом виде таким образом можно было разделить программный код на множество фрагментов для удобства редактирования но перед компиляцией они автоматически объединялись один файл программы который итоге обрабатывался компилятором такая реализация модульности примитивна имеет множество очевидных недостатков поэтому она была быстро заменена современные реализации языка паскаль начиная ucsd pascal поддерживают модули программные модули могут быть двух видов модуль главной программы который как обычно начинается ключевого слова program тело которого содержит код запускаемый после загрузки программы память вспомогательных модулей содержащих типы константы переменные процедуры функции предназначенные для использования других модулях том числе главном модуле структура общая структура подключаемого модуля на паскале выглядит следующим образом unit unitname interface implementation begin может отсутствовать используется если необходимо поместить операторы инициализации end возможен также ещё один вариант unit unitname interface implementation initialization finalization end отличие от главной программы файл модуля начинается ключевого слова unit за которым следует имя модуля точка запятой современные реализации как правило требуют чтобы имя модуля совпадало именем файла исходного кода котором этот модуль содержится модуль содержит три секции интерфейсную секцию секцию реализации тело модуля интерфейсная секция идёт первой начинается ключевого слова interface заканчивается том месте модуля где начинается секция реализации или тело интерфейсной секции объявляются те объекты типы константы переменные процедуры функции для них помещаются заголовки которые должны быть доступны извне модуля при этом допускается частичное объявление типов они могут объявляться без указания структуры одним только именем при использовании такого типа во внешней программе допускается объявление переменных параметров этого типа присваивание значений но невозможно получить доступ деталям его реализации процедуры функции интерфейсной секции объявляются виде форвардов заголовков параметрами но без тела состав интерфейсной секции модуля таков что его достаточно для генерации кода использующего данный модуль переменные объявленные интерфейсной секции являются глобальными то есть существуют единственном экземпляре доступны во всех частях программы использующих данный модуль секция реализации следует за интерфейсной начинается ключевого слова implementation нём располагаются описания процедур функций объявленных интерфейсной секции также описания типов констант переменных процедур функций которые необходимы для реализации интерфейсных процедур функций описание процедуры или функции объявленной интерфейсной секции должно иметь точности такой же заголовок как объявлении теле могут использоваться другие процедуры функции данного модуля объявленные как интерфейсной части так секции реализации переменные объявленные секции реализации являются по сути глобальными то есть существует только один экземпляр каждой такой переменной на всю программу но доступны они только из процедур функций описанных секции реализации данного модуля также из его тела если интерфейсной секции есть сокращённые объявления типов то эти типы должны быть полностью описаны секции реализации тело модуля начинается находящимся на верхнем уровне вложенности ключевым словом begin тело содержит программный код который выполняется один раз при загрузке модуля тело может применяться для инициализации присваивания начальных значений переменным модуля выделения ресурсов для его работы так далее тело модуля может отсутствовать ряде реализаций паскаля например delphi вместо тела модуля могут применяться две секции также необязательные initialization finalization они располагаются конце модуля после ключевого слова первая секция инициализации содержит код который должен быть выполнен при загрузке модуля вторая секция финализации код который будет выполнен при выгрузке модуля секция финализации может выполнять действия обратные инициализации удалять объекты из памяти закрывать файлы освобождать выделенные ресурсы модуль заканчивается ключевым словом end точкой использование чтобы использовать модуль главная программа или другой модуль должны импортировать данный модуль то есть содержать объявление его использовании это объявление делается помощью инструкции подключения модулей представляющей собой ключевое слово uses за которым через запятую следуют имена модулей которые требуется подключить инструкция подключения должна следовать непосредственно за заголовком программы либо после ключевого слова interface если подключение производится модуле модули подключённые интерфейсной секции могут использоваться во всём модуле секции реализации теле но секция реализации может иметь собственную инструкцию подключения она следует за ключевым словом implementation содержащую имена подключаемых модулей которые отсутствуют интерфейсной секции но нужны для секции реализации одним из поводов использования отдельного списка подключения для раздела реализации является ситуация когда два или более модуля используют друг друга чтобы не возникали циклические ссылки объявлениях использования таких модулей по крайней мере один из них должен подключать другой секции реализации любые объявленные интерфейсных секциях модулей объекты можно использовать программе там где эти модули подключены имена импортированных из подключённых модулей объектов остаются теми же самыми их можно использовать непосредственно если два или более подключённых модуля имеют объекты называемые одинаково компилятор не может их различить то при попытке использования такого объекта будет выдана ошибка компиляции неоднозначное задание имени этом случае программист должен применять квалификацию имени указать имя формате проблемы могут возникнуть если появляется необходимость использования программе двух разных одноимённых модулей если модули доступны только виде то есть поменять их имена невозможно оказывается невозможным их одновременный импорт стандартного решения такой коллизии на уровне языка не существует но конкретные компиляторы могут предлагать те или иные способы её обхода частности средства назначения псевдонимов импортируемым модулям прямого указания какой модуль из какого файла брать компиляция компоновка модули спроектированы расчёте на обеспечение раздельной компиляции компилятор не должен компилировать импортированные модули для того чтобы откомпилировать модуль который их использует однако чтобы правильно компилировать модуль компилятор должен иметь доступ секции интерфейса всех используемых им модулей существует два разных иногда совмещаемых подхода организации такого доступа модули компилируются бинарные файлы специального формата каждого компилятора своего которых сохранена подробная информация об объектах объявленных интерфейсной секции также может содержаться созданный при компиляции модуля объектом языке но использует при этом только интерфейсную секцию модуля если библиотечный модуль поставляется виде без полных исходных текстов то вместе бинарным файлом идёт урезанный файл исходного кода модуля содержащий только интерфейсную секцию компилятору этого достаточно чтобы правильно обрабатывать обращения из использующих модулей на этапе сборки программы компоновщик просто включает программу бинарный файл загрузка выгрузка модулей для нормальной работы модуля может потребоваться выполнить некоторые действия до начала его использования переменные открыть нужные файлы выделить память или другие ресурсы всё это может быть сделано теле модуля либо секции инициализации действия обратные инициализации делаются секции финализации порядок инициализации финализации модулей косвенно определяется порядком объявления секции uses но для статически программ где модуль либо компилируется один исполняемый файл главной программой либо находится отдельной динамической библиотеке но загружается на этапе первоначальной загрузки компилятор всегда гарантирует что инициализация будет выполнена до момента первого использования модуля финализация выполняется при завершении работы программы после завершения главного модуля так что используемые модули финализируются позже чем использующие их случае динамической загрузки модулей управляемой самим программистом инициализаторы выполняются при загрузке то есть момент когда команда загрузки модуля вернула управление инициализатор его уже выполнен финализатор выполняется после выгрузки обычно при выполнении команды выгрузки модуля если эта команда не вызывается динамически загруженные модули финализируются так же как все остальные при завершении программы объектно ориентированное object pascal имеется возможность разрабатывать программы применением парадигмы объектно классы задаются помощью типа object аналогичного record который кроме полей данных может содержать заголовки процедур методов имена описываемых методов следуют за именем класса через точку конструктор деструктор задаются как обычные процедуры но вместо идентификатора procedure задаются ключевые слова constructor destructor соответственно отличие от подобных языков они имеют имя отличное от имени класса деструкторов может быть несколько они могут иметь параметры на практике эта возможность используется редко обычно класс имеет единственный деструктор destroy виртуальный деструктор класса родителя поддерживаются единичное наследование полиморфизм классов механизм виртуальных методов слово virtual после заголовка метода класса существуют динамические методы tp описываются путём добавления целого числа после слова virtual используются преимущественно для обработки сообщений delphi freepascal для этих целей используется слово message для создания обычных динамических методов слово dynamic отличающиеся меньшим использованием памяти меньшей скоростью вызова за счёт отсутствия дублирования динамических методов предков vmt потомка однако freepascal не делает различий между виртуальными динамическими методами delphi fpc реализована перегрузка операций абстрактные методы директивы private protected public published по умолчанию члены класса являются public диалекте delphi классы могут также помощью слова class причём взаимное наследование object классами не допускается введены интерфейсы interface все методы абстрактные не могут содержать полей данных все классы созданные помощью class являются наследниками tobject все интерфейсы происходят от iunknown классы созданные помощью class могут реализовывать несколько интерфейсов delphi интерфейсы были введены для поддержки технологии com фирмы microsoft классы class отличие от обычных классов object не нуждаются явном выделении освобождении памяти память под них динамически выделяется конструктором именем create вызываемым именем класса освобождается при вызове деструктора именем destroy могут иметь другие имена переменная такого класса отличие от класса object хранит адрес экземпляра класса памяти значение nil используется для указания пустой ссылки поэтому для освобождения объекта tobject определён специальный метод free проверяющий ссылку на nil вызывающий виртуальный деструктор destroy код использованием таких классов будет выглядеть следующим образом модификации objectpascal delphi freepascal описании классов появляются свойства property которые совмещают удобство работы переменными роль которых ооп играют поля вызовы методов которые всегда уведомляют объект об изменении его состояния первом случае использование myobj fprop поле объекта было изменено непосредственно итоге методы объекта не будут подозревать что это поле было ранее изменено более сложном случае они могут полагаться на то что поле неизменно либо же полю может быть присвоено значение недопустимое для данного объекта во втором случае значение присваивается непосредственно свойству объекта которое ссылается на вызов метода корректно обрабатывающего изменение данного поля этот подход удобен если объект связан визуальным элементом изменение поля отвечающего например за ширину элемента никак не отразится на самом визуальном элементе объект будет дезинформирован относительно реальных размеров элемента корректным подходом без использования свойств является разработка методов на получение установку любого значения поля но работа такими методами будет менее удобна например вместо последней строки надо было бы написать myobj setprop myobj getprop причём метод myobj getprop следовало бы написать для унификации доступа большой интерес представляют индексные свойства которые ведут себя практически так же как массивы заменяя обращение элементу массива вызовом метода тем не менее свойства не являются панацеей при компиляции обращения свойствам непосредственно транслируются вызов методов или прямую работу полями поэтому настоящими переменными свойства не являются частности их невозможно передавать виде var параметров примечания литература стандарты iso programming languages pascal заменён стандартом iso ansi ieee гост системы обработки информации язык паскаль iso information technology programming languages pascal iso iec information technology progamming languages extended pascal ссылки на pascal online tutorial rus pascal central паскальные исходники со всего мира сайт программе статья паскале энциклопедии progopedia ru категория семейство языков паскаль категория языки для образования категория статьи примерами кода паскаль категория языки со статическим распределением памяти