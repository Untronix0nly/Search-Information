sqlj подмножество стандарта sql направленное на объединение преимуществ синтаксиса языков sql java ради удобства реализации бизнес логики работы данными данный стандарт разработан консорциумом состоящим из компаний ibm micro focus microsoft compaq точнее его подразделение занимающееся субд которое скорее можно отнести приобретенной компании tandem informix oracle sun sybase предыстория на момент появления консорциума jsql впоследствии ставшего одноимённым разрабатываемым им стандартом году идея взаимодействии реляционных субд программ на java была не нова компанией javasoft дочерним подразделением компании sun уже был разработан интерфейс jdbc соединение бд средствами java включённый стандарт языка начиная момента выпуска jdk однако силу определённых причин см sqlj jdbc возможностей предоставляемых этим интерфейсом было недостаточно спецификация стандарта sqlj состоит из трех частей уровень регламентирует встраивание sql операторов текст программы на java уровень определяет обратное включение именно реализацию использующих sql субд хранимых процедур функций на языке java уровень устанавливает соответствие между типами данных концу года все три уровня спецификации были завершены представлены для рассмотрения ansi качестве дополнений стандарту sql первые две части нового стандарта были включены соответственно части sql olb sql psm стандарта sql третья часть вошла как отдельный модуль sql jrt стандарт sql обычно применительно разработке приложений работающих бд под sqlj обычно понимается именно уровень пример кода приведем простой пример java класса использующего sqlj для получения результатов запроса из oracle import java sql import oracle sqlj runtime oracle public class singlerowquery extends base public static void main string args try connect singlerowquery catch sqlexception printstacktrace public static void singlerowquery int id throws sqlexception string fullname null string street null sql select fullname street into out fullname out street from customer where id in id system out println customer with id id system out println system out println fullname street из рассмотрения приведённого кода ясно что сам текст процедуры singlerowquery встраивается sql запрос встраивание это организовано по определённым правилам текст запроса находится внутри директивы sql переменные внешние по отношению sql запросу задаются внутри него определенном формате подробно все синтаксические конструкции будут рассмотрены далее sqlj jdbc логично возникновение вопроса причинах создания двух параллельных стандартов для реализации технологий доступа субд для начала стоит отметить что sqlj jdbc относятся разным семействам стандартов концептуально они разные jdbc является api входящим стандарт языка java ориентированным на передачу сформированной программой sql конструкции бд также обработку результата sqlj же является подмножеством стандарта sql sql olb для него первичным является понятие базы данных язык который включаются sql конструкции вторичен согласно этому стандарту встраивание sql операторов допускается не только java но языки ada cobol fortran mumps pl далее использование sqlj на самом деле неявно подразумевает вызов jdbc методов так как данном случае они выполняют роль соответственно высоко низкоуровневого api если углубиться подробности реализации технологий sqlj jdbc то можно обнаружить что любые sqlj директивы прозрачно для программиста специальной подсистемой называемой sqlj препроцессором транслируются jdbc вызовы благодаря этому можно спокойно сочетать одном фрагменте кода sqlj jdbc вызовы при необходимости используя общий контекст на самом деле каждом конкретном случае когда требуется выполнение sql оператора выбор между sqlj jdbc стоит делать исходя из характера предполагаемой операции если это сложный поисковый запрос возможными вариациями по количеству условий на поиск тогда однозначно более целесообразно будет формирование текстовой строки запроса последующее его выполнение через jdbc если же требуется просто подстановка каких то переменных либо вычислимых выражений тогда эргономичнее части длины кода будет написать sqlj директиву синтаксис для того чтобы эффективно использовать синтаксические новшества вносимые стандартом sqlj необходимо предварительно разобраться их особенностях связанных процессом разбора sqlj конструкций любые sqlj конструкции начинаются директивы sql частности блоки содержащие внутри себя собственно sql запросы задаются как sql внешние переменные терминологии sqlj внешней переменной называется переменная sqlj конструкции используемая для получения значений или передачи их во внешнюю относительно конструкции программную среду примеру int sql select field into out from table where id in system out println внешние переменные для избежания должны задаваться определённом виде именно inout модификаторы in out inout опциональны используются для указания переменных соответственно передающих значение извне sqlj конструкцию возвращающих значение вовне выполняющих обе функции данные ключевые слова используются не только для этого также они задают метод доступа внешним переменным внутри sqlj конструкции при наличии модификатора in возможно только чтение значения переменной при наличии out только запись при наличии inout полный доступ по умолчанию при отсутствии явно заданного модификатора переменные объявляются неявным модификатором inout внешние выражения вместо просто переменных sqlj конструкциях можно использовать выражения содержащие внешние переменные чаще называемые просто внешними выражениями они имеют определённый синтаксис основной нюанс при использовании внешних выражений заключается том что их использование может повлечь за собой определённые последствия связанные тем что разбор sqlj конструкции препроцессором при наличии нескольких внешних выражений идёт определённом порядке при использовании выражениях присваиваний результат присваивания может быть передан программную среду для иллюстрации данных двух моментов разберем простой пример использования внешних выражений int sql select result from table where field xi and field yi and field zi system out println исходя из опыта можно попытаться предположить что значение переменной процессе разбора sql выражения не будет изменяться сформированный запрос будет иметь вид select result from table where field and field and field однако первое второе утверждения неверны для проверки этого составим простую схему проясняющую порядок разбора данной конструкции sqlj препроцессором xi yi zi следовательно после выполнения sqlj директивы будет иметь место выполняться будет запрос select result from table where field and field and field контексты терминологии sqlj jdbc контекстом подключения называется совокупность из трёх параметров однозначно ими определяемая название базы данных идентификатор сессии идентификатор активной транзакции для любой sqlj конструкции контекст котором она будет исполняться можно определить явно sql рамках директивы sql можно также создавать новые контексты для последующего использования sql context если контекст явно не задан то конструкция считается выполняемом контексте по умолчанию при необходимости контекст по умолчанию может быть изменён итераторы итератором терминологии стандарта sqlj называется объект для хранения результата запроса возвращающего более одной записи по своей сути реализации он представляет собой не просто множество записей множество некоторым упорядочением на нём позволяющим использовать полученные записи последовательно этом плане итератор имеет много общего курсором стандартом предусмотрены два типа итераторов разница между ними достаточно интересна итераторы привязкой по позиции использовании требуют более sql подобного синтаксиса отличие от итераторов привязкой по столбцам которые очень близки по использованию объектам итераторы привязкой по позиции первым типом итератора является итератор привязкой по позициям он объявляется следующим образом sql public iterator bypos string int ясно видно что данном случае привязка результатов запроса итератору осуществляется просто по совпадению типов данных между итератором результатом запроса однако для этого требуется чтобы типы данных итератора результата запроса могли быть отображены друг на друга согласно стандарту sql jrt создадим простую таблицу create table people fullname varchar birthyear numeric теперь помощью итератора первого типа конструкции fetch into произведем выборку данных из результата запроса bypos positer string name null int year sql positer select fullname birthyear from people for sql fetch positer into name year if positer endfetch break system out println name was born in year первой директивой осуществляется привязка результата запроса итератору второй помощью конструкции fetch into из результата последовательно считывается по одной записи итераторы именованием столбцов вторым типом итератора более приближенного по использованию обычным объектам является итератор именованием столбцов для указанной таблицы создание итератора второго типа будет выглядеть следующим образом sql public iterator byname string fullname int birthyear используется он как обычный объект именно доступ полям осуществляется через соответствующие акцессорные методы byname namiter sql namiter select fullname birthyear from people string int while namiter next namiter birthyear namiter fullname system out println was born in однако существует правило которое должно быть соблюдено имена полей итератора должны совпадать без учёта регистра именами полей запросе это связано процессом разбора sqlj конструкции препроцессором случае если имя столбца бд имеет название несовместимое правилами именования переменных java необходимо использовать запросе формирующем итератор псевдонимы вызовы процедур функций вызовы процедур очень просто записываются использованием внешних переменных sql call proc myarg функции свою очередь вызываются использованием конструкции value int sql values func взаимодействие jdbc так как sqlj директивы при своём использовании используют jdbc вызовы то представляет интерес возможность использовать эти технологии совместно достаточно легко преобразовывать итераторы объекты resultset наоборот преобразование объекта resultset осуществляется очень просто для этого сначала нужно определить итератор именованием столбцов нашем примере он будет обозначаться employees затем выполнить операцию cast sql iterator employees string ename double sal stmt conn string query select ename sal from emp where query whereclause resultset rs stmt executequery query employees emps sql emps cast rs while emps next system out println emps ename earns emps sal emps close stmt close отдельно стоит обратить внимание что после привязки результата запроса итератору отдельно закрывать результат запроса нет надобности это за программиста сделает сам препроцессор обратный процесс преобразование итератора объект resultset производится помощью итераторов особого типа так называемых слабо типизированных итераторов sqlj runtime iter sql iter select ename from emp resultset rs iter getresultset while rs next system out println employee name rs getstring iter close этом случае связь между итератором результатом запроса также сохраняется закрывать следует именно итератор особенности sqlj как уже упоминалось ранее сравнивать sqlj как технологию проще всего аналогичной java ориентированной технологией того же назначения именно jdbc ситуация усложняется тем что эти технологии не параллельны не вполне взаимозаменяемы находятся друг над другом архитектурно запрос одинакового назначения записанный jdbc вызовах sqlj директиве большинстве случаев будет более компактно записан тексте программы именно во втором случае что уменьшает размер листинга вероятность ошибки связанной со сборкой итоговой строки запроса из небольших фрагментов любая sqlj директива на этапе компиляции разбирается проверяется препроцессором следовательно все ошибки синтаксиса выявляются ещё на этом этапе отличие от jdbc где контролируется правильность конструкций только точки зрения синтаксиса java за разбор правильность собственно запроса отвечает уже субд что естественно приводит тому что ошибки такого рода будут выявлены уже на этапе запуска собственно сам препроцессор обычно имеющий название sqlj не входит jdk он необходимые для его работы библиотеки обычно предоставляются производителем субд это закономерно как показано выше sqlj гораздо более близок субд чем собственно языку java более того препроцессор должен учитывать особенности sql синтаксиса своей субд большинстве случаев особенно это касается часто выполняющихся сложных запросов работающих большими массивами данных sqlj директива будет выполняться среднем быстрее аналогичного набора jdbc вызовов это связано тем что план для запроса случае sqlj директивы будет строиться только один раз затем использоваться повторно отличие от jdbc где построение плана будет осуществляться при каждом вызове создаваемый при трансляции sqlj директивы план запроса при необходимости может быть подвергнут настройке со стороны пользователя случае jdbc такая возможность по понятным причинам отсутствует если запрос требует значительных изменений каждом конкретном случае простой пример поисковый запрос по набору полей значения части которых могут отсутствовать то проще использовать jdbc так как преимуществ использовании sqlj здесь нет так как при использовании jdbc нет надобности дополнительном этапе обработки кода трансляции то процесс компиляции этом случае будет быстрее недостатки sqlj sqlj требует дополнительного шага большинство ide не имеют поддержки sqlj sqlj не имеет поддержки большинстве orm фреймворков таких как hibernate поддержка программными средствами oracle db informix http www ibm com software data informix pubs library iif html см embedded sqlj user guide ссылки категория java категория стандарты языка sql