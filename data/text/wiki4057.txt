объе ктно ориенти рованное программи рование ооп методология основанная на представлении программы виде совокупности объектов каждый из которых является экземпляром определённого класса классы образуют иерархию наследования идеологически ооп подход как моделированию информационных объектов решающий на новом уровне основную задачу структурного информации точки зрения управляемости что существенно улучшает управляемость самим процессом моделирования что свою очередь особенно важно при реализации крупных проектов управляемость для иерархических систем предполагает минимизацию избыточности данных аналогичную нормализации их целостность поэтому созданное удобно управляемым будет удобно пониматься таким образом через тактическую задачу управляемости решается стратегическая задача транслировать понимание задачи программистом наиболее удобную для дальнейшего использования форму основные принципы случае ооп связаны различными аспектами базового понимания предметной задачи которое требуется для оптимального управления соответствующей моделью абстрагирование для выделения моделируемом предмете важного для решения конкретной задачи по предмету конечном счёте контекстное понимание предмета формализуемое виде класса инкапсуляция для быстрой безопасной организации собственно иерархической управляемости чтобы было достаточно простой команды что делать без одновременного уточнения как именно делать так как это уже другой уровень управления наследование для быстрой безопасной организации родственных понятий чтобы было достаточно на каждом иерархическом шаге учитывать только изменения не дублируя всё остальное учтённое на предыдущих шагах полиморфизм для определения точки которой единое управление лучше распараллелить или наоборот собрать воедино то есть фактически речь идёт прогрессирующей организации информации согласно первичным семантическим критериям важное неважное ключевое подробности родительское дочернее единое множественное частности на последнем этапе даёт возможность перехода на следующий уровень детализации что замыкает общий процесс обычный человеческий язык целом отражает идеологию ооп начиная инкапсуляции представления предмете виде его имени заканчивая полиморфизмом использования слова переносном смысле что итоге развивает выражение представления через имя предмета до полноценного понятия класса основные понятия абстракция данных абстрагирование означает выделение значимой информации исключение из рассмотрения незначимой ооп рассматривают лишь абстракцию данных нередко называя её просто абстракцией подразумевая набор наиболее значимых характеристик объекта доступных остальной программе инкапсуляция инкапсуляция свойство системы позволяющее объединить данные методы работающие ними классе одни языки например java или ruby отождествляют инкапсуляцию сокрытием но другие smalltalk eiffel ocaml различают эти понятия наследование наследование свойство системы позволяющее описать новый класс на основе уже существующего частично или полностью заимствующейся класс от которого производится наследование называется базовым родительским или суперклассом новый класс потомком наследником дочерним или производным классом полиморфизм подтипов полиморфизм подтипов ооп называемый просто полиморфизмом свойство системы позволяющее использовать объекты одинаковым интерфейсом без информации типе внутренней структуре объекта другой вид полиморфизма параметрический ооп называют обобщённым класс класс универсальный комплексный тип данных состоящий из тематически единого набора полей переменных более элементарных типов методов функций для работы этими полями то есть он является моделью информационной сущности внутренним внешним интерфейсами для оперирования своим содержимым значениями полей частности классах широко используются специальные блоки из одного или чаще двух спаренных методов отвечающих за элементарные операции определённым полем интерфейс присваивания считывания значения которые имитируют доступ полю эти блоки называются свойствами почти совпадают по конкретному имени со своим полем например имя поля может начинаться со строчной имя свойства заглавной буквы другим проявлением интерфейсной природы класса является то что при копировании соответствующей переменной через присваивание копируется только интерфейс но не сами данные то есть класс ссылочный тип данных переменная объект относящаяся заданному классом типу называется экземпляром этого класса при этом некоторых исполняющих системах класс также может представляться некоторым объектом при выполнении программы посредством динамической идентификации типа данных обычно классы разрабатывают таким образом чтобы обеспечить отвечающие природе объекта решаемой задаче целостность данных объекта также удобный простой интерфейс свою очередь целостность предметной области объектов их интерфейсов также удобство их проектирования обеспечивается наследованием объект сущность адресном пространстве вычислительной системы появляющаяся при создании экземпляра класса например после запуска результатов компиляции связывания исходного кода на выполнение классификация подвидов ооп мартин абади построили теоретическое обоснование ооп классификацию на основе этого обоснования они отмечают что выделенные ими понятия категории вместе встречаются далеко не во всех оо языках большинство языков поддерживают лишь подмножества теории порой своеобразные отклонения от неё ключевые понятия квантификация переменных типа универсальная отношения супертип подтип включение см принцип подстановки барбары лисков частный случай подтипизации см подтипизация на записях объект объектный тип фактически специальная форма записи число полей которой входят функции первого класса класс класс описывает абстрактное поведение объектные типы строятся на основе класса посредством добавления различных приватных полей методов объект то есть значение объектного типа традиционно называемое экземпляром класса порождается конструктором на основе начальных параметров традиционно перечисляемые основные принципы ооп не аппелируют данному теоретическому обоснованию являются устоявшимися сообществе догмами что приводит сильному разбросу вариантов изложения разных источниках по большей части они относятся языкам потомкам алгола симулы меньшей степени потомкам smalltalk частности часто упоминаемый принцип сокрытия потомках smalltalk семантически недоступен идеологически считается несущественным значительно большей степени теоретически обоснованные концепции ооп поддерживают оо языки развившиеся на поприще функционального ocaml диалекты haskell haskell mondrian successor ml более того основные идеи объектного моделирования этом случае не требуют прямой поддержки со стороны языка могут быть сравнительно легко эмулированы наиболее заметные отличия проявлении показателей качества между языками разных видов мейнстримных языках декларируемые принципы нацелены на повышение изначально низкого для императивного коэффициента повторного использования кода полиморфно типизированных применение концепций ооп напротив означает очевидное его снижение из за перехода от полиморфизма ad hoc полиморфизму динамически типизированных языках smalltalk python ruby эти принципы используются для логической организации программы их влияние на коэффициент повторного использования трудно спрогнозировать он сильно зависит от дисциплины программиста например clos мультиметоды одновременно являются функциями первого класса что позволяет рассматривать их одновременно как как обобщённые истинно полиморфные традиционные оо языки используют то есть допустимость соиспользования объектов разных классов только при условии явного указания родственных отношений между классами для полиморфно типизированных языков характерна то есть согласование классов между собой тем же механизмом что согласование числа типом int динамически типизированные языки также занимают здесь промежуточную позицию обобщённое обоснование включая множественную середине годов построил джузеппе кастанья история ооп возникло результате развития идеологии процедурного где данные подпрограммы процедуры функции их обработки формально не связаны для дальнейшего развития объектно часто большое значение имеют понятия события так называемое событийно ориентированное компонента компонентное коп взаимодействие объектов происходит посредством сообщений результатом дальнейшего развития ооп по видимому будет агентно ориентированое где агенты независимые части кода на уровне выполнения взаимодействие агентов происходит посредством изменения среды которой они находятся языковые конструкции конструктивно не относящиеся непосредственно объектам но сопутствующие им для их безопасной исключительные ситуации проверки эффективной работы инкапсулируются от них аспекты аспектно ориентированном субъектно ориентированное расширяет понятие объекта посредством обеспечения более независимого взаимодействия объектов может являться переходной стадией между ооп агентным части их взаимодействия первым языком котором были предложены основные понятия впоследствии сложившиеся парадигму была симула но термин объектная не использовался контексте использования этого языка момент его появления году нём были предложены революционные идеи объекты классы виртуальные методы др однако это всё не было воспринято современниками как нечто грандиозное фактически симула была алголом классами упрощающим выражение процедурном многих сложных концепций понятие класса симуле может быть полностью определено через композицию конструкций алгола то есть класс симуле это нечто сложное описываемое посредством примитивов взгляд на под новым углом отличным от процедурного предложили алан кэй дэн ингаллс языке smalltalk здесь понятие класса стало идеей для всех остальных конструкций языка то есть класс смолтоке является примитивом посредством которого описаны более сложные конструкции именно он стал первым широко объектно ориентированным языком настоящее время количество прикладных языков список языков реализующих объектно ориентированную парадигму является наибольшим по отношению другим парадигмам наиболее промышленности языки delphi java др воплощают объектную модель симулы примерами языков опирающихся на модель смолтока являются objective python ruby определение ооп его основные концепции центре ооп находится понятие объекта объект это сущность которой можно посылать сообщения которая может на них реагировать используя свои данные объект это экземпляр класса данные объекта скрыты от остальной программы сокрытие данных называется инкапсуляцией наличие инкапсуляции достаточно для объектности языка но ещё не означает его объектной для этого требуется наличие наследования но даже наличие инкапсуляции наследования не делает язык полной мере объектным точки зрения ооп основные преимущества ооп проявляются только том случае когда языке реализован полиморфизм подтипов возможность единообразно обрабатывать объекты различной реализацией при условии наличия общего интерфейса сложности определения ооп имеет уже более чем сорокалетнюю историю но несмотря на это до сих пор не существует чёткого общепринятого определения данной технологии основные принципы заложенные первые объектные языки системы подверглись существенному изменению или искажению дополнению при многочисленных реализациях последующего времени кроме того примерно середины годов термин объектно ориентированный стал модным результате ним произошло то же самое что несколько раньше термином структурный ставшим модным после распространения технологии структурного его стали искусственно прикреплять любым новым разработкам чтобы обеспечить им бьёрн страуструп году писал что обоснование объектной чего либо большинстве случаев сводится некорректному силлогизму это хорошо объектная это хорошо следовательно является объектно ориентированным тимоти бадд пишет роджер кинг настаивал что его кот является объектно ориентированным кроме прочих своих достоинств кот демонстрирует характерное поведение реагирует на сообщения наделён унаследованными реакциями управляет своим вполне независимым внутренним состоянием по мнению алана кэя создателя языка smalltalk которого считают одним из отцов основателей ооп объектно ориентированный подход заключается следующем наборе основных принципов цитируется по вышеупомянутой книге бадда всё является объектом вычисления осуществляются путём взаимодействия обмена данными между объектами при котором один объект требует чтобы другой объект выполнил некоторое действие объекты взаимодействуют посылая получая сообщения сообщение это запрос на выполнение действия дополненный набором аргументов которые могут понадобиться при выполнении действия каждый объект имеет независимую память которая состоит из других объектов каждый объект является представителем класса который выражает общие свойства объектов таких как целые числа или списки классе задаётся поведение объекта тем самым все объекты которые являются экземплярами одного класса могут выполнять одни те же действия классы организованы единую древовидную структуру общим корнем называемую иерархией наследования память поведение связанное экземплярами определённого класса автоматически доступны любому классу расположенному ниже иерархическом дереве таким образом программа представляет собой набор объектов имеющих состояние поведение объекты взаимодействуют посредством сообщений естественным образом выстраивается иерархия объектов программа целом это объект для выполнения своих функций она обращается входящим неё объектам которые свою очередь выполняют запрошенное путём обращения другим объектам программы естественно чтобы избежать бесконечной рекурсии обращениях на каком то этапе объект трансформирует обращённое нему сообщение сообщения стандартным системным объектам предоставляемым языком средой устойчивость управляемость системы обеспечивается за счёт чёткого разделения ответственности объектов за каждое действие отвечает определённый объект однозначного определения интерфейсов межобъектного взаимодействия полной изолированности внутренней структуры объекта от внешней среды инкапсуляции определить ооп можно многими другими способами концепции появление ооп отдельного понятия класса закономерно вытекает из желания иметь множество объектов со сходным поведением класс ооп это чистом виде абстрактный тип данных создаваемый программистом этой точки зрения объекты являются значениями данного абстрактного типа определение класса задаёт внутреннюю структуру значений набор операций которые над этими значениями могут быть выполнены желательность иерархии классов значит наследования вытекает из требований повторному использованию кода если несколько классов имеют сходное поведение нет смысла дублировать их описание лучше выделить общую часть общий родительский класс описании самих этих классов оставить только различающиеся элементы необходимость совместного использования объектов разных классов способных обрабатывать однотипные сообщения требует поддержки полиморфизма возможности записывать разные объекты переменные одного того же типа таких условиях объект отправляя сообщение может не знать точности какому классу относится адресат одни те же сообщения отправленные переменным одного типа содержащим объекты разных классов вызовут различную реакцию отдельного пояснения требует понятие обмена сообщениями первоначально например том же smalltalk взаимодействие объектов представлялось как настоящий обмен сообщениями то есть пересылка от одного объекта другому специального объекта сообщения такая модель является чрезвычайно общей она прекрасно подходит например для описания параллельных вычислений помощью активных объектов каждый из которых имеет собственный поток исполнения работает одновременно прочими такие объекты могут вести себя как отдельные абсолютно автономные вычислительные единицы посылка сообщений естественным образом решает вопрос обработки сообщений объектами присвоенными полиморфным переменным независимо от того как объявляется переменная сообщение обрабатывает код класса которому относится присвоенный переменной объект данный подход реализован языках smalltalk ruby objective python однако общность механизма обмена сообщениями имеет другую сторону полноценная передача сообщений требует дополнительных накладных расходов что не всегда приемлемо поэтому во многих современных объектно ориентированных языках используется концепция отправка сообщения как вызов метода объекты имеют доступные извне методы вызовами которых обеспечивается взаимодействие объектов данный подход реализован огромном количестве языков том числе object pascal java oberon однако это приводит тому что сообщения уже не являются объектами как следствие не имеют атрибутов что сужает возможности некоторые языки используют гибридное представление демонстрируя преимущества одновременно обоих подходов например clos python концепция виртуальных методов поддерживаемая этими другими современными языками появилась как средство обеспечить выполнение нужных методов при использовании полиморфных переменных то есть по сути как попытка расширить возможности вызова методов для реализации части обеспечиваемой механизмом обработки сообщений особенности реализации как уже говорилось выше современных объектно ориентированных языках каждый объект является значением относящимся определённому классу класс представляет собой объявленный программистом составной тип данных имеющий составе поля данных параметры объекта конечно не все только необходимые программе задающие его состояние свойства объекта предметной области иногда поля данных объекта называют свойствами объекта из за чего возможна путаница фактически поля представляют собой значения переменные константы объявленные как принадлежащие классу методы процедуры функции связанные классом они определяют действия которые можно выполнять над объектом такого типа которые сам объект может выполнять классы могут наследоваться друг от друга класс потомок получает все поля методы класса родителя но может дополнять их собственными либо переопределять уже имеющиеся большинство языков поддерживает только единичное наследование класс может иметь только один класс родитель лишь некоторых допускается множественное наследование порождение класса от двух или более классов родителей множественное наследование создаёт целый ряд проблем как логических так чисто реализационных поэтому полном объёме его поддержка не распространена вместо этого годы появилось стало активно вводиться объектно ориентированные языки понятие интерфейса интерфейс это класс без полей без реализации включающий только заголовки методов если некий класс наследует или как говорят реализует интерфейс он должен реализовать все входящие него методы использование интерфейсов предоставляет относительно дешёвую альтернативу множественному наследованию взаимодействие объектов абсолютном большинстве случаев обеспечивается вызовом ими методов друг друга инкапсуляция обеспечивается следующими средствами контроль доступа поскольку методы класса могут быть как чисто внутренними обеспечивающими логику объекта так внешними помощью которых взаимодействуют объекты необходимо обеспечить скрытость первых при доступности извне вторых для этого языки вводятся специальные синтаксические конструкции явно задающие область видимости каждого члена класса традиционно это модификаторы public protected private обозначающие соответственно открытые члены класса члены класса доступные внутри класса из классов потомков скрытые доступные только внутри класса конкретная номенклатура модификаторов их точный смысл различаются разных языках методы доступа поля класса общем случае не должны быть доступны извне поскольку такой доступ позволил бы произвольным образом менять внутреннее состояние объектов поэтому поля обычно объявляются скрытыми либо язык принципе не позволяет обращаться полям класса извне для доступа находящимся полях данным используются специальные методы называемые методами доступа такие методы либо возвращают значение того или иного поля либо производят запись это поле нового значения при записи метод доступа может допустимость записываемого значения при необходимости произвести другие манипуляции данными объекта чтобы они остались корректными внутренне согласованными методы доступа называют ещё аксессорами от доступ по отдельности геттерами чтение сеттерами запись свойства объекта псевдополя доступные для чтения или записи свойства внешне выглядят как поля используются аналогично доступным полям некоторыми исключениями однако фактически при обращении ним происходит вызов методов доступа таким образом свойства можно рассматривать как умные поля данных сопровождающие доступ внутренним данным объекта какими либо дополнительными действиями например когда изменение координаты объекта сопровождается его перерисовкой на новом месте свойства по сути не более чем синтаксический сахар поскольку никаких новых возможностей они не добавляют лишь скрывают вызов методов доступа конкретная языковая реализация свойств может быть разной например объявление свойства непосредственно содержит код методов доступа который вызывается только при работе со свойствами то есть не требует отдельных методов доступа доступных для вызова delphi объявление свойства содержит лишь имена методов доступа которые должны вызываться при обращении полю сами методы доступа представляют собой обычные методы некоторыми дополнительными требованиями сигнатуре полиморфизм реализуется путём введения язык правил согласно которым переменной типа класс может быть присвоен объект любого класса потомка её класса проектирование программ целом ооп ориентировано на разработку крупных программных комплексов разрабатываемых командой программистов возможно достаточно большой проектирование системы целом создание отдельных компонентов их объединение конечный продукт при этом часто выполняется разными людьми нет ни одного специалиста который знал бы проекте всё объектно ориентированное проектирование ориентируется на описание структуры проектируемой системы приоритетно по отношению описанию её поведения отличие от функционального то есть фактически ответе на два основных вопроса из каких частей состоит система чём состоит ответственность каждой из её частей выделение частей производится таким образом чтобы каждая имела минимальный по объёму точно определённый набор выполняемых функций обязанностей при этом другими частями как можно меньше дальнейшее уточнение приводит выделению более мелких фрагментов описания по мере детализации описания определения ответственности выявляются данные которые необходимо хранить наличие близких по поведению агентов которые становятся кандидатами на реализацию виде классов общими предками после выделения компонентов определения интерфейсов между ними реализация каждого компонента может проводиться практически независимо от остальных разумеется при соблюдении соответствующей технологической дисциплины большое значение имеет правильное построение иерархии классов одна из известных проблем больших систем построенных по ооп технологии так называемая проблема хрупкости базового класса она состоит том что на поздних этапах разработки когда иерархия классов построена на её основе разработано большое количество кода оказывается трудно или даже невозможно внести какие либо изменения код базовых классов иерархии от которых порождены все или многие работающие системе классы даже если вносимые изменения не затронут интерфейс базового класса изменение его поведения может непредсказуемым образом отразиться на классах потомках случае крупной системы разработчик базового класса просто не состоянии предугадать последствия изменений он даже не знает том как именно базовый класс используется от каких особенностей его поведения зависит корректность работы классов потомков различные ооп методологии компонентное следующий этап развития ооп прототип класс ориентированное разные подходы созданию программы которые могут комбинироваться имеющие свои преимущества недостатки компонентное компонентно ориентированное это своеобразная надстройка над ооп набор правил ограничений направленных на построение крупных развивающихся программных систем большим временем жизни программная система этой методологии представляет собой набор компонентов хорошо определёнными интерфейсами изменения существующую систему вносятся путём создания новых компонентов дополнение или качестве замены ранее существующих при создании новых компонентов на основе ранее созданных запрещено использование наследования реализации новый компонент может наследовать лишь интерфейсы базового таким образом компонентное обходит проблему хрупкости базового класса прототипное прототипное сохранив часть черт ооп отказалось от базовых понятий класса наследования прототип это объект образец по образу подобию которого создаются другие объекты объекты копии могут сохранять связь родительским объектом автоматически наследуя изменения прототипе эта особенность определяется рамках конкретного языка вместо механизма описания классов порождения экземпляров язык предоставляет механизм создания объекта путём задания набора полей методов которые объект должен иметь механизм клонирования объектов каждый вновь созданный объект является экземпляром без класса каждый объект может стать прототипом быть использован для создания нового объекта помощью операции клонирования после клонирования новый объект может быть изменён частности дополнен новыми полями методами клонированный объект либо становится полной копией прототипа хранящей все значения его полей дублирующей его методы либо сохраняет ссылку на прототип не включая себя клонированных полей методов до тех пор пока они не будут изменены последнем случае среда исполнения обеспечивает механизм делегирования если при обращении объекту он сам не содержит нужного метода или поля данных вызов передаётся прототипу от него при необходимости дальше по цепочке класс ориентированное класс ориентированное это сфокусированное на данных причём данные поведение неразрывно связаны между собой вместе данные поведение представляют собой класс соответственно языках основанных на понятии класс все объекты разделены на два основных типа классы экземпляры класс определяет структуру поведение одинаковую для всех экземпляров данного класса экземпляр является носителем данных то есть обладает состоянием меняющимся соответствии поведением заданным классом класс ориентированных языках новый экземпляр создаётся через вызов конструктора класса возможно набором параметров получившийся экземпляр имеет структуру поведение жёстко заданные его классом объектных программ гради буч указывает на следующие причины приводящие снижению программ из за использования объектно ориентированных средств динамическое связывание методов обеспечение полиморфного поведения объектов приводит необходимости связывать методы вызываемые программой то есть определять какой конкретно метод будет вызываться не на этапе компиляции процессе исполнения программы на что тратится дополнительное время при этом реально динамическое связывание требуется не более чем для вызовов но некоторые ооп языки используют его постоянно значительная глубина абстракции ооп разработка часто приводит созданию многослойных приложений где выполнение объектом требуемого действия сводится множеству обращений объектам более низкого уровня таком приложении происходит очень много вызовов методов возвратов из методов что естественно сказывается на наследование размывает код код относящийся конечным классам иерархии наследования которые обычно используются программой непосредственно находится не только самих этих классах но их классах предках относящиеся одному классу методы фактически описываются разных классах это приводит двум неприятным моментам снижается скорость трансляции так как компоновщику приходится подгружать описания всех классов иерархии снижается программы системе со страничной памятью поскольку методы одного класса физически находятся разных местах кода далеко друг от друга при работе фрагментов программы активно обращающихся унаследованным методам система вынуждена производить частые переключения страниц инкапсуляция снижает скорость доступа данным запрет на прямой доступ полям класса извне приводит необходимости создания использования методов доступа написание компиляция исполнение методов доступа сопряжены дополнительными расходами динамическое создание уничтожение объектов динамически создаваемые объекты как правило размещаются куче что менее эффективно чем размещение их на стеке тем более статическое выделение памяти под них на этапе компиляции несмотря на отмеченные недостатки буч утверждает что выгоды от использования ооп более весомы кроме того повышение за счёт лучшей организации ооп кода по его словам некоторых случаях компенсирует дополнительные накладные расходы на организацию программы можно также заметить что многие эффекты снижения могут сглаживаться или даже полностью устраняться за счёт качественной оптимизации кода компилятором например упомянутое выше снижение скорости доступа полям класса из за использования методов доступа устраняется если компилятор вместо вызова метода доступа использует инлайн подстановку современные компиляторы делают это вполне уверенно критика ооп несмотря на отдельные критические замечания адрес ооп настоящее время именно эта парадигма используется подавляющем большинстве промышленных проектов однако нельзя считать что ооп является наилучшей из методик во всех случаях критические высказывания адрес ооп было показано отсутствие значимой разницы продуктивности разработки программного обеспечения между ооп процедурным подходом кристофер дэйт указывает на невозможность сравнения ооп других технологий во многом из за отсутствия строгого общепризнанного определения ооп александр степанов одном из своих интервью указывал что ооп методологически неправильно что ооп практически такая же мистификация как искусственный интеллект фредерик брукс указывает что наиболее сложной частью создания программного обеспечения является спецификация дизайн тестирование концептуальных конструкций отнюдь не работа по выражению этих концептуальных конструкций ооп наряду такими технологиями как искусственный интеллект верификация программ автоматическое графическое экспертные системы др по его мнению не является серебряной пулей которая могла бы на порядок величины снизить сложность разработки программных систем согласно бруксу ооп позволяет сократить только привнесённую сложность выражение дизайна дизайн остаётся сложным по своей природе эдсгер дейкстра указывал то чём общество большинстве случаев просит это эликсир от всех болезней естественно эликсир имеет очень впечатляющие названия иначе будет очень трудно что то продать структурный анализ дизайн программная инженерия модели зрелости управляющие информационные системы management information systems интегрированные среды поддержки проектов объектная реинжиниринг бизнес процессов никлаус вирт считает что ооп не более чем тривиальная надстройка над структурным преувеличение её значимости выражающееся том числе во включении языки всё новых модных объектно ориентированных средств вредит качеству программного обеспечения патрик киллелиа своей книге тюнинг веб сервера писал ооп предоставляет вам множество способов замедлить работу ваших программ известная обзорная статья проблем современного ооп перечисляет некоторые типичные проблемы ооп программистском фольклоре получила широкое распространение критика объектно подхода сравнении функциональным подходом использованием метафоры королевства существительных из эссе стива йегги если попытаться критические высказывания адрес ооп можно выделить несколько аспектов критики данного подхода критика рекламы ооп критикуется явно высказываемое или подразумеваемое работах некоторых пропагандистов ооп также рекламных материалах объектно ориентированных средств разработки представление об объектном как некоем всемогущем подходе который магическим образом устраняет сложность как замечали многие том числе упомянутые выше брукс дейкстра серебряной пули не существует независимо от того какой парадигмы придерживается разработчик создание нетривиальной сложной программной системы всегда сопряжено со значительными затратами ресурсов времени из наиболее специалистов области ооп никто как правило не отрицает справедливость критики этого типа оспаривание эффективности разработки методами ооп критики оспаривают тезис том что разработка объектно ориентированных программ требует меньше ресурсов или приводит созданию более качественного по проводится сравнение затрат на разработку разными методами на основании которого делается вывод об отсутствии ооп преимуществ данном направлении учитывая крайнюю сложность объективного сравнения различных разработок подобные сопоставления как минимум спорны другой стороны получается что ровно так же спорны утверждения об эффективности ооп объектно ориентированных программ указывается на то что целый ряд врождённых особенностей ооп технологии делает построенные на её основе программы технически менее эффективными по сравнению аналогичными необъектными программами не отрицая действительно имеющихся дополнительных накладных расходов на организацию работы ооп программ см раздел выше нужно однако отметить что значение снижения часто критиками современных условиях когда технические возможности компьютеров чрезвычайно велики постоянно растут для большинства прикладных программ техническая эффективность оказывается менее существенна чем скорость разработки лишь для некоторого очень ограниченного класса программ по встроенных систем драйверы устройств низкоуровневая часть системного по научное по остаётся критическим фактором критика отдельных технологических решений ооп языках библиотеках эта критика многочисленна но затрагивает она не ооп как таковое приемлемость применимость конкретных случаях тех или иных реализаций её механизмов одним из излюбленных объектов критики является язык входящий число наиболее промышленных ооп языков объектно ориентированные языки многие современные языки специально созданы для облегчения объектно однако следует отметить что можно применять техники ооп для не объектно языка наоборот применение объектно языка вовсе не означает что код автоматически становится объектно ориентированным как правило объектно ориентированный язык ооя содержит следующий набор элементов объявление классов полями данными членами класса методами функциями членами класса механизм расширения класса наследования порождение нового класса от существующего автоматическим включением всех особенностей реализации класса предка состав класса потомка большинство ооя поддерживают только единичное наследование полиморфные переменные параметры функций методов позволяющие присваивать одной той же переменной экземпляры различных классов полиморфное поведение экземпляров классов за счёт использования виртуальных методов некоторых ооя все методы классов являются виртуальными некоторые языки добавляют указанному минимальному набору те или иные дополнительные средства их числе конструкторы деструкторы финализаторы свойства аксессоры индексаторы средства управления видимостью компонентов классов интерфейсы или модификаторы доступа такие как public private protected feature др одни языки отвечают принципам ооп полной мере них все основные элементы являются объектами имеющими состояние связанные методы примеры подобных языков smalltalk eiffel существуют гибридные языки совмещающие объектную подсистему целостном виде подсистемами других парадигм как два более языка одном позволяющие совмещать одной программе объектные модели иными размывающие грань между объектно ориентированной другими парадигмами за счёт нестандартных возможностей балансирующих между ооп другими парадигмами таких как множественная диспетчеризация параметрические классы возможность манипулировать методами классов как объектами др примеры таких языков clos dylan ocaml python ruby objective однако наиболее распространены языки включающие средства эмуляции объектной модели поверх более традиционной императивной семантики алан кэй назвал такие языки склеиванием возможностей противовес чистоте стиля языков воплощающих некую парадигму непосредственно примеры таких языков симула visual basic delphi модула модула java php см также orm технология связывания оо программ базами данных доменный объект uml объектно ориентированное проектирование сравнение языков примечания литература перевод на русский язык design patterns ссылки обзоры обзор объектно основы объектно интуит ру бертран мейер бобровский история ооп pc week re от стр от стр критика ооп ричард гэбриэл объектная парадигма провалилась гай стил объектная парадигма не провалилась категория парадигмы