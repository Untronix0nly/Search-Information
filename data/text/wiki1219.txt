язык программи рования формальный язык предназначенный для записи компьютерных программ язык определяет набор лексических синтаксических семантических правил определяющих внешний вид программы действия которые выполнит исполнитель обычно эвм под её управлением со времени создания первых программируемых машин человечество придумало более восьми тысяч языков включая эзотерические визуальные игрушечные каждый год их число увеличивается некоторыми языками умеет пользоваться только небольшое число их собственных разработчиков другие становятся известны миллионам людей программисты могут владеть десятком более разных языков язык предназначен для написания компьютерных программ которые представляют собой набор правил позволяющих компьютеру выполнить тот или иной вычислительный процесс организовать управление различными объектами язык отличается от естественных языков тем что предназначен для управления эвм то время как естественные языки используются прежде всего для общения людей между собой большинство языков использует специальные конструкции для определения манипулирования структурами данных управления процессом вычислений как правило язык определяется не только через спецификации стандарта языка формально определяющие его синтаксис семантику но через воплощения реализации стандарта программные средства обеспечивающих трансляцию или интерпретацию программ на этом языке такие программные средства различаются по производителю марке варианту версии времени выпуска полноте воплощения стандарта дополнительным возможностям могут иметь определённые ошибки или особенности воплощения влияющие на практику использования языка или даже на его стандарт история ранние этапы развития можно сказать что первые языки возникали ещё до появления современных электронных вычислительных машин уже xix веке были изобретены устройства которые можно долей условности назвать примеру музыкальная шкатулка позднее механическое пианино посредством металлического цилиндра жаккардовый ткацкий станок посредством картонных карт для управления ими использовались наборы инструкций которые рамках современной классификации можно считать прототипами предметно ориентированных языков значимым можно считать язык на котором леди ада августа графиня лавлейс году написала программу для вычисления чисел бернулли для аналитической машины чарльза бэббиджа ставшей бы случае реализации первым компьютером мире хотя механическим паровым двигателем годах чёрч тьюринг марков разработали математические абстракции лямбда исчисление машину тьюринга нормальные алгоритмы соответственно для формализации алгоритмов это же время годы появились электрические цифровые компьютеры был разработан язык который можно считать первым высокоуровневым языком для эвм plankalkül созданный немецким инженером цузе период по годы программисты эвм начала годов особенности таких как univac ibm при создании программ пользовались непосредственно машинным кодом запись программы на котором состояла из единиц нулей который принято считать языком первого поколения при этом разные машины разных производителей использовали различные коды что требовало переписывать программу при переходе на другую эвм первым практически реализованным языком стал году так называемый краткий код котором операции переменные кодировались двухсимвольными сочетаниями он был разработан компании eckert mauchly computer corporation выпускавшей univac созданной одним из сотрудников тьюринга джоном мокли мокли поручил своим сотрудникам разработать транслятор математических формул однако для годов эта цель была слишком амбициозна краткий код был реализован помощью интерпретатора вскоре на смену такому методу пришло применение языков второго поколения также ограниченных спецификациями конкретных машин но более простых для использования человеком за счёт использования мнемоник символьных обозначений машинных команд возможности сопоставления имён адресам машинной памяти они традиционно известны под наименованием языков ассемблера автокодов однако при использовании ассемблера становился необходимым процесс перевода программы на язык машинных кодов перед её выполнением для чего были разработаны специальные программы также получившие название ассемблеров сохранялись проблемы переносимостью программы эвм одной архитектуры на другую необходимость для программиста при решении задачи мыслить терминами низкого уровня ячейка адрес команда позднее языки второго поколения были них появилась поддержка макрокоманд середины начали появляться языки третьего поколения такие как фортран лисп кобол языки этого типа более абстрактны их ещё называют языками высокого уровня универсальны не имеют жёсткой зависимости от конкретной аппаратной платформы используемых на ней машинных команд программа на языке высокого уровня может исполняться по крайней мере теории на практике обычно имеются ряд специфических версий или диалектов реализации языка на любой эвм на которой для этого языка имеется транслятор инструмент переводящий программу на язык машины после чего она может быть выполнена процессором обновлённые версии перечисленных языков до сих пор имеют хождение разработке программного обеспечения каждый из них оказал определённое влияние на последующее развитие языков тогда же конце годов появился алгол также послуживший основой для ряда дальнейших разработок этой сфере необходимо заметить что на формат применение ранних языков значительной степени влияли интерфейсные ограничения период годов были разработаны основные парадигмы языков используемые настоящее время хотя во многих аспектах этот процесс представлял собой лишь улучшение идей концепций заложенных ещё первых языках третьего поколения язык apl оказал влияние на функциональное стал первым языком поддерживавшим обработку массивов язык пл npl был разработан годах как объединение лучших черт фортрана кобола язык snobol разработанный течение годов ориентированный на обработку текстов ввёл число базовых операций языков сопоставление образцом язык симула появившийся примерно это же время впервые включал поддержку объектно середине группа специалистов представила язык smalltalk который был уже всецело объектно ориентированным период по годы велась разработка языка си популярного по сей день ставшего основой для множества последующих языков например столь популярных как java году был создан пролог наиболее известный хотя не первый далеко не единственный язык логического году языке ml была реализована расширенная система полиморфной типизации положившая начало типизированным языкам функционального каждый из этих языков породил по семейству потомков большинство современных языков конечном счёте основано на одном из них кроме того годах активно велись споры необходимости поддержки структурного тех или иных языках частности голландский специалист дейкстра выступал печати предложениями полном отказе от использования инструкций goto во всех высокоуровневых языках развивались также приёмы направленные на сокращение объёма программ повышение продуктивности работы программиста пользователя объединение развитие годы наступил период который можно условно назвать временем консолидации язык объединил себе черты объектно системного правительство сша язык ада производный от паскаля предназначенный для использования бортовых системах управления военными объектами японии других странах мира осуществлялись значительные инвестиции изучение перспектив так называемых языков пятого поколения которые включали бы себя конструкции логического сообщество функциональных языков приняло качестве стандарта ml лисп целом этот период скорее опорой на заложенный предыдущем десятилетии фундамент нежели разработкой новых парадигм важной тенденцией которая наблюдалась разработке языков для систем было сосредоточение на применении модулей объёмных единиц организации кода хотя некоторые языки такие как пл уже поддерживали соответствующую модульная система нашла своё отражение применение также языках модула оберон ада ml часто модульные системы объединялись конструкциями обобщённого важным направлением работ становятся визуальные графические языки которых процесс написания программы как текста заменяется на процесс рисования конструирования программы виде диаграммы на экране эвм визуальные языки обеспечивают наглядность лучшее восприятие логики программы человеком годах связи активным развитием интернета распространение получили языки позволяющие создавать сценарии для веб страниц главным образом perl развившийся из скриптового инструмента для unix систем java возрастала также популярность технологий виртуализации эти изменения однако также не представляли собой фундаментальных новаций являясь скорее уже существовавших парадигм языков последнем случае главным образом семейства си настоящее время развитие языков идёт направлении повышения безопасности надёжности создания новых форм модульной организации кода интеграции базами данных спецификация языков стандартизация для многих широко языков созданы международные стандарты специальные организации проводят регулярное обновление публикацию спецификаций формальных определений языка рамках таких комитетов продолжается разработка модернизация языков решаются вопросы расширении или поддержке уже существующих новых языковых конструкций алфавит современные языки рассчитаны на использование ascii то есть доступность всех графических символов ascii является необходимым достаточным условием для записи любых конструкций языка управляющие символы ascii используются ограниченно допускаются только возврат каретки cr перевод строки lf горизонтальная табуляция ht иногда также вертикальная табуляция vt переход следующей странице ff ранние языки возникшие эпоху битных символов использовали более ограниченный набор например алфавит фортрана включает символов включая пробел заметным исключением является язык apl котором используется очень много специальных символов использование символов за пределами ascii например символов koi или символов юникода зависит от реализации иногда они разрешаются только комментариях символьных строковых константах иногда идентификаторах ссср существовали языки где все ключевые слова писались русскими буквами но большой популярности подобные языки не завоевали исключение составляет встроенный язык предприятие расширение набора используемых символов сдерживается тем что многие проекты по разработке программного обеспечения являются международными очень сложно было бы работать кодом где имена одних переменных записаны русскими буквами других арабскими третьих китайскими иероглифами вместе тем для работы текстовыми данными языки нового поколения delphi java поддерживают unicode грамматика контекстно свободная грамматика контекстно зависимая грамматика регулярный язык регулярные выражения грамматика фразовой структурой ll lalr yacc antlr parsec ast семантика существует несколько подходов определению семантики языков основных три операционная аксиоматическая денотационная при описании семантики рамках операционного подхода обычно исполнение конструкций языка помощью некоторой воображаемой абстрактной эвм аксиоматическая семантика описывает последствия выполнения конструкций языка помощью языка логики задания пред пост условий денотационная семантика оперирует понятиями типичными для математики множества соответствия также суждения утверждения др классификация не существует общепринятой систематичной таксономии языков есть множество черт согласно которым можно производить классификацию языков причём одни из них однозначно проводят разделы между языками на основе технических свойств другие основываются на доминирующих признаках имеют исключения более условны третьи полностью субъективны нередко сопровождаются заблуждениями но на практике весьма распространены конкретный язык подавляющем большинстве случаев имеет более одного языка предка многие языки создаются как сочетание элементов различных языков одних случаях такое сочетание проходит математический анализ на предмет см например определение других язык формируется исходя из практических потребностей для решения актуальных проблем целью получения коммерческого успеха но при этом без соблюдения математической строгости включением язык идей как случае языки низкого высокого уровня обычно под уровнем языка понимается степень отличия семантики языка от машинного кода целевой архитектуры процессора другими словами наименьший масштаб преобразований которые должен претерпеть код программы перед тем как он сможет исполняться зачастую существенной потерей эффективности степень которой семантика языка учитывает особенности мышления человека нежели машины то есть уровень языка тем ниже чем он ближе машине тем выше чем он ближе человеку эта двойственность появилась годы при создании языков планкалкюль фортран при их разработке ставились прямые намерения обеспечить более краткую запись часто встречающихся конструкций например арифметических выражений чем требовали процессоры того времени этих языках вводился новый слой абстракции предполагались преобразования программ машинный язык поэтому их назвали языками высокого уровня то есть надстройкой надслоением над языком машины однако вскоре стало ясно что эти определения вовсе не обязательно идут бок бок так история знает случаи когда язык традиционно считающийся высокоуровневым реализовывался аппаратно см лисп машина или когда язык являющийся низкоуровневым на одной платформе компилировался как высокоуровневый на другой таким образом программы на cisc ассемблере vax использовались на risc машинах dec alpha см таким образом понятие уровня языка является не строго формальным скорее условным языкам низкого уровня относят первую очередь машинные языки или на общеупотребимом жаргоне машинные коды то есть языки реализованные непосредственно на аппаратном уровне их относят вскоре после них появились так называемые языки ассемблера простейшем случае они реализуют мнемонику над машинным языком для записи команд их параметров частности адресов памяти кроме того многие языки ассемблера включают весьма развитый макроязык языки первого второго поколения позволяют точно контролировать как требуемая будет исполняться на данном процессоре учётом особенностей его архитектуры одной стороны это обеспечивает высокое быстродействие компактность программ но другой для переноса программы на другую аппаратную платформу её нужно перекодировать часто из за различий архитектуры процессоров нуля большинство языков ассемблера являются бестиповыми но существуют нацеленные на обеспечение минимальной безопасности низкоуровневых программ годам сложность программ выросла настолько что превысила способность программистов управляться ними это привело огромным убыткам застою развитии информационных технологий ответом на эту проблему стало появление массы языков высокого уровня предлагающих самые разные способы управления сложностью подробнее см парадигма языки для мелком крупном масштабе программы на языках высокого уровня гораздо легче модифицируются совсем легко переносятся компьютера на компьютер на практике наибольшее распространение получили языки третьего поколения которые лишь претендуют на звание высокоуровневых но реально предоставляют лишь те высокоуровневые конструкции что находят однозначное соответствие инструкциям машине фон неймана языкам четвёртого поколения относят языки высшего порядка иногда выделяется категория языков пятого поколения но она не является общепринятой чаще используется термин язык сверх высокого уровня это языки реализация которых включает существенную алгоритмическую составляющую то есть когда интерпретация небольшого исходного кода требует весьма сложных вычислений чаще всего так называют логические языки про которые также говорят что это просто языки четвёртого поколения дополненные базой знаний кроме того языкам сверх высокого уровня относят визуальные языки языки основанные на подмножестве естественного языка например так называемой деловой прозы важной категорией являются предметно ориентированные языки отнесение языка этой категории является весьма условным зачастую спорным на практике этот термин могут применять представителям третьего четвёртого пятого поколений языков порой так даже классифицируют язык си который можно отнести поколению он изначально как высокоуровневый ассемблер его также часто называют языком среднего уровня он позволяет значительной степени контролировать способ реализации алгоритма учётом свойств типичных для весьма большого числа аппаратных архитектур однако есть платформы под которые реализации си даже нестандартном виде отсутствуют по причине принципиальной невозможности или их создания со временем появились другие языки среднего уровня например llvm первые три поколения языков формируют императивную парадигму последующие декларативную термин императив означает приказной порядок то есть посредством пошагового машины или детального указания уже придуманного программистом способа реализации технического задания термин декларатив означает описание то есть посредством предоставления формализации технического задания виде пригодном для предоставлением свободы выбора транслятору языка императивные языки нацелены на описание того как получить результат тогда как языки более высокого уровня нацелены на описание того что требуется результате поэтому первые называют как языками или языками на машину вторые что языками или языками на человека для множества задач полностью автоматическое порождение по настоящему эффективной реализации алгоритмически неразрешимо так что на практике даже на что языках нередко используются определённые алгоритмические ухищрения однако существуют методы получения эффективных реализаций из основанных на определении реализаций лоб такие как изобретённая ссср суперкомпиляция большинстве случаев языки высокого уровня порождают машинный код большего размера исполняются медленнее однако некоторые языки высокого уровня для алгоритмически структурно сложных программ могут давать заметное преимущество эффективности уступая низкоуровневым лишь на небольших простых программах подробнее см эффективность языков иначе говоря потенциальная эффективность языка меняется повышением его уровня нелинейно вообще неоднозначно однако скорость разработки трудоёмкость модификации устойчивость другие показатели качества сложных системах оказываются гораздо важнее предельно возможной скорости исполнения они обеспечивают различие между программой что работает той что нет так что экономически более целесообразна эволюция аппаратного обеспечения исполнение большего числа инструкций единицу времени методов оптимизирующей компиляции более того последние десятилетия эволюция аппаратного обеспечения движется направлении поддержки методов оптимизирующей компиляции для языков высокого уровня примеру автоматическая сборка мусора присутствующая большинстве высокоуровневых языков считается одним из важнейших улучшений благотворно повлиявших на скорость разработки поэтому наши дни языки низкого уровня используются только задачах системного распространено мнение что задачах где необходим точный контроль за ресурсами язык сам должен требовать как можно меньше преобразований иначе все усилия программиста окажутся напрасными есть примеры опровергающие это так язык bitc является представителем четвёртого поколения функциональной парадигмы но целиком полностью ориентирован именно на системное уверенно конкурирует по скорости си то есть это высокоуровневый язык предназначенный для низкоуровневого языки третьего поколения limbo разрабатывались для использования одновременно как системном целью повышения операционной системы так прикладном это обеспечивает единство платформы что сокращает потери при трансляции безопасные небезопасные языки современные компьютеры представляют сложные данные реального мира виде чисел памяти компьютера это вводит дисциплину риск человеческого фактора том числе вероятность ошибок доступа памяти поэтому многие языки сопровождаются средством контроля смысла операций над двоичными данными на основе сопровождающей их логической информации системой типов однако существуют бестиповые языки например forth системы типов языков делятся на динамические потомки lisp smalltalk apl статические последние свою очередь делятся на неполиморфные потомки алгола bcpl полиморфные потомки ml кроме того они делятся на явные неявные другими словами требующие декларации типов для объектов программе или статически выводящие их самостоятельно системы типов бывают сильные слабые сильная система типов назначает тип для всякого выражения раз навсегда когда бы конкретно это ни происходило динамике или статике слабая позволяет впоследствии переназначать типы сильная типизация порой ошибочно отождествляется со статической общем целом язык называется безопасным если программы на нём которые могут быть приняты компилятором как правильно построенные динамике никогда не выйдут за рамки допустимого поведения это не значит что такие программы не содержат ошибок вообще термин хорошее поведение программы означает что даже если программа содержит некий баг частности логическую ошибку то она тем не менее не способна нарушить целостность данных обрушиться хотя термины неформальны безопасность некоторых языков например математически доказуема безопасность других например ada была обеспечена ad hoc образом без обеспечения концептуальной целостности что может обернуться катастрофами если положиться на них ответственных задачах см концептуальная целостность языков неформальная терминология была популяризована робином милнером одним из авторов теории формальной верификации собственно языка степень контроля ошибок реакция языка на них могут различаться простейшие системы типов запрещают примеру вычитать строку из целого числа однако целыми числами могут представляться миллиметры дюймы но было бы логической ошибкой вычитать дюймы из миллиметров развитые системы типов позволяют наиболее развитые принуждают внедрять программу такую логическую информацию для эвм она является избыточной полностью удаляется при порождении машинного кода тем или иным образом частности не допускает над данными никаких операций кроме тех что разрешены явно формализованы однако программы на нём всё же могут завершаться порождением необработанного исключения например при попытке деления на ноль его потомок mlpolyr гарантирует также отсутствие необработанных исключений такие языки называются типобезопасными java менее строги контролируют лишь утечки памяти поэтому их контексте чаще используют более узкий термин безопасность типов отношении доступа памяти или чаще просто безопасность доступа памяти сильно динамически типизируемые языки отслеживают поведение программ динамике что влечёт снижение быстродействия реагируют на ошибки порождением исключения все эти языки ориентированы на практичность предоставляя оптимальный компромисс между пресечением серьёзных сбоев высокой скоростью разработки программ но существуют языки предназначенные для написания программ которые верны по построению то есть обеспечивающие гарантию того что исполнимая программа по структуре поведению будет тождественна её спецификации см зависимый тип как следствие программы на таких языках часто называют исполнимыми спецификациями см соответствие карри говарда трудоёмкость разработки на таких языках возрастает на порядки кроме того они требуют очень высокой квалификации разработчика поэтому они используются только формальной верификации примерами таких языков служат agda coq языки си его потомок являются небезопасными программах на них обширно встречаются ситуации ослабления типизации приведение типов прямого её нарушения каламбур типизации так что ошибки доступа памяти являются них статистической нормой но крах программы наступает далеко не сразу что затрудняет поиск места ошибки коде самые мощные системы статического анализа для них такие как pvs studio способны обнаруживать не более ошибок но их использование обходится очень дорого денежном смысле достоверно же гарантировать безотказность программ на этих языках невозможно не прибегая формальной верификации что не только ещё дороже но требует специальных знаний си есть безопасные потомки такие как cyclone или rust язык forth не претендует на звание безопасного но тем не менее на практике существование программ способных повредить данные почти исключено так как содержащая потенциально опасную ошибку программа аварийно завершается на первом же тестовом запуске принуждая коррекции исходного кода сообществе erlang принят подход let it crash также нацеленный на раннее выявление ошибок компилируемые встраиваемые языки можно выделить три принципиально разных способа реализации языков компиляция интерпретация встраивание распространено заблуждение согласно которому способ реализации является присущим конкретному языку свойством это деление до определённой степени условно ряде случаев язык имеет формальную семантику ориентированную на интерпретацию но все или почти все его действительные реализации являются компиляторами порой весьма эффективно оптимизирующими примерами могут служить языки семейства ml такие как standard ml haskell есть языки размывающие границы между интерпретацией компиляцией например forth компиляция означает что исходный код программы сперва преобразуется целевой машинный код специальной программой называемой компилятором результате получается исполнимый модуль который уже может быть запущен на исполнение как отдельная программа интерпретация же означает что исходный код выполняется непосредственно команда за командой иногда минимальной подготовкой буквально после разбора исходного кода ast так что программа просто не может быть запущена без наличия интерпретатора встраивание языка можно философски рассматривать как реализацию без трансляции том смысле что такой язык является синтаксическим семантическим подмножеством некоего другого языка без которого он не существует говоря же более точно встраиваемые языки добавляют сказанному ещё четыре способа реализации естественный для языка способ реализации определяется временем связывания программных элементов их частности языках со статической типизацией переменные другие объекты программы связываются типом данных на этапе компиляции случае типизации динамической на этапе выполнения как правило произвольной точке программы некоторые свойства элементов языка такие как значение арифметических операторов или управляющих ключевых слов могут быть связаны уже на этапе определения языка других языках возможно их переназначение см раннее связывание обычно означает бо льшую эффективность программы то время как позднее большую гибкость ценой которого является меньшая скорость или усложнение этапа однако даже из казалось бы очевидных случаев есть исключения например интенсиональный полиморфизм откладывает обработку статической типизации до этапа выполнения но не замедляя повышая общее быстродействие по крайней мере теории для любого традиционно компилируемого языка такого как паскаль можно написать интерпретатор но многие языки предоставляют некоторые дополнительные возможности такие как динамическая генерация кода см так что их компиляция должна быть динамической см динамическая компиляция таким образом составной термин язык способ его реализации ряде случаев оказывается уместен кроме того большинство современных чистых интерпретаторов не исполняют конструкции языка непосредственно компилируют их некоторое высокоуровневое промежуточное представление например разыменованием переменных раскрытием макрокоманд большинство традиционно или компилируемых языков могут реализовываться как встраиваемые хотя метаязыков которые были бы способны охватить другие языки как своё подмножество не так много наиболее ярким представителем является lisp как правило программы выполняются быстрее не требуют для выполнения дополнительных программ так как уже переведены на машинный язык вместе тем при каждом изменении текста программы требуется её перекомпиляция что замедляет процесс разработки кроме того программа может выполняться только на том же типе компьютеров как правило под той же операционной системой на которую был рассчитан компилятор чтобы создать исполняемый файл для машины другого типа требуется новая компиляция языки позволяют запускать программы сразу же после изменения причём на разных типах машин операционных систем без дополнительных усилий гомоиконные вовсе динамически перемещать программу между разными машинами без прерывания её работы наиболее общий случай сериализации позволяя разрабатывать см тж системы высокой доступности портируемость программы определяется только наличием реализаций интерпретаторов под те или иные аппаратные платформы ценой всего этого становятся заметные потери быстродействия кроме того если программа содержит фатальную ошибку то об этом не будет известно пока интерпретатор не дойдёт до её места коде отличие от статически типобезопасных языков некоторые языки например java находятся между компилируемыми именно программа компилируется не машинный язык машинно независимый код низкого уровня байт код далее байт код выполняется виртуальной машиной для выполнения байт кода обычно используется интерпретация хотя отдельные его части для ускорения работы программы могут быть транслированы машинный код непосредственно во время выполнения программы по технологии компиляции на лету just in time compilation jit для java байт код исполняется виртуальной машиной java java virtual machine jvm для common language runtime подобный подход некотором смысле позволяет использовать плюсы как интерпретаторов так компиляторов языки первого высшего порядка начальные сведения математическая логика по порядку см логика первого порядка логика высшего порядка эта терминология естественным образом наследуется информатикой образуя семантики соответственно первого высшего порядка языки первого порядка например потомки алгола такие как basic или классический pascal вирта позволяют определять только зависимости первого порядка между величинами например значение sqare зависит от значения такие зависимости называются функциями языки высшего порядка позволяют определять зависимости между зависимостями например значение map зависит от значений где значение само выражает абстрактную зависимость другими словами параметр варьируется над множеством функций определённой сигнатуры такие зависимости называются функциями высшего порядка при этом большинстве случаев говорят что такой язык рассматривает зависимости функции как объекты первого класса иначе говоря допускает функции первого класса некоторые языки например си не поддерживают первоклассные функции но предоставляют ограниченные возможности строить функции высшего порядка эти термины ввёл языкам высшего порядка относятся почти все функциональные языки исключения очень редки примером функционального языка первого порядка долгое время являлся но году него была добавлена поддержка первоклассных функций развитием систем типов различение порядков на типы см конструктор типов выразительность языки первого порядка позволяют воплощать виде кода алгоритмы но не архитектуру программ по мнению это ограничение унаследовано языком алгол от него другими языками из классической математики где используются только константные операции функции однозначно распознаваемые вне контекста отсутствует систематичная нотация для произвольной работы функциями качестве такой нотации годах было построено лямбда исчисление которое позже легло основу языков высшего порядка схемы взаимодействия компонентов процедур функций объектов процессов др для программ на языках первого порядка могут существовать лишь на условном уровне вне самих программ со временем были обнаружены многократно повторяющиеся однотипные схемы такого рода результате чего вокруг них выстроилась самостоятельная методология шаблоны проектирования языки высшего порядка позволяют воплощать такие схемы виде исполнимого кода пригодного для многократного использования функций предназначенных для преобразования композиции других функций см например конверторы сканеры sml результате решения которые на языках первого порядка могут быть представлены фрагментами программ порой довольно сложными громоздкими на языках высшего порядка могут сокращаться до одной команды или вообще использования элемента семантики самого языка не имеющего синтаксического выражения например шаблон команда часто применяемый языках первого порядка эквивалентен непосредственно самому понятию функции первого класса то же на более высокие слои языков типизацию см полиморфизм высших рода типизацию типизации см полиморфизм родо сказанное преимущественно относится языкам семантика которых основана на лямбда исчислении потомки lisp ml однако некоторые языки иной природы также предоставляют возможность примерами служат стековые языки forth определённая разновидность объектно ориентированных языков smalltalk clos см изучение введя терминологию сущностей первого второго класса тут же акцентировал внимание на том что из личного опыта обсуждений со множеством людей он убедился что невероятно тяжело перестать думать функциях как об объектах второго класса то есть порядок языка имеет ярко выраженное психологическое влияние см гипотеза сепира уорфа владение языками более высокого уровня поможет программисту думать терминах более высокоуровневых абстракций низкоуровневые же языки могут навязывать обратное связи чем широко известно следующее высказывание практически невозможно обучить хорошему студентов имевших опыт работы бейсиком как потенциальные программисты они ментально исковерканы без надежды на восстановление это значит что само по себе использование языка высшего порядка не означает автоматически изменение архитектуры повышение коэффициента повторного использования см серебряной пули нет определяющим фактором является умение конкретного разработчика применять соответствующие идиомы понимание возможностей ограничений высокоуровневых конструкций базовых принципов их реализации не только дают программисту возможность наиболее эффективно использовать изученный им язык но позволят создавать использовать аналогичные механизмы случае разработки на языке где они не реализованы разработчику владеющему бо льшим спектром языков будет проще выбрать среди них инструмент наиболее подходящий для решения стоящей перед ним задачи изучить случае необходимости новый язык или реализовать предметно ориентированный язык которым примеру можно отнести интерфейс командной строки достаточно сложной программы парадигма отнесение языков парадигмам может производиться по нескольким признакам из которых одни соответствуют конкретным техническим характеристикам языков другие весьма условны технически языки делятся например на допускающие побочные эффекты ссылочно прозрачные во втором случае говорят что язык принадлежит чисто функциональной парадигме качестве парадигмы также иногда рассматриваются определённые свойства системы типов стратегии вычисления языка например для параметрически полиморфных систем типов нередко говорят реализации парадигмы обобщённого другим примером может служить свойство гомоиконности открывающее целый спектр разновидностей существует масса языков наследованных от математики многие из которых формируют уникальные парадигмы яркими представителями являются lisp впервые воплотивший лямбда исчисление положивший таким образом начало функциональной парадигме smalltalk впервые воплотивший объектно ориентированную парадигму появившаяся за много лет до него симула поддерживала понятие класса но воплощала структурную парадигму стековый язык forth воплощающий конкатенативную парадигму более условно языки делятся на поколения первые два поколения являются низкоуровневыми то есть на специфику конкретного аппаратного обеспечения принципе не соотносятся какой либо парадигмой хотя конкретный разработчик на них разумеется может идеологически следовать определённым тенденциям вместе третьим поколением они формируют императивную парадигму последующие поколения декларативную более подробно см раздел языки низкого высокого уровня многие декларативные языки включают себя определённые императивные возможности иногда наоборот ростом размера сложности программ уже при использовании языков второго поколения начала формироваться парадигма процедурного требующая производить декомпозицию крупных процедур цепочку иерархически связанных более мелких примерно то же время появились первые языки сформировалось сперва структурное как прямое развитие процедурного затем модульное со временем появилось огромное количество разнообразных путей решения проблемы растущих программных систем сохранением исходно императивного подхода основе некоторых случаях достигнуто существенное влияние на показатели скорости разработки качества но общем целом как выше отмечено языки третьего поколения абстрагируются от машинной логики лишь до определённого уровня незначительно подвержены настоящему времени третье поколение языков представлено наиболее обширным спектром разнообразных парадигм относят функциональные языки из которых выделяются чисто функциональные соответствующие выше упомянутой технической категории ссылочно прозрачных остальные называются не чисто функциональными относят языки логического котором помимо традиционного выделяется несколько особых форм например ограничениями фактически языки пятого поколения это языки четвёртого поколения дополненные базой знаний поэтому эта категория как уже выше отмечено не является общепринятой многие парадигмы являются условно методиками организации структуры программы применимы большому множеству языков наиболее широкий охват имеют структурная модульная они применяются императивных декларативных языках другие парадигмы тесно связаны техническими свойствами например подмножество языка шаблоны формально может рассматриваться как полный по тьюрингу чисто функциональный язык но не обладает присущими функциональным языкам свойствами ссылочная прозрачность гарантия оптимизации хвостовых вызовов др как следствие применяемые компиляции функциональных языков алгоритмы не могут быть применены потому ведущие исследователи функциональной парадигмы отзываются весьма скептически подробнее см критика шаблонов языки для мелком крупном масштабе программы могут решать задачи одна программа строит график для заданной функции другая управляет крупного предприятия различные языки рассчитаны на разный исходный масштаб задачи что ещё более важно по разному справляются ростом сложности программных систем ключевым качеством языка от которого зависит как меняется трудоёмкость разработки по мере наращивания системы является абстракция то есть возможность отделять смысл поведение компонента системы от способа его реализации рост сложности любой программной системы принципиально ограничен тем пределом до которого ещё можно сохранять контроль над ней если объём информации требуемый для осмысления компонента этой системы превышает вместимость мозга одного человека то этот компонент не будет до конца понят станет чрезвычайно тяжело дорабатывать его или исправлять ошибки от каждой корректировки можно ждать введения новых ошибок из за этого неполного знания такие показатели качества исходного кода как тестируемость очевидным образом определяются коэффициентом повторного использования это может означать как применение разных функций одному тому же компоненту так возможность применять одну ту же функцию разным компонентам параметрически полиморфные особенно выводящие динамические системы типов существенно повышают коэффициент повторного использования например функция вычисляющая длину массива будет применима бесконечному множеству типов массивов если же язык требует сигнатуре функции указывать конкретный способ реализации входных данных то этот коэффициент резко страдает например pascal критиковался за необходимость всегда указывать конкретный размер массива за необходимость различать при обращении компонентам языки высшего порядка позволяют выделять схемы взаимодействия функций многократно вызываемый блок кода функцию высшего порядка наибольших значений повторное использование достигает при переходе языку более высокого уровня при необходимости специально для данной задачи этом случае повторно используется язык не одна функция сама разработка языка может вестись интенсивным повторным использованием компонентов компилятора развитием языков появились особые присущие исключительно не требовавшиеся ранее математике категории компонентов зависимостей монады классы типов полиморфные ветвления аспекты др их использование позволяет выражать бо льшую том же объёме кода тем самым переводя более мелкий масштаб другие фундаментальные проблемы связанные со сложностью крупных систем лежат вне самих программ это взаимодействие разрабатывающих её программистов между собой помимо обеспечения абстракции не последнюю роль этом играет концептуальная целостность выбранного языка кроме свойств семантики языка повторное использование может обеспечиваться посредством модульной структуры программной системы или комплекса более того сколь бы гибким ни был язык работа огромными объёмами кодов особенно множеством людей требует их декомпозиции на модули тем или иным образом модульная структура подразумевает не просто разбиение монолитного исходного кода программы на множество текстовых файлов обеспечение абстракции более крупном масштабе то есть определение интерфейса для всякого логически завершённого фрагмента сокрытие деталей его реализации зависимости от применённых языке правил определения области видимости язык может допускать или не допускать автоматическое определение зависимостей если согласно правилам возможен конфликт имён то автоопределение зависимостей невозможно тогда заголовке модуля требуется явно перечислять имена модулей компоненты которых нём используются некоторые языки например basic или классический pascal вирта ориентированы исключительно на разработку мелких структурно простых программ они не обеспечивают ни развитой системы модулей ни гибкости конкретных фрагментов язык си создавался как высокоуровневый ассемблер что само по себе не предполагает разработку систем выше некоторого порога сложности поэтому поддержка него заложена также не была некоторые языки высокого сверх высокого уровня erlang smalltalk prolog предоставляют качестве базовых примитивных элементов концепции которые других языках представляются конструктивно алгоритмически сложными процессы классы базы знаний аналогично разнообразным математическим исчислениям см также концептуальная целостность языков поэтому такие языки нередко рассматриваются роли предметно специфичных на них выглядят простыми некоторые но далеко не все задачи которые на других языках выглядят сложными однако расширение других аспектах на этих языках может оборачиваться затруднениями его родственники расслаиваются на два языка из которых один язык ядро ориентирован на разработку простых программ другой язык модулей соответственно на нелинейную компоновку их сложные программные системы со временем были построены варианты слияния их воедино ml многие другие языки также включают системы модулей но большинство из них являются языками модулей первого порядка язык модулей ml является единственным своём роде языком модулей высшего порядка языки lisp forth позволяют наращивать системы произвольно безгранично том числе позволяя создавать встраиваемые предметно специфичные языки внутри себя как своё синтаксическое семантическое подмножество поэтому их нередко называют метаязыками наиболее популярным на сегодняшний день подходом решению проблемы является объектно ориентированное хотя успешность его применения на протяжении десятилетий существования неоднократно подвергалась скепсису до сих пор отсутствуют достоверные данные том что он приносит выигрыш по сравнению другими подходами по тем или иным показателям качества ему сопутствуют порой конкурируют различные технологии зависимостей между компонентами метаклассы контракты прототипы примеси типажи др более мощным подходом исторически считалось использование различных форм то есть автоматизации самого процесса разработки на различных уровнях принципиально различается внешнее по отношению языку доступное самом языке при использовании языков первого порядка сложность растущих программных систем быстро переходит порог способностей человека по восприятию переработке информации поэтому применяются внешние средства визуального проектирования позволяющие обозревать сложные схемы упрощённом виде уменьшенном масштабе затем автоматически порождать каркас кода см case сообществах разработчиков использующих языки высшего порядка доминирует прямо противоположный подход пресекать саму возможность выхода сложности из под контроля за счёт разделения информационных моделей на независимые составляющие разработки средств автоматического преобразования одних моделей другие см языково ориентированное концептуальная целостность языков фредерик брукс хоар делают акцент на необходимости обеспечения концептуальной целостности информационных систем вообще языков частности чтобы каждой части системы использовались сходные синтаксические семантические формы не требовалось осваивать помимо собственно состава системы также правила её идиоматического использования хоар предсказывал что сложность ады станет причиной катастроф алан кэй отделяет языки являющиеся стилем во плоти от прочих языков являющихся склеиванием возможностей грег нельсон выделяют особую категорию языки наследованные от математики эти акценты призывают использованию языков воплощающих некое математическое исчисление аккуратно адаптированное для того чтобы быть более практичным языком для разработки реальных программ такие языки отличаются хотя это означает необходимость вручную реализовывать многие идиомы доступные более популярных языках качестве примитивов языка таких языков целом может быть существенно выше лишь некоторые языки попадают под эту категорию большинство же языков проектируются приоритетно исходя из возможности эффективной трансляции машину тьюринга многие языки опираются на общие теории но при разработке они почти никогда не проверяются на безопасность совместного использования конкретных языковых элементов являющихся частными приложениями этих теорий что неизбежно приводит несовместимости между реализациями языка эти проблемы либо игнорируются либо начинают преподноситься как естественное явление но их причиной является то что язык не был подвергнут математическому анализу примеры математически обоснованных языков воплощаемых ими математических моделей agda idris мартин лёфа apl его потомки оригинальная семантика не имеющая названия воплощающая нотацию айверсона для исчисления массивов часто встречается термин coq erlang исчисление процессов первоначально форме модели акторов позже также построено обоснование на исчислении forth конкатенативный язык haskell теория категорий включая декартово замкнутую категорию воплощающую лямбда исчисление категорию монад для моделирования побочных эффектов расширение системы типов хиндли милнера систему родо др joy композиция функций гомоморфизм иначе говоря чистый конкатенативный язык как следствие чистый функциональный lisp лямбда исчисление чёрча том числе язык выражений воплощающий scheme облагороженный диалект лиспа сильнее типизированный большей степени гомоиконный соблюдающий дополненный нотацией продолжений ml типизированное лямбда исчисление то есть лямбда исчисление дополненное системой типов хиндли милнера prolog исчисление предикатов mercury исчисление предикатов дополненное системой типов хиндли милнера smalltalk теория множеств соблюдением sql исчисление кортежей вариант реляционного исчисления свою очередь основанного на исчислении предикатов первого порядка sgml его потомки html xml нотация деревьев важный случай графов unlambda комбинаторная логика регулярные выражения рефал оригинальная семантика турчина носящая название рефал машины или рефал автомата созданная на основе нормального алгоритма маркова воплощающая композицию теории автоматов сопоставления образцом переписывания термов наличие математического обоснования для языка может гарантировать или как минимум обещать очень высокой вероятностью некоторые или все из следующих положительных свойств существенное повышение стабильности программ одних случаях за счёт построения доказательства надёжности для самого языка см существенного упрощения формальной верификации программ даже получения языка который сам является системой автоматического доказательства coq agda других случаях за счёт раннего обнаружения ошибок на первых же пробных запусках программ forth регулярные выражения обеспечение потенциально более высокой эффективности программ даже если семантика языка далека от архитектуры целевой платформы компиляции нему могут быть применимы формальные методики глобального анализа программ хотя трудоёмкость написания даже тривиального транслятора может оказаться выше например для языков scheme standard ml существуют развитые полнопрограммно оптимизирующие компиляторы результат работы которых может уверенно конкурировать по скорости языком низкого уровня си даже опережать последний хотя ресурсоёмкость работы самих компиляторов оказывается значительно выше одна из самых быстрых субд kdb написана на языке язык scala унаследовавший математику от ml обеспечивает на платформе jvm более высокую скорость чем родной для неё язык java другой стороны forth имеет репутацию одного из самых ресурсам языков менее требователен чем си используется для разработки приложений реального времени под самые маломощные эвм кроме того транслятор форта является одним из наименее трудоёмких реализации на ассемблере заранее известный неограниченный или наоборот чётко очерченный предел роста сложности программных компонентов систем комплексов которые можно выразить средствами этого языка сохранением показателей качества языки не имеющие математического обоснования именно такие наиболее часто применяются мейнстриме java delphi др на практике ограничивают реализуемую или снижают качество по мере усложнения системы так как им присущи кривые роста сложности как касательно работы одного отдельно взятого человека так касательно сложности управления проектом целом прогнозируемая сложность системы приводит либо поэтапной декомпозиции проекта на множество более мелких задач каждая из которых решается соответствующим языком либо языково для случая когда адресуемой языком задачей является как раз описание семантик или символьные вычисления lisp ml haskell рефал регулярные выражения языки неограниченным пределом роста сложности программ нередко относят метаязыкам что толковании термина не верно но практике сводимо так как всякий мини язык выбранный для решения некоторой подзадачи составе общей задачи может быть представлен виде синтаксического семантического подмножества данного языка не требуя трансляции удобство для человека при решении задач на которые этот язык ориентирован по своей природе см проблемно ориентированный язык что некоторой степени также способно косвенно повлиять на повышение стабильности результирующих программ за счёт повышения вероятности обнаружения ошибок исходном коде снижения дублирования кода особые категории языков учебные предметно специфичные эзотерические визуальные формальные преобразования оптимизация турчин отмечает что достоинства всякого языка определяются не только тем сколь он удобен для использования человеком но тем какой степени тексты на этом языке поддаются формальным преобразованиям например ссылочная прозрачность означает что параметры функций не обязаны вычисляться перед вызовом вместо этого фактически переданное выражение может быть целиком подставлено на место переменной функции поведение функции от этого не изменится это открывает возможности почти произвольных могут устраняться ненужные промежуточные представления данных редуцироваться сложные цепочки вычислений подбираться оптимальное количество параллельных процессов вводиться мемоизация пр другой стороны это означает полное отсутствие побочных эффектов это делает реализацию некоторых алгоритмов заведомо менее эффективной чем при использовании изменяемого состояния для небольших простых программ языки высокого уровня порождают машинный код большего размера исполняются медленнее однако для алгоритмически структурно сложных программ преимущество может быть на стороне некоторых языков высокого уровня так как человек физически не способен выражать сложные концепции учётом их эффективного исполнения на языке машины примеру существует бенчмарк на котором mlton уверенно опережают gcc есть масса частных причин по которым автоматическая оптимизация ходе трансляции языков высокого уровня даёт принципе более высокую скорость исполнения чем сознательный контроль способа реализации на языках низкого уровня например имеются достоверные данные том что автоматическое управление памятью более эффективно чем ручное уже только при использовании динамического метода см сборка мусора существует потенциально более эффективный статический метод см далее для каждого микроконтекста необходимо распределить регистры учётом минимизации обращения памяти это требует решения задачи раскраски графа такого рода особенностей машинной логики очень много так что общая информационная сложность возрастает экспоненциально при каждом шаге на уровень вниз компиляция языка высокого уровня может включать десятки таких шагов существует множество стратегий автоматической оптимизации некоторые универсальны другие могут быть применимы лишь языкам определённой природы некоторые зависят от способа использования языка примером может служить оптимизация хвостовых вызовов её частный случай оптимизация хвостовой рекурсии хотя компиляторы многих языков осуществляют оптимизацию хвостовой рекурсии при определённых условиях лишь некоторые языки способны семантически гарантировать оптимизацию хвостовых вызовов общем случае стандарт языка scheme требует чтобы всякая реализация гарантировала её для многих функциональных языков она принципе применима но лишь оптимизирующие компиляторы её выполняют языках вроде си или она может производиться лишь определённых случаях лишь при использовании глобального анализа потока управления языки высшего порядка большинстве случаев вынуждены исполняться медленнее чем языки первого порядка причины лежат как самой декомпозиции линейного кода на цепочку вложенных вызовов так вытекающих особенностях низкоуровневого представления функций см замыкание данных обёрнутое теговое однако существуют техники агрессивной оптимизации программ позволяющие редуцировать языки высшего порядка до языков первого порядка см mlton популярность языков трудно определить какой язык наиболее популярен так как значение слова популярность зависит от контекста английском языке используется термин usage имеющий ещё более размытое значение один язык может отнимать наибольшее количество человеко часов на другом написано наибольшее число строк кода третий занимает наибольшее процессорное время четвёртый наиболее часто служит базой академических кругах некоторые языки очень популярны для конкретных задач например кобол до сих пор доминирует корпоративных дата центрах фортран научных инженерных приложениях вариации языка си системном различные потомки ml формальной верификации другие языки регулярно используются для создания самых разнообразных приложений существуют различные метрики для измерения популярности языков каждая из которых разработана пристрастием определённому смыслу понятия популярности подсчёт числа вакансий упоминающих язык количество проданных книг учебников или справочников оценка количества строк кода написанных на языке что не принимает расчёт редко публикуемые случаи использования языков подсчёт упоминаний языка запросах поисковиков следует заметить что высокие оценки по этим показателям не только никак не свидетельствуют высоком техническом уровне языка или оптимизации расходов при его использовании но напротив порой могут говорить об обратном например язык кобол входит число лидеров по количеству написанных на нём строк кода но причиной этому является крайне низкий показатель кода что делает этот код не повторно используемым как следствие поддержка программ на коболе кратковременной перспективе обходится значительно дороже чем программ на большинстве современных языков но переписывание их нуля потребовало бы значительных единовременных вложений может сравниваться только долговременными расходами техническое несовершенство кобола обусловлено тем что его разрабатывали без привлечения экспертов области информатики см также компьютерный язык hello world стандарт оформления кода теория языка примечания литература повторно опубликовано перевод на русский язык ссылки the language list более языков кратким описанием computer languages history история языков по май содержит регулярно обновляемую диаграмму examples примеры на языках programming language popularity регулярно обновляемое исследование популярности языков языков которые стоит изучать programming community index регулярно обновляемый рейтинг популярности языков computer language shootout benchmarks сравнение языков по эффективности programming languages that are loved сравнение языков по любви ненависти ним категория языки