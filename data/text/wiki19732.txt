сборка мусора одна из форм автоматического управления памятью специальный процесс называемый сборщиком мусора периодически освобождает память удаляя объекты которые уже не будут востребованы приложениями если бы память компьютера была бесконечной можно было бы просто оставлять ненужные объекты памяти сборка мусора эмуляция такого бесконечного компьютера на конечной памяти многие ограничения сборщиков мусора нет гарантии что финализатор выполнится управляет только памятью но не другими ресурсами вытекают из этой метафоры история сборка мусора была впервые применена джоном маккарти году среде на разработанном им функциональном языке лисп впоследствии она применялась других системах языках преимущественно функциональных логических необходимость сборки мусора языках этих типов обусловлена тем что структура таких языков делает крайне неудобным отслеживание времени жизни объектов памяти ручное управление ею широко используемые этих языках списки основанные на них сложные структуры данных во время работы программ постоянно создаются надстраиваются расширяются копируются правильно определить момент удаления того или иного объекта затруднительно промышленных процедурных объектных языках сборка мусора долго не использовалась предпочтение отдавалось ручному управлению памятью как более эффективному предсказуемому но со второй половины годов технология сборки мусора стала использоваться директивных императивных объектных языках со второй половины годов всё большее число создаваемых языков сред ориентированных на прикладное включают механизм сборки мусора либо как единственный либо как один из доступных механизмов управления динамической памятью настоящее время она используется oberon java python ruby perl других языках проблемы ручного управления памятью традиционным для директивных языков способом управления памятью является ручной его сущность следующем для создания объекта динамической памяти программист явно вызывает команду выделения памяти эта команда возвращает указатель на выделенную область памяти который сохраняется используется для доступа ней до тех пор пока созданный объект нужен для работы программы программа обращается нему через ранее сохранённый указатель когда надобность объекте проходит программист явно вызывает команду освобождения памяти передавая ей указатель на удаляемый объект любом языке допускающем создание объектов динамической памяти потенциально возможны две проблемы висячие ссылки утечки памяти висячая ссылка висячая ссылка это оставшаяся использовании ссылка на объект который уже удалён после удаления объекта все сохранившиеся программе ссылки на него становятся висячими память занимаемая ранее объектом может быть передана операционной системе стать недоступной или быть использована для размещения нового объекта той же программе первом случае попытка обратиться по повисшей ссылке приведёт срабатыванию механизма защиты памяти аварийной остановке программы во втором непредсказуемым последствиям появление висячих ссылок обычно становится следствием неправильной оценки времени жизни объекта программист вызывает команду удаления объекта до того как его использование прекратится утечка памяти создав объект динамической памяти программист может не удалить его после завершения использования если ссылающейся на объект переменной будет присвоено новое значение на объект нет других ссылок он становится программно недоступным но продолжает занимать память поскольку команда его удаления не вызывалась такая ситуация называется утечкой памяти если объекты ссылки на которые теряются создаются программе постоянно то утечка памяти проявляется постепенном увеличении объёма используемой памяти если программа работает долго объём используемой ею памяти постоянно растёт через какое то время ощутимо замедляется работа системы из за необходимости при любом выделении памяти использовать свопинг либо программа исчерпывает доступный объём адресного пространства завершается ошибкой механизм сборки мусора основные принципы сборка мусора технология позволяющая одной стороны упростить избавив программиста от необходимости вручную удалять объекты созданные динамической памяти другой устранить ошибки вызванные неправильным ручным управлением памятью системе со сборкой мусора обязанность освобождения памяти от объектов которые больше не используются возлагается на среду исполнения программы программист лишь создаёт динамические объекты пользуется ими он может не заботиться об удалении объектов поскольку это делает за него среда для осуществления сборки мусора состав среды исполнения включается специальный программный модуль называемый сборщиком мусора этот модуль периодически запускается определяет какие из созданных динамической памяти объектов более не используются освобождает занимаемую ими память периодичность запуска сборщика мусора определяется особенностями системы сборщик может работать фоновом режиме запускаясь при неактивности программы например когда программа простаивает ожидая ввода данных пользователем сборщик мусора запускается безусловно прерывая на время своей работы выполнение программы когда очередную операцию выделения памяти оказывается невозможно выполнить из за того что вся доступная память исчерпана после освобождения памяти прерванная операция выделения памяти возобновляется программа продолжает исполняться дальше если же оказывается что освободить память невозможно среда исполнения останавливает программу сообщением об ошибке недостаточно памяти достижимость объекта хотя общем случае невозможно точно определить момент когда объект был использован последний раз больше не нужен сборщики мусора используют консервативные оценки позволяющие определить что будущем объект гарантированно не будет использоваться обычно критерием того что объект ещё используется является наличие ссылок на него если системе нет больше ссылок на данный объект то он очевидно больше не может быть использован программой следовательно может быть удалён этот критерий используется большинством современных сборщиков мусора называется ещё достижимостью объекта неформально можно задать следующее рекурсивное определение достижимого объекта определённое множество объектов считается достижимым изначально корневые объекты обычно их число включают все глобальные переменные объекты на которые есть ссылки стеке вызовов любой объект на который есть ссылка из достижимого объекта тоже считается достижимым за исключением ссылок указанных программистом как слабая такое определение не является теоретически наилучшим так как число достижимых согласно ему попадают те объекты которые уже никогда не будут использованы но на которые пока ещё существуют ссылки оптимальным было бы считать недостижимым объект которому процессе дальнейшей работы программы не будет ни одного обращения однако выявление таких объектов невозможно поскольку сводится алгоритмически неразрешимой задаче об остановке для этого достаточно предположить что некоторый объект будет использован том только том случае если успешно завершится программа алгоритм выставления флагов простой алгоритм определения достижимых объектов алгоритм пометок mark and sweep заключается следующем для каждого объекта хранится бит указывающий достижим ли этот объект из программы или нет изначально все объекты кроме корневых помечаются как недостижимые рекурсивно просматриваются помечаются как достижимые объекты ещё не помеченные до которых можно добраться из корневых объектов по ссылкам те объекты которых бит достижимости не был установлен считаются недостижимыми следует обратить внимание что согласно данному алгоритму если два или более объектов ссылаются друг на друга но ни на один из этих объектов нет других ссылок то имеет место циклическая ссылка вся группа считается недостижимой эта особенность алгоритма позволяет гарантированно удалять группы объектов использование которых прекратилось но которых имеются ссылки друг на друга такие группы часто называются islands of isolation острова изоляции алгоритм подсчёта ссылок другой вариант алгоритма определения достижимости обычный подсчёт ссылок его использование замедляет операции присваивания ссылок но зато определение достижимых объектов тривиально это все объекты значение счётчика ссылок которых превышает нуль без дополнительных уточнений этот алгоритм отличие от предыдущего не удаляет циклически замкнутые цепочки вышедших из употребления объектов сохранивших ссылки друг на друга стратегии сборки мусора как только определено множество недостижимых объектов сборщик мусора может освободить память занимаемую ими оставить остальное как есть также можно после освобождения памяти переместить все или часть оставшихся объектов другие области памяти обновив вместе этим все ссылки на них эти два варианта реализации называются соответственно неперемещающим перемещающим обе стратегии имеют как достоинства так недостатки скорость выделения освобождения памяти неперемещающий сборщик мусора быстрее освобождает память поскольку эта операция сводится пометке соответствующих блоков памяти как свободных но тратит больше времени на её выделение поскольку память фрагментируется при выделении необходимо найти памяти нужное количество блоков подходящего размера перемещающий сборщик требует сравнительно больше времени при сборе мусора тратится дополнительное время на дефрагментацию памяти изменение всех ссылок на перемещаемые объекты зато перемещение позволяет использовать чрезвычайно простой быстрый алгоритм выделения памяти при дефрагментации объекты передвигаются так чтобы разделить всю память на две большие области занятую свободную сохраняется указатель на их границу для выделения новой памяти достаточно лишь переместить эту границу вернув кусок из начала свободной памяти скорость доступа объектам динамической памяти объекты поля которых используются совместно перемещающий сборщик позволяет размещать памяти недалеко друг от друга тогда они вероятнее окажутся кэше процессора одновременно что уменьшит количество обращений относительно медленному озу совместимость инородным кодом перемещающий сборщик мусора вызывает затруднения при использовании кода который не управляется системой автоматического управления памятью такой код называется инородным традиционной терминологии или неуправляемым терминологии microsoft указатель на память выделенную системе неперемещающим сборщиком можно просто передать инородному коду для использования удерживая хотя бы одну обычную ссылку на объект чтобы сборщик его не удалил перемещающий сборщик меняет положение объектов памяти синхронно меняя все ссылки на них но поменять ссылки инородном коде он не может результате переданные инородному коду ссылки после перемещения объекта станут некорректными для работы инородным кодом используются различные специальные приёмы например pinning явная блокировка объекта запрещающая его перемещение во время сборки мусора поколения объектов как показывает практика недавно созданные объекты чаще становятся недостижимыми чем объекты существующие длительное время соответствии этой закономерностью многие современные сборщики мусора подразделяют все объекты на несколько поколений серий объектов близким временем существования как только память выделенная одному из поколений заканчивается этом поколении во всех более молодых производится поиск недостижимых объектов все они удаляются оставшиеся переводятся более старое поколение использование поколений сокращает время цикла сборки мусора поскольку уменьшается число просматриваемых ходе сборки объектов однако этот метод требует от среды исполнения отслеживания ссылок между разными поколениями другие механизмы неизменные объекты например java lang string java как только строке присвоили какое то значение её уже нельзя менять подпрограммы будут передавать ссылку на эту строку друг другу когда все ссылки исчезнут строка будет уничтожена сборщиком мусора финализаторы финализатор указывает что делать когда объект попадает под сборщик мусора обычно финализаторы пишут для обёрток над объектами операционной системы файлами сетевыми сокетами они автоматически закрывают соответствующий объект поскольку объект до сбора может провисеть памяти довольно долго хорошая манера закрыть файл или сокет вручную командой наподобие close требования языку системе чтобы программа могла использовать сборку мусора необходимо выполнение ряда условий относящихся языку среде исполнения самой решаемой задаче необходимость среды исполнения со сборщиком мусора естественно для сборки мусора необходима динамическая среда поддерживающая исполнение программы наличие этой среде сборщика мусора поддержка со стороны языка сборщик мусора может нормально функционировать только тогда когда он может точно отследить все ссылки на все созданные объекты очевидно если язык допускает преобразование ссылок указателей другие типы данных целые числа массивы байтов так далее такой как си си отследить использование таких преобразованных ссылок становится невозможно сборка мусора становится бессмысленной она не защищает от повисания ссылок утечек памяти поэтому языки ориентированные на использование сборки мусора обычно существенно ограничивают свободу использования указателей адресной арифметики преобразований типов указателей другим типам данных части из них вообще нет типа данных указатель части он есть но не допускает ни преобразований типа ни изменения техническая допустимость кратковременных замедлений работе программ сборка мусора выполняется периодически как правило заранее неизвестные моменты времени если приостановка работы программы на время сравнимое со временем сборки мусора может привести критическим ошибкам использовать подобной ситуации сборку мусора очевидно нельзя наличие некоторого резерва свободной памяти чем больше памяти доступно среде исполнения тем реже запускается сборщик мусора тем эффективнее его работа работа сборщика мусора системе где количество доступной сборщику памяти приближается пиковой потребности программы может оказаться неэффективной чем меньше избыток памяти тем чаще происходит запуск сборщика тем больше времени тратится на его выполнение падение программы таком режиме может оказаться слишком существенным проблемы использования вопреки часто встречающимся утверждениям наличие сборки мусора вовсе не освобождает программиста от всех проблем управления памятью освобождение других ресурсов занятых объектом помимо динамической памяти объект может владеть другими ресурсами подчас более ценными чем память если объект при создании открывает файл по завершении использования он должен его закрыть если подключается субд должен отключиться системах ручным управлением памятью это делается непосредственно перед удалением объекта из памяти чаще всего деструкторах соответствующих объектов системах со сборкой мусора обычно есть возможность выполнить некоторый код непосредственно перед удалением объекта так называемые финализаторы но для освобождения ресурсов они не годятся так как момент удаления заранее неизвестен может оказаться что ресурс освобождается намного позже чем перестаёт использоваться объект подобных случаях программисту всё равно приходится отслеживать использование объекта вручную вручную выполнять операции по освобождению занятых объектом ресурсов специально для этой цели существует интерфейс idisposable java closeable утечка памяти системах со сборкой мусора тоже могут возникать утечки памяти правда имеющие несколько другую природу ссылка на неиспользуемый объект может сохраниться другом объекте который используется становится своеобразным якорем удерживающим ненужный объект памяти например созданный объект добавляется коллекцию используемую для вспомогательных операций потом перестаёт использоваться но не удаляется из коллекции коллекция удерживает ссылку объект остаётся достижимым не подвергается сборке мусора результатом становится всё та же утечка памяти чтобы устранить подобные проблемы среда исполнения может поддерживать специальное средство так называемые слабые ссылки слабые ссылки не удерживают объект превращаются null как только объект исчезает поэтому код должен быть готов тому что однажды ссылка укажет никуда потеря эффективности при операциях частым выделением освобождением памяти некоторые действия вполне безобидные для систем ручным управлением памятью системах со сборкой мусора могут порождать несоразмерно большие накладные расходы классический пример подобной проблемы приведён ниже string out предполагается что strings содержит большое количество коротких строк из которых нужно собрать одну большую строку переменной out for string str strings out str данный код будет каждую итерацию создавать новую строковую переменную выделять под неё память данный код на языке java выглядит так как будто переменная out созданная однажды цикле каждый раз дописывается новой строкой же строки java неизменяемы поэтому данном коде на каждом проходе цикла будет происходить создание новой строковой переменной достаточной длины копирование новую переменную старого содержимого out копирование новую переменную содержимого str присваивание переменной out ссылки на новую строковую переменную при этом каждый раз блок памяти котором ранее находилось значение переменной out будет выходить из употребления ждать до запуска сборщика мусора если объединяется подобным образом строк по символов то суммарно на данную операцию будет выделено более байт памяти то есть раз больше чем размер конечной длинной строки подобные операции когда достаточно большие объекты памяти часто создаются тут же перестают использоваться ведут очень быстрому непродуктивному заполнению всей доступной памяти частому запуску сборщика мусора что определённых условиях может сильно замедлить работу программы или по крайней мере потребовать выделения ей для работы неадекватно большого объёма памяти во избежание подобных проблем программист должен хорошо представлять себе механизм автоматического управления памятью также иногда могут использоваться специальные средства для эффективного выполнения опасных операций так для оптимизации приведённого выше примера необходимо воспользоваться специальным классом stringbuilder позволяющим одним действием выделить память сразу под всю строку цикле только дописывать конец этой строки очередной фрагмент достоинства недостатки по сравнению ручным управлением памятью сборка мусора безопаснее поскольку она предотвращает утечки памяти возникновение висячих ссылок из за удаления объектов другой положительный момент упрощение самого процесса другой стороны наличие сборки мусора может вызывать неопытного разработчика чувство ложной безопасности базирующееся на представлении что вопросам выделения освобождения памяти вообще не надо уделять внимания поскольку они решаются сборщиком мусора например объект никогда не будет удалён если на него остался хотя бы один необнулённый указатель глобальной области видимости поиск такой псевдоутечки языках со сборщиком мусора особенно сложен программист не может полностью игнорировать вопрос управления памятью при наличии сборщика мусора хотя затраты ручного труда на управление памятью этом случае всё таки существенно меньше по сравнению языками полностью ручным управлением без сборщика зачастую критически важной является не только гарантия освобождения ресурса но гарантия того что он освободится до вызова какой то другой процедуры например открытые файлы входы критические секции отдавать управление этими ресурсами сборщику мусора нельзя поэтому приходится убирать их вручную впрочем последнее время даже языках со сборщиком мусора вводят возможность создавать классы вызовом специального метода деструктора dispose при выходе из зоны видимости во многих случаях системы со сборкой мусора демонстрируют меньшую эффективность как по скорости так по объёму используемой памяти что неизбежно так как сборщик мусора сам потребляет ресурсы нуждается некотором избытке свободной памяти для нормальной работы кроме того системах со сборкой мусора сложнее реализуются низкоуровневые алгоритмы требующие прямого доступа оперативной памяти компьютера поскольку свободное использование указателей невозможно прямой доступ памяти требует наличия специальных интерфейсов написанных на низкоуровневых языках другой стороны современных системах со сборкой мусора операция выделения памяти сведена элементарному добавлению блока конец кучи причём куча время от времени уплотняется уменьшая фрагментацию данных поддержка некоторых императивных языках автоматического вызова деструктора ада delphi также более простая чем сборка мусора технология использования умных ссылок отслеживания количества ссылок на объект непосредственно нём автоматическое удаление при удалении последней ссылки как это сделано технологии com значительно снижает вероятность утечек позволяя концентрировать опасные места внутри реализации класса при этом не требуя лишних ресурсов хотя требует при этом более высокой квалификации программиста конечно писать код освобождения ресурсов всё равно придётся но автоматические деструкторы дадут уверенность что этот код обязательно вызовется впрочем для наиболее часто используемых ресурсов во всех популярных языках поддерживающих автодеструкторы уже есть автоматические обёртки которые сами закрывают ресурс благодаря чему забота ресурсах становится едва ли не проще чем непредсказуемым сборщиком мусора существенное удобство от сборки мусора возникает тогда когда динамически созданные объекты живут длительное время многократно дублируются ссылки на них передаются между различными участками программы таких программах общем случае достаточно сложно безошибочно определить место где объект перестал использоваться его можно удалять поскольку именно такая ситуация складывается при широком использовании динамически изменяемых структур данных списки деревья графы сборка мусора является необходимой широко использующих такие структуры функциональных логических языках типа хаскелла лиспа или пролога использование сборки мусора традиционных императивных языках основанных на структурной парадигме возможно дополненной объектными средствами определяется желаемым соотношением между простотой скоростью разработки программ эффективностью её выполнения управление памятью конкретных языках системах сборка мусора часто ручному управлению памятью при котором программист явно указывает когда какие области памяти надо освободить однако есть языки которых используется комбинация двух методов управления памятью равно как есть другие технологии решения той же фундаментальной проблемы например en region inference некоторые языки требуют использования механизма сборки мусора соответствии со своей спецификацией java eiffel другие по причинам эффективности реализации например формальные языки для лямбда исчисления эти языки называются языками со сборкой мусора многие языки со сборкой мусора не имеют возможностей для явного ручного удаления объектов например оператора delete благодаря чему возникновение висячих ссылок исключается принципе сборщик мусора лишь занимается удалением объектов на которые нет ссылок из программы некоторые языки например modula или позволяют использовать как ручное управление памятью так сборку мусора одном приложении используя две отдельные кучи см также утечка памяти слабая ссылка примечания категория управление памятью категория концепции языков категория статьи примерами кода java